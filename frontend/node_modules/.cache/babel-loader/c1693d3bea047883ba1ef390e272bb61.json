{"ast":null,"code":"import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n  const descendants = vel.children();\n\n  while (descendants.length > 0) {\n    const descendant = descendants.shift();\n\n    if (fn(descendant)) {\n      descendants.push(...descendant.children());\n    }\n  }\n}\n\nexport const mask = HighlighterView.extend({\n  tagName: 'rect',\n  className: 'highlight-mask',\n  attributes: {\n    'pointer-events': 'none'\n  },\n  options: {\n    padding: 3,\n    maskClip: MASK_CLIP,\n    deep: false,\n    attrs: {\n      'stroke': '#FEB663',\n      'stroke-width': 3,\n      'stroke-linecap': 'butt',\n      'stroke-linejoin': 'miter'\n    }\n  },\n  VISIBLE: 'white',\n  INVISIBLE: 'black',\n  MASK_ROOT_ATTRIBUTE_BLACKLIST: ['marker-start', 'marker-end', 'marker-mid', 'transform', 'stroke-dasharray'],\n  MASK_CHILD_ATTRIBUTE_BLACKLIST: ['stroke', 'fill', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill-opacity', 'marker-start', 'marker-end', 'marker-mid'],\n  // TODO: change the list to a function callback\n  MASK_REPLACE_TAGS: ['FOREIGNOBJECT', 'IMAGE', 'USE', 'TEXT', 'TSPAN', 'TEXTPATH'],\n  // TODO: change the list to a function callback\n  MASK_REMOVE_TAGS: ['TEXT', 'TSPAN', 'TEXTPATH'],\n\n  transformMaskChild(cellView, childEl) {\n    const {\n      MASK_CHILD_ATTRIBUTE_BLACKLIST,\n      MASK_REPLACE_TAGS,\n      MASK_REMOVE_TAGS\n    } = this;\n    const childTagName = childEl.tagName(); // Do not include the element in the mask's image\n\n    if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n      childEl.remove();\n      return false;\n    } // Replace the element with a rectangle\n\n\n    if (MASK_REPLACE_TAGS.includes(childTagName)) {\n      // Note: clone() method does not change the children ids\n      const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n\n      if (originalChild) {\n        const {\n          node: originalNode\n        } = originalChild;\n        let childBBox = cellView.getNodeBoundingRect(originalNode);\n\n        if (cellView.model.isElement()) {\n          childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n        }\n\n        const replacement = V('rect', childBBox.toJSON());\n        const {\n          x: ox,\n          y: oy\n        } = childBBox.center();\n        const {\n          angle,\n          cx = ox,\n          cy = oy\n        } = originalChild.rotate();\n        if (angle) replacement.rotate(angle, cx, cy); // Note: it's not important to keep the same sibling index since all subnodes are filled\n\n        childEl.parent().append(replacement);\n      }\n\n      childEl.remove();\n      return false;\n    } // Keep the element, but clean it from certain attributes\n\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n      childEl.removeAttr(attrName);\n    });\n    return true;\n  },\n\n  transformMaskRoot(_cellView, rootEl) {\n    const {\n      MASK_ROOT_ATTRIBUTE_BLACKLIST\n    } = this;\n    MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n      rootEl.removeAttr(attrName);\n    });\n  },\n\n  getMaskShape(cellView, vel) {\n    const {\n      options,\n      MASK_REPLACE_TAGS\n    } = this;\n    const {\n      deep\n    } = options;\n    const tagName = vel.tagName();\n    let maskRoot;\n\n    if (tagName === 'G') {\n      if (!deep) return null;\n      maskRoot = vel.clone();\n      forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n    } else {\n      if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n      maskRoot = vel.clone();\n    }\n\n    this.transformMaskRoot(cellView, maskRoot);\n    return maskRoot;\n  },\n\n  getMaskId() {\n    return `highlight-mask-${this.cid}`;\n  },\n\n  getMask(cellView, vNode) {\n    const {\n      VISIBLE,\n      INVISIBLE,\n      options\n    } = this;\n    const {\n      padding,\n      attrs\n    } = options;\n    const strokeWidth = 'stroke-width' in attrs ? attrs['stroke-width'] : 1;\n    const hasNodeFill = vNode.attr('fill') !== 'none';\n    let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n    if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1; // stroke of the invisible shape\n\n    const minStrokeWidth = magnetStrokeWidth + padding * 2; // stroke of the visible shape\n\n    const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n    let maskEl = this.getMaskShape(cellView, vNode);\n\n    if (!maskEl) {\n      const nodeBBox = cellView.getNodeBoundingRect(vNode.node); // Make sure the rect is visible\n\n      nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n      maskEl = V('rect', nodeBBox.toJSON());\n    }\n\n    maskEl.attr(attrs);\n    return V('mask', {\n      'id': this.getMaskId()\n    }).append([maskEl.clone().attr({\n      'fill': hasNodeFill ? VISIBLE : 'none',\n      'stroke': VISIBLE,\n      'stroke-width': maxStrokeWidth\n    }), maskEl.clone().attr({\n      'fill': hasNodeFill ? INVISIBLE : 'none',\n      'stroke': INVISIBLE,\n      'stroke-width': minStrokeWidth\n    })]);\n  },\n\n  removeMask(paper) {\n    const maskNode = paper.svg.getElementById(this.getMaskId());\n\n    if (maskNode) {\n      paper.defs.removeChild(maskNode);\n    }\n  },\n\n  addMask(paper, maskEl) {\n    paper.defs.appendChild(maskEl.node);\n  },\n\n  highlight(cellView, node) {\n    const {\n      options,\n      vel\n    } = this;\n    const {\n      padding,\n      attrs,\n      maskClip = MASK_CLIP,\n      layer\n    } = options;\n    const color = 'stroke' in attrs ? attrs['stroke'] : '#000000';\n\n    if (!layer && node === cellView.el) {\n      // If the highlighter is appended to the cellView\n      // and we measure the size of the cellView wrapping group\n      // it's necessary to remove the highlighter first\n      vel.remove();\n    }\n\n    const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n    const maskEl = this.getMask(cellView, V(node));\n    this.addMask(cellView.paper, maskEl);\n    vel.attr(highlighterBBox.toJSON());\n    vel.attr({\n      'transform': V.matrixToTransformString(cellView.getNodeMatrix(node)),\n      'mask': `url(#${maskEl.id})`,\n      'fill': color\n    });\n  },\n\n  unhighlight(cellView) {\n    this.removeMask(cellView.paper);\n  }\n\n});","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/highlighters/mask.mjs"],"names":["V","HighlighterView","MASK_CLIP","forEachDescendant","vel","fn","descendants","children","length","descendant","shift","push","mask","extend","tagName","className","attributes","options","padding","maskClip","deep","attrs","VISIBLE","INVISIBLE","MASK_ROOT_ATTRIBUTE_BLACKLIST","MASK_CHILD_ATTRIBUTE_BLACKLIST","MASK_REPLACE_TAGS","MASK_REMOVE_TAGS","transformMaskChild","cellView","childEl","childTagName","isSVGGraphicsElement","includes","remove","originalChild","findOne","id","node","originalNode","childBBox","getNodeBoundingRect","model","isElement","transformRect","getNodeMatrix","replacement","toJSON","x","ox","y","oy","center","angle","cx","cy","rotate","parent","append","forEach","attrName","attr","removeAttr","transformMaskRoot","_cellView","rootEl","getMaskShape","maskRoot","clone","maskChild","getMaskId","cid","getMask","vNode","strokeWidth","hasNodeFill","magnetStrokeWidth","parseFloat","isNaN","minStrokeWidth","maxStrokeWidth","maskEl","nodeBBox","inflate","width","height","removeMask","paper","maskNode","svg","getElementById","defs","removeChild","addMask","appendChild","highlight","layer","color","el","highlighterBBox","matrixToTransformString","unhighlight"],"mappings":"AAAA,OAAOA,CAAP,MAAc,gBAAd;AACA,SAASC,eAAT,QAAgC,4BAAhC;AAEA,MAAMC,SAAS,GAAG,EAAlB;;AAEA,SAASC,iBAAT,CAA2BC,GAA3B,EAAgCC,EAAhC,EAAoC;AAChC,QAAMC,WAAW,GAAGF,GAAG,CAACG,QAAJ,EAApB;;AACA,SAAOD,WAAW,CAACE,MAAZ,GAAqB,CAA5B,EAA+B;AAC3B,UAAMC,UAAU,GAAGH,WAAW,CAACI,KAAZ,EAAnB;;AACA,QAAIL,EAAE,CAACI,UAAD,CAAN,EAAoB;AAChBH,MAAAA,WAAW,CAACK,IAAZ,CAAiB,GAAGF,UAAU,CAACF,QAAX,EAApB;AACH;AACJ;AACJ;;AAED,OAAO,MAAMK,IAAI,GAAGX,eAAe,CAACY,MAAhB,CAAuB;AAEvCC,EAAAA,OAAO,EAAE,MAF8B;AAGvCC,EAAAA,SAAS,EAAE,gBAH4B;AAIvCC,EAAAA,UAAU,EAAE;AACR,sBAAkB;AADV,GAJ2B;AAQvCC,EAAAA,OAAO,EAAE;AACLC,IAAAA,OAAO,EAAE,CADJ;AAELC,IAAAA,QAAQ,EAAEjB,SAFL;AAGLkB,IAAAA,IAAI,EAAE,KAHD;AAILC,IAAAA,KAAK,EAAE;AACH,gBAAU,SADP;AAEH,sBAAgB,CAFb;AAGH,wBAAkB,MAHf;AAIH,yBAAmB;AAJhB;AAJF,GAR8B;AAoBvCC,EAAAA,OAAO,EAAE,OApB8B;AAqBvCC,EAAAA,SAAS,EAAE,OArB4B;AAuBvCC,EAAAA,6BAA6B,EAAE,CAC3B,cAD2B,EAE3B,YAF2B,EAG3B,YAH2B,EAI3B,WAJ2B,EAK3B,kBAL2B,CAvBQ;AA+BvCC,EAAAA,8BAA8B,EAAE,CAC5B,QAD4B,EAE5B,MAF4B,EAG5B,cAH4B,EAI5B,gBAJ4B,EAK5B,kBAL4B,EAM5B,cAN4B,EAO5B,cAP4B,EAQ5B,YAR4B,EAS5B,YAT4B,CA/BO;AA2CvC;AACAC,EAAAA,iBAAiB,EAAE,CACf,eADe,EAEf,OAFe,EAGf,KAHe,EAIf,MAJe,EAKf,OALe,EAMf,UANe,CA5CoB;AAqDvC;AACAC,EAAAA,gBAAgB,EAAE,CACd,MADc,EAEd,OAFc,EAGd,UAHc,CAtDqB;;AA4DvCC,EAAAA,kBAAkB,CAACC,QAAD,EAAWC,OAAX,EAAoB;AAClC,UAAM;AACFL,MAAAA,8BADE;AAEFC,MAAAA,iBAFE;AAGFC,MAAAA;AAHE,QAIF,IAJJ;AAKA,UAAMI,YAAY,GAAGD,OAAO,CAAChB,OAAR,EAArB,CANkC,CAOlC;;AACA,QAAI,CAACd,CAAC,CAACgC,oBAAF,CAAuBF,OAAvB,CAAD,IAAoCH,gBAAgB,CAACM,QAAjB,CAA0BF,YAA1B,CAAxC,EAAiF;AAC7ED,MAAAA,OAAO,CAACI,MAAR;AACA,aAAO,KAAP;AACH,KAXiC,CAYlC;;;AACA,QAAIR,iBAAiB,CAACO,QAAlB,CAA2BF,YAA3B,CAAJ,EAA8C;AAC1C;AACA,YAAMI,aAAa,GAAGN,QAAQ,CAACzB,GAAT,CAAagC,OAAb,CAAsB,IAAGN,OAAO,CAACO,EAAG,EAApC,CAAtB;;AACA,UAAIF,aAAJ,EAAmB;AACf,cAAM;AAAEG,UAAAA,IAAI,EAAEC;AAAR,YAAyBJ,aAA/B;AACA,YAAIK,SAAS,GAAGX,QAAQ,CAACY,mBAAT,CAA6BF,YAA7B,CAAhB;;AACA,YAAIV,QAAQ,CAACa,KAAT,CAAeC,SAAf,EAAJ,EAAgC;AAC5BH,UAAAA,SAAS,GAAGxC,CAAC,CAAC4C,aAAF,CAAgBJ,SAAhB,EAA2BX,QAAQ,CAACgB,aAAT,CAAuBN,YAAvB,CAA3B,CAAZ;AACH;;AACD,cAAMO,WAAW,GAAG9C,CAAC,CAAC,MAAD,EAASwC,SAAS,CAACO,MAAV,EAAT,CAArB;AACA,cAAM;AAAEC,UAAAA,CAAC,EAAEC,EAAL;AAASC,UAAAA,CAAC,EAAEC;AAAZ,YAAmBX,SAAS,CAACY,MAAV,EAAzB;AACA,cAAM;AAAEC,UAAAA,KAAF;AAASC,UAAAA,EAAE,GAAGL,EAAd;AAAkBM,UAAAA,EAAE,GAAGJ;AAAvB,YAA8BhB,aAAa,CAACqB,MAAd,EAApC;AACA,YAAIH,KAAJ,EAAWP,WAAW,CAACU,MAAZ,CAAmBH,KAAnB,EAA0BC,EAA1B,EAA8BC,EAA9B,EATI,CAUf;;AACAzB,QAAAA,OAAO,CAAC2B,MAAR,GAAiBC,MAAjB,CAAwBZ,WAAxB;AACH;;AACDhB,MAAAA,OAAO,CAACI,MAAR;AACA,aAAO,KAAP;AACH,KA/BiC,CAgClC;;;AACAT,IAAAA,8BAA8B,CAACkC,OAA/B,CAAuCC,QAAQ,IAAI;AAC/C,UAAIA,QAAQ,KAAK,MAAb,IAAuB9B,OAAO,CAAC+B,IAAR,CAAa,MAAb,MAAyB,MAApD,EAA4D;AAC5D/B,MAAAA,OAAO,CAACgC,UAAR,CAAmBF,QAAnB;AACH,KAHD;AAIA,WAAO,IAAP;AACH,GAlGsC;;AAoGvCG,EAAAA,iBAAiB,CAACC,SAAD,EAAYC,MAAZ,EAAoB;AACjC,UAAM;AAAEzC,MAAAA;AAAF,QAAoC,IAA1C;AACAA,IAAAA,6BAA6B,CAACmC,OAA9B,CAAsCC,QAAQ,IAAI;AAC9CK,MAAAA,MAAM,CAACH,UAAP,CAAkBF,QAAlB;AACH,KAFD;AAGH,GAzGsC;;AA2GvCM,EAAAA,YAAY,CAACrC,QAAD,EAAWzB,GAAX,EAAgB;AACxB,UAAM;AAAEa,MAAAA,OAAF;AAAWS,MAAAA;AAAX,QAAiC,IAAvC;AACA,UAAM;AAAEN,MAAAA;AAAF,QAAWH,OAAjB;AACA,UAAMH,OAAO,GAAGV,GAAG,CAACU,OAAJ,EAAhB;AACA,QAAIqD,QAAJ;;AACA,QAAIrD,OAAO,KAAK,GAAhB,EAAqB;AACjB,UAAI,CAACM,IAAL,EAAW,OAAO,IAAP;AACX+C,MAAAA,QAAQ,GAAG/D,GAAG,CAACgE,KAAJ,EAAX;AACAjE,MAAAA,iBAAiB,CAACgE,QAAD,EAAWE,SAAS,IAAI,KAAKzC,kBAAL,CAAwBC,QAAxB,EAAkCwC,SAAlC,CAAxB,CAAjB;AACH,KAJD,MAIO;AACH,UAAI3C,iBAAiB,CAACO,QAAlB,CAA2BnB,OAA3B,CAAJ,EAAyC,OAAO,IAAP;AACzCqD,MAAAA,QAAQ,GAAG/D,GAAG,CAACgE,KAAJ,EAAX;AACH;;AACD,SAAKL,iBAAL,CAAuBlC,QAAvB,EAAiCsC,QAAjC;AACA,WAAOA,QAAP;AACH,GA1HsC;;AA4HvCG,EAAAA,SAAS,GAAG;AACR,WAAQ,kBAAiB,KAAKC,GAAI,EAAlC;AACH,GA9HsC;;AAgIvCC,EAAAA,OAAO,CAAC3C,QAAD,EAAW4C,KAAX,EAAkB;AAErB,UAAM;AAAEnD,MAAAA,OAAF;AAAWC,MAAAA,SAAX;AAAsBN,MAAAA;AAAtB,QAAkC,IAAxC;AACA,UAAM;AAAEC,MAAAA,OAAF;AAAWG,MAAAA;AAAX,QAAqBJ,OAA3B;AAEA,UAAMyD,WAAW,GAAI,kBAAkBrD,KAAnB,GAA4BA,KAAK,CAAC,cAAD,CAAjC,GAAoD,CAAxE;AACA,UAAMsD,WAAW,GAAGF,KAAK,CAACZ,IAAN,CAAW,MAAX,MAAuB,MAA3C;AACA,QAAIe,iBAAiB,GAAGC,UAAU,CAACJ,KAAK,CAACZ,IAAN,CAAW,cAAX,CAAD,CAAlC;AACA,QAAIiB,KAAK,CAACF,iBAAD,CAAT,EAA8BA,iBAAiB,GAAG,CAApB,CART,CASrB;;AACA,UAAMG,cAAc,GAAGH,iBAAiB,GAAG1D,OAAO,GAAG,CAArD,CAVqB,CAWrB;;AACA,UAAM8D,cAAc,GAAGD,cAAc,GAAGL,WAAW,GAAG,CAAtD;AACA,QAAIO,MAAM,GAAG,KAAKf,YAAL,CAAkBrC,QAAlB,EAA4B4C,KAA5B,CAAb;;AACA,QAAI,CAACQ,MAAL,EAAa;AACT,YAAMC,QAAQ,GAAGrD,QAAQ,CAACY,mBAAT,CAA6BgC,KAAK,CAACnC,IAAnC,CAAjB,CADS,CAET;;AACA4C,MAAAA,QAAQ,CAACC,OAAT,CAAiBD,QAAQ,CAACE,KAAT,GAAiB,CAAjB,GAAqB,GAAtC,EAA2CF,QAAQ,CAACG,MAAT,GAAkB,CAAlB,GAAsB,GAAjE;AACAJ,MAAAA,MAAM,GAAIjF,CAAC,CAAC,MAAD,EAASkF,QAAQ,CAACnC,MAAT,EAAT,CAAX;AACH;;AACDkC,IAAAA,MAAM,CAACpB,IAAP,CAAYxC,KAAZ;AACA,WAAOrB,CAAC,CAAC,MAAD,EAAS;AACb,YAAM,KAAKsE,SAAL;AADO,KAAT,CAAD,CAEJZ,MAFI,CAEG,CACNuB,MAAM,CAACb,KAAP,GAAeP,IAAf,CAAoB;AAChB,cAAQc,WAAW,GAAGrD,OAAH,GAAa,MADhB;AAEhB,gBAAUA,OAFM;AAGhB,sBAAgB0D;AAHA,KAApB,CADM,EAMNC,MAAM,CAACb,KAAP,GAAeP,IAAf,CAAoB;AAChB,cAAQc,WAAW,GAAGpD,SAAH,GAAe,MADlB;AAEhB,gBAAUA,SAFM;AAGhB,sBAAgBwD;AAHA,KAApB,CANM,CAFH,CAAP;AAcH,GAnKsC;;AAqKvCO,EAAAA,UAAU,CAACC,KAAD,EAAQ;AACd,UAAMC,QAAQ,GAAGD,KAAK,CAACE,GAAN,CAAUC,cAAV,CAAyB,KAAKpB,SAAL,EAAzB,CAAjB;;AACA,QAAIkB,QAAJ,EAAc;AACVD,MAAAA,KAAK,CAACI,IAAN,CAAWC,WAAX,CAAuBJ,QAAvB;AACH;AACJ,GA1KsC;;AA4KvCK,EAAAA,OAAO,CAACN,KAAD,EAAQN,MAAR,EAAgB;AACnBM,IAAAA,KAAK,CAACI,IAAN,CAAWG,WAAX,CAAuBb,MAAM,CAAC3C,IAA9B;AACH,GA9KsC;;AAgLvCyD,EAAAA,SAAS,CAAClE,QAAD,EAAWS,IAAX,EAAiB;AACtB,UAAM;AAAErB,MAAAA,OAAF;AAAWb,MAAAA;AAAX,QAAmB,IAAzB;AACA,UAAM;AAAEc,MAAAA,OAAF;AAAWG,MAAAA,KAAX;AAAkBF,MAAAA,QAAQ,GAAGjB,SAA7B;AAAwC8F,MAAAA;AAAxC,QAAkD/E,OAAxD;AACA,UAAMgF,KAAK,GAAI,YAAY5E,KAAb,GAAsBA,KAAK,CAAC,QAAD,CAA3B,GAAwC,SAAtD;;AACA,QAAI,CAAC2E,KAAD,IAAU1D,IAAI,KAAKT,QAAQ,CAACqE,EAAhC,EAAoC;AAChC;AACA;AACA;AACA9F,MAAAA,GAAG,CAAC8B,MAAJ;AACH;;AACD,UAAMiE,eAAe,GAAGtE,QAAQ,CAACY,mBAAT,CAA6BH,IAA7B,EAAmC6C,OAAnC,CAA2CjE,OAAO,GAAGC,QAArD,CAAxB;AACA,UAAM8D,MAAM,GAAG,KAAKT,OAAL,CAAa3C,QAAb,EAAuB7B,CAAC,CAACsC,IAAD,CAAxB,CAAf;AACA,SAAKuD,OAAL,CAAahE,QAAQ,CAAC0D,KAAtB,EAA6BN,MAA7B;AACA7E,IAAAA,GAAG,CAACyD,IAAJ,CAASsC,eAAe,CAACpD,MAAhB,EAAT;AACA3C,IAAAA,GAAG,CAACyD,IAAJ,CAAS;AACL,mBAAa7D,CAAC,CAACoG,uBAAF,CAA0BvE,QAAQ,CAACgB,aAAT,CAAuBP,IAAvB,CAA1B,CADR;AAEL,cAAS,QAAO2C,MAAM,CAAC5C,EAAG,GAFrB;AAGL,cAAQ4D;AAHH,KAAT;AAKH,GAnMsC;;AAqMvCI,EAAAA,WAAW,CAACxE,QAAD,EAAW;AAClB,SAAKyD,UAAL,CAAgBzD,QAAQ,CAAC0D,KAAzB;AACH;;AAvMsC,CAAvB,CAAb","sourcesContent":["import V from '../V/index.mjs';\nimport { HighlighterView } from '../dia/HighlighterView.mjs';\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nexport const mask = HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray'\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!V.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = V.transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = V('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n\n        const strokeWidth = ('stroke-width' in attrs) ? attrs['stroke-width'] : 1;\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  V('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return V('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const maskEl = this.getMask(cellView, V(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': V.matrixToTransformString(cellView.getNodeMatrix(node)),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n"]},"metadata":{},"sourceType":"module"}