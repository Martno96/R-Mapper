{"ast":null,"code":"import { config } from '../config/index.mjs';\nimport { assign, invoke, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs'; // Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n  /**\n   * @abstract\n   */\n  _removePorts: function () {// implemented in ports.js\n  },\n\n  /**\n   *\n   * @abstract\n   */\n  _renderPorts: function () {// implemented in ports.js\n  },\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('element');\n    return classNames.join(' ');\n  },\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments);\n\n    this._initializePorts();\n  },\n  presentationAttributes: {\n    'attrs': ['UPDATE'],\n    'position': ['TRANSLATE', 'TOOLS'],\n    'size': ['RESIZE', 'PORTS', 'TOOLS'],\n    'angle': ['ROTATE', 'TOOLS'],\n    'markup': ['RENDER'],\n    'ports': ['PORTS']\n  },\n  initFlag: ['RENDER'],\n  UPDATE_PRIORITY: 0,\n  confirmUpdate: function (flag, opt) {\n    const {\n      useCSSSelectors\n    } = config;\n\n    if (this.hasFlag(flag, 'PORTS')) {\n      this._removePorts();\n\n      this._cleanPortsCache();\n    }\n\n    let transformHighlighters = false;\n\n    if (this.hasFlag(flag, 'RENDER')) {\n      this.render();\n      this.updateTools(opt);\n      this.updateHighlighters(true);\n      transformHighlighters = true;\n      flag = this.removeFlag(flag, ['RENDER', 'UPDATE', 'RESIZE', 'TRANSLATE', 'ROTATE', 'PORTS', 'TOOLS']);\n    } else {\n      let updateHighlighters = false; // Skip this branch if render is required\n\n      if (this.hasFlag(flag, 'RESIZE')) {\n        this.resize(opt);\n        updateHighlighters = true; // Resize method is calling `update()` internally\n\n        flag = this.removeFlag(flag, ['RESIZE', 'UPDATE']);\n      }\n\n      if (this.hasFlag(flag, 'UPDATE')) {\n        this.update(this.model, null, opt);\n        flag = this.removeFlag(flag, 'UPDATE');\n        updateHighlighters = true;\n\n        if (useCSSSelectors) {\n          // `update()` will render ports when useCSSSelectors are enabled\n          flag = this.removeFlag(flag, 'PORTS');\n        }\n      }\n\n      if (this.hasFlag(flag, 'TRANSLATE')) {\n        this.translate();\n        flag = this.removeFlag(flag, 'TRANSLATE');\n        transformHighlighters = true;\n      }\n\n      if (this.hasFlag(flag, 'ROTATE')) {\n        this.rotate();\n        flag = this.removeFlag(flag, 'ROTATE');\n        transformHighlighters = true;\n      }\n\n      if (this.hasFlag(flag, 'PORTS')) {\n        this._renderPorts();\n\n        updateHighlighters = true;\n        flag = this.removeFlag(flag, 'PORTS');\n      }\n\n      if (updateHighlighters) {\n        this.updateHighlighters(false);\n      }\n    }\n\n    if (transformHighlighters) {\n      this.transformHighlighters();\n    }\n\n    if (this.hasFlag(flag, 'TOOLS')) {\n      this.updateTools(opt);\n      flag = this.removeFlag(flag, 'TOOLS');\n    }\n\n    return flag;\n  },\n\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {},\n  update: function (_, renderingOnlyAttrs) {\n    this.cleanNodesCache(); // When CSS selector strings are used, make sure no rule matches port nodes.\n\n    const {\n      useCSSSelectors\n    } = config;\n    if (useCSSSelectors) this._removePorts();\n    var model = this.model;\n    var modelAttrs = model.attr();\n    this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n      rootBBox: new Rect(model.size()),\n      selectors: this.selectors,\n      scalableNode: this.scalableNode,\n      rotatableNode: this.rotatableNode,\n      // Use rendering only attributes if they differs from the model attributes\n      roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs\n    });\n\n    if (useCSSSelectors) {\n      this._renderPorts();\n    }\n  },\n  rotatableSelector: 'rotatable',\n  scalableSelector: 'scalable',\n  scalableNode: null,\n  rotatableNode: null,\n  // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n  // default markup is not desirable.\n  renderMarkup: function () {\n    var element = this.model;\n    var markup = element.get('markup') || element.markup;\n    if (!markup) throw new Error('dia.ElementView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.ElementView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el);\n    var selectors = this.selectors = doc.selectors;\n    this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n    this.scalableNode = V(selectors[this.scalableSelector]) || null; // Fragment\n\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    var vel = this.vel;\n    vel.append(V(markup)); // Cache transformation groups\n\n    this.rotatableNode = vel.findOne('.rotatable');\n    this.scalableNode = vel.findOne('.scalable');\n    var selectors = this.selectors = {};\n    selectors[this.selector] = this.el;\n  },\n  render: function () {\n    this.vel.empty();\n    this.renderMarkup();\n\n    if (this.scalableNode) {\n      // Double update is necessary for elements with the scalable group only\n      // Note the resize() triggers the other `update`.\n      this.update();\n    }\n\n    this.resize();\n\n    if (this.rotatableNode) {\n      // Translate transformation is applied on `this.el` while the rotation transformation\n      // on `this.rotatableNode`\n      this.rotate();\n      this.translate();\n    } else {\n      this.updateTransformation();\n    }\n\n    if (!config.useCSSSelectors) this._renderPorts();\n    return this;\n  },\n  resize: function (opt) {\n    if (this.scalableNode) return this.sgResize(opt);\n    if (this.model.attributes.angle) this.rotate();\n    this.update();\n  },\n  translate: function () {\n    if (this.rotatableNode) return this.rgTranslate();\n    this.updateTransformation();\n  },\n  rotate: function () {\n    if (this.rotatableNode) {\n      this.rgRotate(); // It's necessary to call the update for the nodes outside\n      // the rotatable group referencing nodes inside the group\n\n      this.update();\n      return;\n    }\n\n    this.updateTransformation();\n  },\n  updateTransformation: function () {\n    var transformation = this.getTranslateString();\n    var rotateString = this.getRotateString();\n    if (rotateString) transformation += ' ' + rotateString;\n    this.vel.attr('transform', transformation);\n  },\n  getTranslateString: function () {\n    var position = this.model.attributes.position;\n    return 'translate(' + position.x + ',' + position.y + ')';\n  },\n  getRotateString: function () {\n    var attributes = this.model.attributes;\n    var angle = attributes.angle;\n    if (!angle) return null;\n    var size = attributes.size;\n    return 'rotate(' + angle + ',' + size.width / 2 + ',' + size.height / 2 + ')';\n  },\n  // Rotatable & Scalable Group\n  // always slower, kept mainly for backwards compatibility\n  rgRotate: function () {\n    this.rotatableNode.attr('transform', this.getRotateString());\n  },\n  rgTranslate: function () {\n    this.vel.attr('transform', this.getTranslateString());\n  },\n  sgResize: function (opt) {\n    var model = this.model;\n    var angle = model.angle();\n    var size = model.size();\n    var scalable = this.scalableNode; // Getting scalable group's bbox.\n    // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n    // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n\n    var recursive = false;\n\n    if (scalable.node.getElementsByTagName('path').length > 0) {\n      // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n      // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n      recursive = true;\n    }\n\n    var scalableBBox = scalable.getBBox({\n      recursive: recursive\n    }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n    // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n\n    var sx = size.width / (scalableBBox.width || 1);\n    var sy = size.height / (scalableBBox.height || 1);\n    scalable.attr('transform', 'scale(' + sx + ',' + sy + ')'); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n    // Order of transformations is significant but we want to reconstruct the object always in the order:\n    // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n    // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n    // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n    // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n    // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n    // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\n    var rotatable = this.rotatableNode;\n    var rotation = rotatable && rotatable.attr('transform');\n\n    if (rotation) {\n      rotatable.attr('transform', rotation + ' rotate(' + -angle + ',' + size.width / 2 + ',' + size.height / 2 + ')');\n      var rotatableBBox = scalable.getBBox({\n        target: this.paper.cells\n      }); // Store new x, y and perform rotate() again against the new rotation origin.\n\n      model.set('position', {\n        x: rotatableBBox.x,\n        y: rotatableBBox.y\n      }, assign({\n        updateHandled: true\n      }, opt));\n      this.translate();\n      this.rotate();\n    } // Update must always be called on non-rotated element. Otherwise, relative positioning\n    // would work with wrong (rotated) bounding boxes.\n\n\n    this.update();\n  },\n  // Embedding mode methods.\n  // -----------------------\n  prepareEmbedding: function (data) {\n    data || (data = {});\n    var model = data.model || this.model;\n    var paper = data.paper || this.paper;\n    var graph = paper.model;\n    model.startBatch('to-front'); // Bring the model to the front with all his embeds.\n\n    model.toFront({\n      deep: true,\n      ui: true\n    }); // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n    // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n\n    var maxZ = graph.getElements().reduce(function (max, cell) {\n      return Math.max(max, cell.attributes.z || 0);\n    }, 0); // Move to front also all the inbound and outbound links that are connected\n    // to any of the element descendant. If we bring to front only embedded elements,\n    // links connected to them would stay in the background.\n\n    var connectedLinks = graph.getConnectedLinks(model, {\n      deep: true,\n      includeEnclosed: true\n    });\n    connectedLinks.forEach(function (link) {\n      if (link.attributes.z <= maxZ) link.set('z', maxZ + 1, {\n        ui: true\n      });\n    });\n    model.stopBatch('to-front'); // Before we start looking for suitable parent we remove the current one.\n\n    var parentId = model.parent();\n\n    if (parentId) {\n      graph.getCell(parentId).unembed(model, {\n        ui: true\n      });\n    }\n  },\n  processEmbedding: function (data) {\n    data || (data = {});\n    var model = data.model || this.model;\n    var paper = data.paper || this.paper;\n    var paperOptions = paper.options;\n    var candidates = [];\n\n    if (isFunction(paperOptions.findParentBy)) {\n      var parents = toArray(paperOptions.findParentBy.call(paper.model, this));\n      candidates = parents.filter(function (el) {\n        return el instanceof Cell && this.model.id !== el.id && !el.isEmbeddedIn(this.model);\n      }.bind(this));\n    } else {\n      candidates = paper.model.findModelsUnderElement(model, {\n        searchBy: paperOptions.findParentBy\n      });\n    }\n\n    if (paperOptions.frontParentOnly) {\n      // pick the element with the highest `z` index\n      candidates = candidates.slice(-1);\n    }\n\n    var newCandidateView = null;\n    var prevCandidateView = data.candidateEmbedView; // iterate over all candidates starting from the last one (has the highest z-index).\n\n    for (var i = candidates.length - 1; i >= 0; i--) {\n      var candidate = candidates[i];\n\n      if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n        // candidate remains the same\n        newCandidateView = prevCandidateView;\n        break;\n      } else {\n        var view = candidate.findView(paper);\n\n        if (paperOptions.validateEmbedding.call(paper, this, view)) {\n          // flip to the new candidate\n          newCandidateView = view;\n          break;\n        }\n      }\n    }\n\n    if (newCandidateView && newCandidateView != prevCandidateView) {\n      // A new candidate view found. Highlight the new one.\n      this.clearEmbedding(data);\n      data.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n    }\n\n    if (!newCandidateView && prevCandidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      this.clearEmbedding(data);\n    }\n  },\n  clearEmbedding: function (data) {\n    data || (data = {});\n    var candidateView = data.candidateEmbedView;\n\n    if (candidateView) {\n      // No candidate view found. Unhighlight the previous candidate.\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    }\n  },\n  finalizeEmbedding: function (data) {\n    data || (data = {});\n    var candidateView = data.candidateEmbedView;\n    var model = data.model || this.model;\n    var paper = data.paper || this.paper;\n\n    if (candidateView) {\n      // We finished embedding. Candidate view is chosen to become the parent of the model.\n      candidateView.model.embed(model, {\n        ui: true\n      });\n      candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), {\n        embedding: true\n      });\n      data.candidateEmbedView = null;\n    }\n\n    invoke(paper.model.getConnectedLinks(model, {\n      deep: true\n    }), 'reparent', {\n      ui: true\n    });\n  },\n  getDelegatedView: function () {\n    var view = this;\n    var model = view.model;\n    var paper = view.paper;\n\n    while (view) {\n      if (model.isLink()) break;\n      if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n      model = model.getParentCell();\n      view = paper.findViewByModel(model);\n    }\n\n    return null;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n\n    if (nodeSelector) {\n      const port = this.findAttribute('port', el);\n\n      if (port) {\n        const proxyPortNode = this.findPortNode(port, nodeSelector);\n        if (proxyPortNode) return proxyPortNode;\n      } else {\n        const [proxyNode] = this.findBySelector(nodeSelector);\n        if (proxyNode) return proxyNode;\n      }\n    }\n\n    return el;\n  },\n\n  // Interaction. The controller part.\n  // ---------------------------------\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('element:pointerdown', evt, x, y);\n  },\n\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('element:pointermove', evt, x, y);\n  },\n\n  notifyPointerup(evt, x, y) {\n    this.notify('element:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('element:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('element:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('element:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    if (this.isPropagationStopped(evt)) return;\n    this.notifyPointerdown(evt, x, y);\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'magnet':\n        this.dragMagnet(evt, x, y);\n        break;\n\n      case 'move':\n        (data.delegatedView || this).drag(evt, x, y);\n      // eslint: no-fallthrough=false\n\n      default:\n        this.notifyPointermove(evt, x, y);\n        break;\n    } // Make sure the element view data is passed along.\n    // It could have been wiped out in the handlers above.\n\n\n    this.eventData(evt, data);\n  },\n  pointerup: function (evt, x, y) {\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'magnet':\n        this.dragMagnetEnd(evt, x, y);\n        break;\n\n      case 'move':\n        (data.delegatedView || this).dragEnd(evt, x, y);\n      // eslint: no-fallthrough=false\n\n      default:\n        this.notifyPointerup(evt, x, y);\n    }\n\n    var magnet = data.targetMagnet;\n    if (magnet) this.magnetpointerclick(evt, magnet, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('element:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('element:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('element:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('element:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('element:mousewheel', evt, x, y, delta);\n  },\n  onmagnet: function (evt, x, y) {\n    this.dragMagnetStart(evt, x, y);\n  },\n  magnetpointerdblclick: function (evt, magnet, x, y) {\n    this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n  },\n  magnetcontextmenu: function (evt, magnet, x, y) {\n    this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n  },\n  // Drag Start Handlers\n  dragStart: function (evt, x, y) {\n    var view = this.getDelegatedView();\n    if (!view || !view.can('elementMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      delegatedView: view\n    });\n    view.eventData(evt, {\n      pointerOffset: view.model.position().difference(x, y),\n      restrictedArea: this.paper.getRestrictedArea(view, x, y)\n    });\n  },\n  dragMagnetStart: function (evt, x, y) {\n    if (!this.can('addLinkFromMagnet')) return;\n    var magnet = evt.currentTarget;\n    var paper = this.paper;\n    this.eventData(evt, {\n      targetMagnet: magnet\n    });\n    evt.stopPropagation();\n\n    if (paper.options.validateMagnet(this, magnet, evt)) {\n      if (paper.options.magnetThreshold <= 0) {\n        this.dragLinkStart(evt, magnet, x, y);\n      }\n\n      this.eventData(evt, {\n        action: 'magnet'\n      });\n      this.stopPropagation(evt);\n    } else {\n      this.pointerdown(evt, x, y);\n    }\n\n    paper.delegateDragEvents(this, evt.data);\n  },\n  dragLinkStart: function (evt, magnet, x, y) {\n    this.model.startBatch('add-link');\n    var linkView = this.addLinkFromMagnet(magnet, x, y); // backwards compatibility events\n\n    linkView.notifyPointerdown(evt, x, y);\n    linkView.eventData(evt, linkView.startArrowheadMove('target', {\n      whenNotAllowed: 'remove'\n    }));\n    this.eventData(evt, {\n      linkView: linkView\n    });\n  },\n  addLinkFromMagnet: function (magnet, x, y) {\n    var paper = this.paper;\n    var graph = paper.model;\n    var link = paper.getDefaultLink(this, magnet);\n    link.set({\n      source: this.getLinkEnd(magnet, x, y, link, 'source'),\n      target: {\n        x: x,\n        y: y\n      }\n    }).addTo(graph, {\n      async: false,\n      ui: true\n    });\n    return link.findView(paper);\n  },\n  // Drag Handlers\n  drag: function (evt, x, y) {\n    var paper = this.paper;\n    var grid = paper.options.gridSize;\n    var element = this.model;\n    var data = this.eventData(evt);\n    var {\n      pointerOffset,\n      restrictedArea,\n      embedding\n    } = data; // Make sure the new element's position always snaps to the current grid\n\n    var elX = snapToGrid(x + pointerOffset.x, grid);\n    var elY = snapToGrid(y + pointerOffset.y, grid);\n    element.position(elX, elY, {\n      restrictedArea,\n      deep: true,\n      ui: true\n    });\n\n    if (paper.options.embeddingMode) {\n      if (!embedding) {\n        // Prepare the element for embedding only if the pointer moves.\n        // We don't want to do unnecessary action with the element\n        // if an user only clicks/dblclicks on it.\n        this.prepareEmbedding(data);\n        embedding = true;\n      }\n\n      this.processEmbedding(data);\n    }\n\n    this.eventData(evt, {\n      embedding\n    });\n  },\n  dragMagnet: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n\n    if (linkView) {\n      linkView.pointermove(evt, x, y);\n    } else {\n      var paper = this.paper;\n      var magnetThreshold = paper.options.magnetThreshold;\n      var currentTarget = this.getEventTarget(evt);\n      var targetMagnet = data.targetMagnet;\n\n      if (magnetThreshold === 'onleave') {\n        // magnetThreshold when the pointer leaves the magnet\n        if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n      } else {\n        // magnetThreshold defined as a number of movements\n        if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n      }\n\n      this.dragLinkStart(evt, targetMagnet, x, y);\n    }\n  },\n  // Drag End Handlers\n  dragEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    if (data.embedding) this.finalizeEmbedding(data);\n  },\n  dragMagnetEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var linkView = data.linkView;\n    if (!linkView) return;\n    linkView.pointerup(evt, x, y);\n    this.model.stopBatch('add-link');\n  },\n  magnetpointerclick: function (evt, magnet, x, y) {\n    var paper = this.paper;\n    if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n    this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n  }\n});\nassign(ElementView.prototype, elementViewPortPrototype);","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/dia/ElementView.mjs"],"names":["config","assign","invoke","isFunction","toArray","CellView","Cell","V","elementViewPortPrototype","Rect","snapToGrid","ElementView","extend","_removePorts","_renderPorts","className","classNames","prototype","apply","split","push","join","initialize","arguments","_initializePorts","presentationAttributes","initFlag","UPDATE_PRIORITY","confirmUpdate","flag","opt","useCSSSelectors","hasFlag","_cleanPortsCache","transformHighlighters","render","updateTools","updateHighlighters","removeFlag","resize","update","model","translate","rotate","_","renderingOnlyAttrs","cleanNodesCache","modelAttrs","attr","updateDOMSubtreeAttributes","el","rootBBox","size","selectors","scalableNode","rotatableNode","roAttributes","rotatableSelector","scalableSelector","renderMarkup","element","markup","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","vel","append","fragment","findOne","selector","empty","updateTransformation","sgResize","attributes","angle","rgTranslate","rgRotate","transformation","getTranslateString","rotateString","getRotateString","position","x","y","width","height","scalable","recursive","node","getElementsByTagName","length","scalableBBox","getBBox","sx","sy","rotatable","rotation","rotatableBBox","target","paper","cells","set","updateHandled","prepareEmbedding","data","graph","startBatch","toFront","deep","ui","maxZ","getElements","reduce","max","cell","Math","z","connectedLinks","getConnectedLinks","includeEnclosed","forEach","link","stopBatch","parentId","parent","getCell","unembed","processEmbedding","paperOptions","options","candidates","findParentBy","parents","call","filter","id","isEmbeddedIn","bind","findModelsUnderElement","searchBy","frontParentOnly","slice","newCandidateView","prevCandidateView","candidateEmbedView","i","candidate","view","findView","validateEmbedding","clearEmbedding","highlight","findProxyNode","embedding","candidateView","unhighlight","finalizeEmbedding","embed","getDelegatedView","isLink","isEmbedded","can","getParentCell","findViewByModel","type","nodeSelector","getAttribute","port","findAttribute","proxyPortNode","findPortNode","proxyNode","findBySelector","notifyPointerdown","evt","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","isPropagationStopped","dragStart","eventData","action","dragMagnet","delegatedView","drag","dragMagnetEnd","dragEnd","magnet","targetMagnet","magnetpointerclick","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onmagnet","dragMagnetStart","magnetpointerdblclick","magnetcontextmenu","pointerOffset","difference","restrictedArea","getRestrictedArea","currentTarget","stopPropagation","validateMagnet","magnetThreshold","dragLinkStart","delegateDragEvents","linkView","addLinkFromMagnet","startArrowheadMove","whenNotAllowed","getDefaultLink","source","getLinkEnd","addTo","async","grid","gridSize","elX","elY","embeddingMode","getEventTarget","contains","mousemoved","clickThreshold"],"mappings":"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","sourcesContent":["import { config } from '../config/index.mjs';\nimport { assign, invoke, isFunction, toArray } from '../util/index.mjs';\nimport { CellView } from './CellView.mjs';\nimport { Cell } from './Cell.mjs';\nimport V from '../V/index.mjs';\nimport { elementViewPortPrototype } from './ports.mjs';\nimport { Rect, snapToGrid } from '../g/index.mjs';\n\n// Element base view and controller.\n// -------------------------------------------\n\nexport const ElementView = CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': ['UPDATE'],\n        'position': ['TRANSLATE', 'TOOLS'],\n        'size': ['RESIZE', 'PORTS', 'TOOLS'],\n        'angle': ['ROTATE', 'TOOLS'],\n        'markup': ['RENDER'],\n        'ports': ['PORTS']\n    },\n\n    initFlag: ['RENDER'],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = config;\n        if (this.hasFlag(flag, 'PORTS')) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, 'RENDER')) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, ['RENDER', 'UPDATE', 'RESIZE', 'TRANSLATE', 'ROTATE', 'PORTS', 'TOOLS']);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, 'RESIZE')) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, ['RESIZE', 'UPDATE']);\n            }\n            if (this.hasFlag(flag, 'UPDATE')) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, 'UPDATE');\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, 'PORTS');\n                }\n            }\n            if (this.hasFlag(flag, 'TRANSLATE')) {\n                this.translate();\n                flag = this.removeFlag(flag, 'TRANSLATE');\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, 'ROTATE')) {\n                this.rotate();\n                flag = this.removeFlag(flag, 'ROTATE');\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, 'PORTS')) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, 'PORTS');\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, 'TOOLS')) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, 'TOOLS');\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = config;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = V(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = V(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append(V(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!config.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        var position = this.model.attributes.position;\n        return 'translate(' + position.x + ',' + position.y + ')';\n    },\n\n    getRotateString: function() {\n        var attributes = this.model.attributes;\n        var angle = attributes.angle;\n        if (!angle) return null;\n        var size = attributes.size;\n        return 'rotate(' + angle + ',' + (size.width / 2) + ',' + (size.height / 2) + ')';\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, assign({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data) {\n\n        data || (data = {});\n\n        var model = data.model || this.model;\n        var paper = data.paper || this.paper;\n        var graph = paper.model;\n\n        model.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        model.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        var maxZ = graph.getElements().reduce(function(max, cell) {\n            return Math.max(max, cell.attributes.z || 0);\n        }, 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        var connectedLinks = graph.getConnectedLinks(model, { deep: true, includeEnclosed: true });\n        connectedLinks.forEach(function(link) {\n            if (link.attributes.z <= maxZ) link.set('z', maxZ + 1, { ui: true });\n        });\n\n        model.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        var parentId = model.parent();\n        if (parentId) {\n            graph.getCell(parentId).unembed(model, { ui: true });\n        }\n    },\n\n    processEmbedding: function(data) {\n\n        data || (data = {});\n\n        var model = data.model || this.model;\n        var paper = data.paper || this.paper;\n        var paperOptions = paper.options;\n\n        var candidates = [];\n        if (isFunction(paperOptions.findParentBy)) {\n            var parents = toArray(paperOptions.findParentBy.call(paper.model, this));\n            candidates = parents.filter(function(el) {\n                return el instanceof Cell && this.model.id !== el.id && !el.isEmbeddedIn(this.model);\n            }.bind(this));\n        } else {\n            candidates = paper.model.findModelsUnderElement(model, { searchBy: paperOptions.findParentBy });\n        }\n\n        if (paperOptions.frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        var newCandidateView = null;\n        var prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (var i = candidates.length - 1; i >= 0; i--) {\n\n            var candidate = candidates[i];\n\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n\n            } else {\n\n                var view = candidate.findView(paper);\n                if (paperOptions.validateEmbedding.call(paper, this, view)) {\n\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        var model = data.model || this.model;\n        var paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(model, { ui: true });\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n\n            data.candidateEmbedView = null;\n        }\n\n        invoke(paper.model.getConnectedLinks(model, { deep: true }), 'reparent', { ui: true });\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const [proxyNode] = this.findBySelector(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        if (this.isPropagationStopped(evt)) return;\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n\n        switch (data.action) {\n            case 'magnet':\n                this.dragMagnet(evt, x, y);\n                break;\n            case 'move':\n                (data.delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n            case 'magnet':\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case 'move':\n                (data.delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                this.notifyPointerup(evt, x, y);\n        }\n\n        var magnet = data.targetMagnet;\n        if (magnet) this.magnetpointerclick(evt, magnet, x, y);\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            delegatedView: view\n        });\n\n        view.eventData(evt, {\n            pointerOffset: view.model.position().difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        if (!this.can('addLinkFromMagnet')) return;\n\n        var magnet = evt.currentTarget;\n        var paper = this.paper;\n        this.eventData(evt, { targetMagnet: magnet });\n        evt.stopPropagation();\n\n        if (paper.options.validateMagnet(this, magnet, evt)) {\n\n            if (paper.options.magnetThreshold <= 0) {\n                this.dragLinkStart(evt, magnet, x, y);\n            }\n\n            this.eventData(evt, { action: 'magnet' });\n            this.stopPropagation(evt);\n\n        } else {\n\n            this.pointerdown(evt, x, y);\n        }\n\n        paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n\n        this.model.startBatch('add-link');\n\n        var linkView = this.addLinkFromMagnet(magnet, x, y);\n\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView: linkView });\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    // Drag Handlers\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var grid = paper.options.gridSize;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        var elX = snapToGrid(x + pointerOffset.x, grid);\n        var elY = snapToGrid(y + pointerOffset.y, grid);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || V(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n});\n\nassign(ElementView.prototype, elementViewPortPrototype);\n"]},"metadata":{},"sourceType":"module"}