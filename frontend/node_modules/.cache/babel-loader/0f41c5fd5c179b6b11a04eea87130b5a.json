{"ast":null,"code":"import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\n\nfunction bboxWrapper(method) {\n  return function (view, magnet, ref, opt) {\n    var rotate = !!opt.rotate;\n    var bbox = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n    var anchor = bbox[method]();\n    var dx = opt.dx;\n\n    if (dx) {\n      var dxPercentage = util.isPercentage(dx);\n      dx = parseFloat(dx);\n\n      if (isFinite(dx)) {\n        if (dxPercentage) {\n          dx /= 100;\n          dx *= bbox.width;\n        }\n\n        anchor.x += dx;\n      }\n    }\n\n    var dy = opt.dy;\n\n    if (dy) {\n      var dyPercentage = util.isPercentage(dy);\n      dy = parseFloat(dy);\n\n      if (isFinite(dy)) {\n        if (dyPercentage) {\n          dy /= 100;\n          dy *= bbox.height;\n        }\n\n        anchor.y += dy;\n      }\n    }\n\n    return rotate ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n  };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n  var angle = view.model.angle();\n  var bbox = view.getNodeBBox(magnet);\n  var anchor = bbox.center();\n  var topLeft = bbox.origin();\n  var bottomRight = bbox.corner();\n  var padding = opt.padding;\n  if (!isFinite(padding)) padding = 0;\n\n  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n    var dy = refPoint.y - anchor.y;\n    anchor.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));\n    anchor.y += dy;\n  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n    var dx = refPoint.x - anchor.x;\n    anchor.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));\n    anchor.x += dx;\n  }\n\n  return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n  var rotate = !!opt.rotate;\n  var bbox, angle, center;\n\n  if (rotate) {\n    bbox = view.getNodeUnrotatedBBox(magnet);\n    center = view.model.getBBox().center();\n    angle = view.model.angle();\n  } else {\n    bbox = view.getNodeBBox(magnet);\n  }\n\n  var padding = opt.padding;\n  if (isFinite(padding)) bbox.inflate(padding);\n  if (rotate) refPoint.rotate(center, angle);\n  var side = bbox.sideNearestToPoint(refPoint);\n  var anchor;\n\n  switch (side) {\n    case 'left':\n      anchor = bbox.leftMiddle();\n      break;\n\n    case 'right':\n      anchor = bbox.rightMiddle();\n      break;\n\n    case 'top':\n      anchor = bbox.topMiddle();\n      break;\n\n    case 'bottom':\n      anchor = bbox.bottomMiddle();\n      break;\n  }\n\n  return rotate ? anchor.rotate(center, -angle) : anchor;\n} // Can find anchor from model, when there is no selector or the link end\n// is connected to a port\n\n\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n  return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n} //joint.anchors\n\n\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/anchors/index.mjs"],"names":["util","toRad","resolveRef","bboxWrapper","method","view","magnet","ref","opt","rotate","bbox","getNodeUnrotatedBBox","getNodeBBox","anchor","dx","dxPercentage","isPercentage","parseFloat","isFinite","width","x","dy","dyPercentage","height","y","model","getBBox","center","angle","_perpendicular","refPoint","topLeft","origin","bottomRight","corner","padding","Math","tan","_midSide","inflate","side","sideNearestToPoint","leftMiddle","rightMiddle","topMiddle","bottomMiddle","_modelCenter","_magnet","_refPoint","endType","getPointFromConnectedLink","offset","top","bottom","left","right","topRight","bottomLeft","perpendicular","midSide","modelCenter"],"mappings":"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","sourcesContent":["import * as util from '../util/index.mjs';\nimport { toRad } from '../g/index.mjs';\nimport { resolveRef } from '../linkAnchors/index.mjs';\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = util.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = util.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan(toRad(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan(toRad(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nexport const center = bboxWrapper('center');\nexport const top = bboxWrapper('topMiddle');\nexport const bottom = bboxWrapper('bottomMiddle');\nexport const left = bboxWrapper('leftMiddle');\nexport const right = bboxWrapper('rightMiddle');\nexport const topLeft = bboxWrapper('origin');\nexport const topRight = bboxWrapper('topRight');\nexport const bottomLeft = bboxWrapper('bottomLeft');\nexport const bottomRight = bboxWrapper('corner');\nexport const perpendicular = resolveRef(_perpendicular);\nexport const midSide = resolveRef(_midSide);\nexport const modelCenter = _modelCenter;\n\n"]},"metadata":{},"sourceType":"module"}