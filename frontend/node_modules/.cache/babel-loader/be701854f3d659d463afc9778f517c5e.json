{"ast":null,"code":"// Vectorizer.\n// -----------\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\nimport * as g from '../g/index.mjs';\n\nconst V = function () {\n  var hasSvg = typeof window === 'object' && !!(window.SVGAngle || document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')); // SVG support is required.\n\n  if (!hasSvg) {\n    // Return a function that throws an error when it is used.\n    return function () {\n      throw new Error('SVG is required to use Vectorizer.');\n    };\n  } // XML namespaces.\n\n\n  var ns = {\n    svg: 'http://www.w3.org/2000/svg',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xml: 'http://www.w3.org/XML/1998/namespace',\n    xlink: 'http://www.w3.org/1999/xlink',\n    xhtml: 'http://www.w3.org/1999/xhtml'\n  };\n  var SVGVersion = '1.1'; // Declare shorthands to the most used math functions.\n\n  var math = Math;\n  var PI = math.PI;\n  var atan2 = math.atan2;\n  var sqrt = math.sqrt;\n  var min = math.min;\n  var max = math.max;\n  var cos = math.cos;\n  var sin = math.sin;\n\n  var V = function (el, attrs, children) {\n    // This allows using V() without the new keyword.\n    if (!(this instanceof V)) {\n      return V.apply(Object.create(V.prototype), arguments);\n    }\n\n    if (!el) return;\n\n    if (V.isV(el)) {\n      el = el.node;\n    }\n\n    attrs = attrs || {};\n\n    if (V.isString(el)) {\n      if (el.toLowerCase() === 'svg') {\n        // Create a new SVG canvas.\n        el = V.createSvgDocument();\n      } else if (el[0] === '<') {\n        // Create element from an SVG string.\n        // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n        var svgDoc = V.createSvgDocument(el); // Note that `V()` might also return an array should the SVG string passed as\n        // the first argument contain more than one root element.\n\n        if (svgDoc.childNodes.length > 1) {\n          // Map child nodes to `V`s.\n          var arrayOfVels = [];\n          var i, len;\n\n          for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n            var childNode = svgDoc.childNodes[i];\n            arrayOfVels.push(new V(document.importNode(childNode, true)));\n          }\n\n          return arrayOfVels;\n        }\n\n        el = document.importNode(svgDoc.firstChild, true);\n      } else {\n        el = document.createElementNS(ns.svg, el);\n      }\n\n      V.ensureId(el);\n    }\n\n    this.node = el;\n    this.setAttributes(attrs);\n\n    if (children) {\n      this.append(children);\n    }\n\n    return this;\n  };\n\n  var VPrototype = V.prototype;\n  Object.defineProperty(VPrototype, 'id', {\n    enumerable: true,\n    get: function () {\n      return this.node.id;\n    },\n    set: function (id) {\n      this.node.id = id;\n    }\n  });\n  /**\n   * @param {SVGGElement} toElem\n   * @returns {SVGMatrix}\n   */\n\n  VPrototype.getTransformToElement = function (target) {\n    var node = this.node;\n\n    if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n      var targetCTM = V.toNode(target).getScreenCTM();\n      var nodeCTM = node.getScreenCTM();\n\n      if (targetCTM && nodeCTM) {\n        return targetCTM.inverse().multiply(nodeCTM);\n      }\n    } // Could not get actual transformation matrix\n\n\n    return V.createSVGMatrix();\n  };\n  /**\n   * @param {SVGMatrix} matrix\n   * @param {Object=} opt\n   * @returns {Vectorizer|SVGMatrix} Setter / Getter\n   */\n\n\n  VPrototype.transform = function (matrix, opt) {\n    var node = this.node;\n\n    if (V.isUndefined(matrix)) {\n      return V.transformStringToMatrix(this.attr('transform'));\n    }\n\n    if (opt && opt.absolute) {\n      return this.attr('transform', V.matrixToTransformString(matrix));\n    }\n\n    var svgTransform = V.createSVGTransform(matrix);\n    node.transform.baseVal.appendItem(svgTransform);\n    return this;\n  };\n\n  VPrototype.translate = function (tx, ty, opt) {\n    opt = opt || {};\n    ty = ty || 0;\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value; // Is it a getter?\n\n    if (V.isUndefined(tx)) {\n      return transform.translate;\n    }\n\n    transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n    var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n    var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n    var newTranslate = 'translate(' + newTx + ',' + newTy + ')'; // Note that `translate()` is always the first transformation. This is\n    // usually the desired case.\n\n    this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n    return this;\n  };\n\n  VPrototype.rotate = function (angle, cx, cy, opt) {\n    opt = opt || {};\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value; // Is it a getter?\n\n    if (V.isUndefined(angle)) {\n      return transform.rotate;\n    }\n\n    transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n    angle %= 360;\n    var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n    var newOrigin = cx !== undefined && cy !== undefined ? ',' + cx + ',' + cy : '';\n    var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n    this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n    return this;\n  }; // Note that `scale` as the only transformation does not combine with previous values.\n\n\n  VPrototype.scale = function (sx, sy) {\n    sy = V.isUndefined(sy) ? sx : sy;\n    var transformAttr = this.attr('transform') || '';\n    var transform = V.parseTransformString(transformAttr);\n    transformAttr = transform.value; // Is it a getter?\n\n    if (V.isUndefined(sx)) {\n      return transform.scale;\n    }\n\n    transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n    var newScale = 'scale(' + sx + ',' + sy + ')';\n    this.attr('transform', (transformAttr + ' ' + newScale).trim());\n    return this;\n  }; // Get SVGRect that contains coordinates and dimension of the real bounding box,\n  // i.e. after transformations are applied.\n  // If `target` is specified, bounding box will be computed relatively to `target` element.\n\n\n  VPrototype.bbox = function (withoutTransformations, target) {\n    var box;\n    var node = this.node;\n    var ownerSVGElement = node.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box defined and\n    // so fall back to 'zero' dimension element.\n\n    if (!ownerSVGElement) {\n      return new g.Rect(0, 0, 0, 0);\n    }\n\n    try {\n      box = node.getBBox();\n    } catch (e) {\n      // Fallback for IE.\n      box = {\n        x: node.clientLeft,\n        y: node.clientTop,\n        width: node.clientWidth,\n        height: node.clientHeight\n      };\n    }\n\n    if (withoutTransformations) {\n      return new g.Rect(box);\n    }\n\n    var matrix = this.getTransformToElement(target || ownerSVGElement);\n    return V.transformRect(box, matrix);\n  }; // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n  // i.e. after transformations are applied.\n  // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n  // Takes an (Object) `opt` argument (optional) with the following attributes:\n  // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n  // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n\n\n  VPrototype.getBBox = function (opt) {\n    var options = {};\n    var outputBBox;\n    var node = this.node;\n    var ownerSVGElement = node.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box defined and\n    // so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n\n    if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n      return new g.Rect(0, 0, 0, 0);\n    }\n\n    if (opt) {\n      if (opt.target) {\n        // check if target exists\n        options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n      }\n\n      if (opt.recursive) {\n        options.recursive = opt.recursive;\n      }\n    }\n\n    if (!options.recursive) {\n      try {\n        outputBBox = node.getBBox();\n      } catch (e) {\n        // Fallback for IE.\n        outputBBox = {\n          x: node.clientLeft,\n          y: node.clientTop,\n          width: node.clientWidth,\n          height: node.clientHeight\n        };\n      }\n\n      if (!options.target) {\n        // transform like this (that is, not at all)\n        return new g.Rect(outputBBox);\n      } else {\n        // transform like target\n        var matrix = this.getTransformToElement(options.target);\n        return V.transformRect(outputBBox, matrix);\n      }\n    } else {\n      // if we want to calculate the bbox recursively\n      // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n      // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n      // this happens even if we wrap a single svg element into a group!\n      // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n      var children = this.children();\n      var n = children.length;\n\n      if (n === 0) {\n        return this.getBBox({\n          target: options.target,\n          recursive: false\n        });\n      } // recursion's initial pass-through setting:\n      // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n\n\n      if (!options.target) {\n        // transform children/descendants like this (their parent/ancestor)\n        options.target = this;\n      } // else transform children/descendants like target\n\n\n      for (var i = 0; i < n; i++) {\n        var currentChild = children[i];\n        var childBBox; // if currentChild is not a group element, get its bbox with a nonrecursive call\n\n        if (currentChild.children().length === 0) {\n          childBBox = currentChild.getBBox({\n            target: options.target,\n            recursive: false\n          });\n        } else {\n          // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n          childBBox = currentChild.getBBox({\n            target: options.target,\n            recursive: true\n          });\n        }\n\n        if (!outputBBox) {\n          // if this is the first iteration\n          outputBBox = childBBox;\n        } else {\n          // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n          outputBBox = outputBBox.union(childBBox);\n        }\n      }\n\n      return outputBBox;\n    }\n  }; // Text() helpers\n\n\n  function createTextPathNode(attrs, vel) {\n    attrs || (attrs = {});\n    var textPathElement = V('textPath');\n    var d = attrs.d;\n\n    if (d && attrs['xlink:href'] === undefined) {\n      // If `opt.attrs` is a plain string, consider it to be directly the\n      // SVG path data for the text to go along (this is a shortcut).\n      // Otherwise if it is an object and contains the `d` property, then this is our path.\n      // Wrap the text in the SVG <textPath> element that points\n      // to a path defined by `opt.attrs` inside the `<defs>` element.\n      var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n      textPathElement.attr('xlink:href', '#' + linkedPath.id);\n    }\n\n    if (V.isObject(attrs)) {\n      // Set attributes on the `<textPath>`. The most important one\n      // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n      // Note that we also allow the following construct:\n      // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n      // In other words, one can completely skip the auto-creation of the path\n      // and use any other arbitrary path that is in the document.\n      textPathElement.attr(attrs);\n    }\n\n    return textPathElement.node;\n  }\n\n  function annotateTextLine(lineNode, lineAnnotations, opt) {\n    opt || (opt = {});\n    var includeAnnotationIndices = opt.includeAnnotationIndices;\n    var eol = opt.eol;\n    var lineHeight = opt.lineHeight;\n    var baseSize = opt.baseSize;\n    var maxFontSize = 0;\n    var fontMetrics = {};\n    var lastJ = lineAnnotations.length - 1;\n\n    for (var j = 0; j <= lastJ; j++) {\n      var annotation = lineAnnotations[j];\n      var fontSize = null;\n\n      if (V.isObject(annotation)) {\n        var annotationAttrs = annotation.attrs;\n        var vTSpan = V('tspan', annotationAttrs);\n        var tspanNode = vTSpan.node;\n        var t = annotation.t;\n        if (eol && j === lastJ) t += eol;\n        tspanNode.textContent = t; // Per annotation className\n\n        var annotationClass = annotationAttrs['class'];\n        if (annotationClass) vTSpan.addClass(annotationClass); // If `opt.includeAnnotationIndices` is `true`,\n        // set the list of indices of all the applied annotations\n        // in the `annotations` attribute. This list is a comma\n        // separated list of indices.\n\n        if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations); // Check for max font size\n\n        fontSize = parseFloat(annotationAttrs['font-size']);\n        if (fontSize === undefined) fontSize = baseSize;\n        if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n      } else {\n        if (eol && j === lastJ) annotation += eol;\n        tspanNode = document.createTextNode(annotation || ' ');\n        if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n      }\n\n      lineNode.appendChild(tspanNode);\n    }\n\n    if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n\n    if (lineHeight) {\n      fontMetrics.lineHeight = lineHeight;\n    } else if (maxFontSize) {\n      fontMetrics.lineHeight = maxFontSize * 1.2;\n    }\n\n    return fontMetrics;\n  }\n\n  var emRegex = /em$/;\n\n  function convertEmToPx(em, fontSize) {\n    var numerical = parseFloat(em);\n    if (emRegex.test(em)) return numerical * fontSize;\n    return numerical;\n  }\n\n  function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n    if (!Array.isArray(linesMetrics)) return 0;\n    var n = linesMetrics.length;\n    if (!n) return 0;\n    var lineMetrics = linesMetrics[0];\n    var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    var rLineHeights = 0;\n    var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n\n    for (var i = 1; i < n; i++) {\n      lineMetrics = linesMetrics[i];\n      var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n      rLineHeights += iLineHeight;\n    }\n\n    var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    var dy;\n\n    switch (alignment) {\n      case 'middle':\n        dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n        break;\n\n      case 'bottom':\n        dy = -(0.25 * llMaxFont) - rLineHeights;\n        break;\n\n      default:\n      case 'top':\n        dy = 0.8 * flMaxFont;\n        break;\n    }\n\n    return dy;\n  }\n\n  VPrototype.text = function (content, opt) {\n    if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.'); // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one.\n\n    content = V.sanitizeText(content);\n    opt || (opt = {}); // Should we allow the text to be selected?\n\n    var displayEmpty = opt.displayEmpty; // End of Line character\n\n    var eol = opt.eol; // Text along path\n\n    var textPath = opt.textPath; // Vertical shift\n\n    var verticalAnchor = opt.textVerticalAnchor;\n    var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.\n\n    var x = opt.x;\n    if (x === undefined) x = this.attr('x') || 0; // Annotations\n\n    var iai = opt.includeAnnotationIndices;\n    var annotations = opt.annotations;\n    if (annotations && !V.isArray(annotations)) annotations = [annotations]; // Shift all the <tspan> but first by one line (`1em`)\n\n    var defaultLineHeight = opt.lineHeight;\n    var autoLineHeight = defaultLineHeight === 'auto';\n    var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em'; // Clearing the element\n\n    this.empty();\n    this.attr({\n      // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n      'xml:space': 'preserve',\n      // An empty text gets rendered into the DOM in webkit-based browsers.\n      // In order to unify this behaviour across all browsers\n      // we rather hide the text element when it's empty.\n      'display': content || displayEmpty ? null : 'none'\n    }); // Set default font-size if none\n\n    var fontSize = parseFloat(this.attr('font-size'));\n\n    if (!fontSize) {\n      fontSize = 16;\n      if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n    }\n\n    var doc = document;\n    var containerNode;\n\n    if (textPath) {\n      // Now all the `<tspan>`s will be inside the `<textPath>`.\n      if (typeof textPath === 'string') textPath = {\n        d: textPath\n      };\n      containerNode = createTextPathNode(textPath, this);\n    } else {\n      containerNode = doc.createDocumentFragment();\n    }\n\n    var offset = 0;\n    var lines = content.split('\\n');\n    var linesMetrics = [];\n    var annotatedY;\n\n    for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n      var dy = lineHeight;\n      var lineClassName = 'v-line';\n      var lineNode = doc.createElementNS(ns.svg, 'tspan');\n      var line = lines[i];\n      var lineMetrics;\n\n      if (line) {\n        if (annotations) {\n          // Find the *compacted* annotations for this line.\n          var lineAnnotations = V.annotateString(line, annotations, {\n            offset: -offset,\n            includeAnnotationIndices: iai\n          });\n          lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n            includeAnnotationIndices: iai,\n            eol: i !== lastI && eol,\n            lineHeight: autoLineHeight ? null : lineHeight,\n            baseSize: fontSize\n          }); // Get the line height based on the biggest font size in the annotations for this line.\n\n          var iLineHeight = lineMetrics.lineHeight;\n          if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n          if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n        } else {\n          if (eol && i !== lastI) line += eol;\n          lineNode.textContent = line;\n        }\n      } else {\n        // Make sure the textContent is never empty. If it is, add a dummy\n        // character and make it invisible, making the following lines correctly\n        // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n        lineNode.textContent = '-';\n        lineClassName += ' v-empty-line'; // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n        // is not applied in Firefox\n\n        var lineNodeStyle = lineNode.style;\n        lineNodeStyle.fillOpacity = 0;\n        lineNodeStyle.strokeOpacity = 0;\n        if (annotations) lineMetrics = {};\n      }\n\n      if (lineMetrics) linesMetrics.push(lineMetrics);\n      if (i > 0) lineNode.setAttribute('dy', dy); // Firefox requires 'x' to be set on the first line when inside a text path\n\n      if (i > 0 || textPath) lineNode.setAttribute('x', x);\n      lineNode.className.baseVal = lineClassName;\n      containerNode.appendChild(lineNode);\n      offset += line.length + 1; // + 1 = newline character.\n    } // Y Alignment calculation\n\n\n    if (namedVerticalAnchor) {\n      if (annotations) {\n        dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n      } else if (verticalAnchor === 'top') {\n        // A shortcut for top alignment. It does not depend on font-size nor line-height\n        dy = '0.8em';\n      } else {\n        var rh; // remaining height\n\n        if (lastI > 0) {\n          rh = parseFloat(lineHeight) || 1;\n          rh *= lastI;\n          if (!emRegex.test(lineHeight)) rh /= fontSize;\n        } else {\n          // Single-line text\n          rh = 0;\n        }\n\n        switch (verticalAnchor) {\n          case 'middle':\n            dy = 0.3 - rh / 2 + 'em';\n            break;\n\n          case 'bottom':\n            dy = -rh - 0.3 + 'em';\n            break;\n        }\n      }\n    } else {\n      if (verticalAnchor === 0) {\n        dy = '0em';\n      } else if (verticalAnchor) {\n        dy = verticalAnchor;\n      } else {\n        // No vertical anchor is defined\n        dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\n        if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n      }\n    }\n\n    containerNode.firstChild.setAttribute('dy', dy); // Appending lines to the element.\n\n    this.append(containerNode);\n    return this;\n  };\n  /**\n   * @public\n   * @param {string} name\n   * @returns {Vectorizer}\n   */\n\n\n  VPrototype.removeAttr = function (name) {\n    var qualifiedName = V.qualifyAttr(name);\n    var el = this.node;\n\n    if (qualifiedName.ns) {\n      if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) {\n        el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\n      }\n    } else if (el.hasAttribute(name)) {\n      el.removeAttribute(name);\n    }\n\n    return this;\n  };\n\n  VPrototype.attr = function (name, value) {\n    if (V.isUndefined(name)) {\n      // Return all attributes.\n      var attributes = this.node.attributes;\n      var attrs = {};\n\n      for (var i = 0; i < attributes.length; i++) {\n        attrs[attributes[i].name] = attributes[i].value;\n      }\n\n      return attrs;\n    }\n\n    if (V.isString(name) && V.isUndefined(value)) {\n      return this.node.getAttribute(name);\n    }\n\n    if (typeof name === 'object') {\n      for (var attrName in name) {\n        if (name.hasOwnProperty(attrName)) {\n          this.setAttribute(attrName, name[attrName]);\n        }\n      }\n    } else {\n      this.setAttribute(name, value);\n    }\n\n    return this;\n  };\n\n  VPrototype.normalizePath = function () {\n    var tagName = this.tagName();\n\n    if (tagName === 'PATH') {\n      this.attr('d', V.normalizePathData(this.attr('d')));\n    }\n\n    return this;\n  };\n\n  VPrototype.remove = function () {\n    if (this.node.parentNode) {\n      this.node.parentNode.removeChild(this.node);\n    }\n\n    return this;\n  };\n\n  VPrototype.empty = function () {\n    while (this.node.firstChild) {\n      this.node.removeChild(this.node.firstChild);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * @param {object} attrs\n   * @returns {Vectorizer}\n   */\n\n\n  VPrototype.setAttributes = function (attrs) {\n    for (var key in attrs) {\n      if (attrs.hasOwnProperty(key)) {\n        this.setAttribute(key, attrs[key]);\n      }\n    }\n\n    return this;\n  };\n\n  VPrototype.append = function (els) {\n    if (!V.isArray(els)) {\n      els = [els];\n    }\n\n    for (var i = 0, len = els.length; i < len; i++) {\n      this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n    }\n\n    return this;\n  };\n\n  VPrototype.prepend = function (els) {\n    var child = this.node.firstChild;\n    return child ? V(child).before(els) : this.append(els);\n  };\n\n  VPrototype.before = function (els) {\n    var node = this.node;\n    var parent = node.parentNode;\n\n    if (parent) {\n      if (!V.isArray(els)) {\n        els = [els];\n      }\n\n      for (var i = 0, len = els.length; i < len; i++) {\n        parent.insertBefore(V.toNode(els[i]), node);\n      }\n    }\n\n    return this;\n  };\n\n  VPrototype.appendTo = function (node) {\n    V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n\n    return this;\n  };\n\n  VPrototype.svg = function () {\n    return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n  };\n\n  VPrototype.tagName = function () {\n    return this.node.tagName.toUpperCase();\n  };\n\n  VPrototype.defs = function () {\n    var context = this.svg() || this;\n    var defsNode = context.node.getElementsByTagName('defs')[0];\n    if (defsNode) return V(defsNode);\n    return V('defs').appendTo(context);\n  };\n\n  VPrototype.clone = function () {\n    var clone = V(this.node.cloneNode(true\n    /* deep */\n    )); // Note that clone inherits also ID. Therefore, we need to change it here.\n\n    clone.node.id = V.uniqueId();\n    return clone;\n  };\n\n  VPrototype.findOne = function (selector) {\n    var found = this.node.querySelector(selector);\n    return found ? V(found) : undefined;\n  };\n\n  VPrototype.find = function (selector) {\n    var vels = [];\n    var nodes = this.node.querySelectorAll(selector);\n\n    if (nodes) {\n      // Map DOM elements to `V`s.\n      for (var i = 0; i < nodes.length; i++) {\n        vels.push(V(nodes[i]));\n      }\n    }\n\n    return vels;\n  }; // Returns an array of V elements made from children of this.node.\n\n\n  VPrototype.children = function () {\n    var children = this.node.childNodes;\n    var outputArray = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var currentChild = children[i];\n\n      if (currentChild.nodeType === 1) {\n        outputArray.push(V(children[i]));\n      }\n    }\n\n    return outputArray;\n  }; // Returns the V element from parentNode of this.node.\n\n\n  VPrototype.parent = function () {\n    return V(this.node.parentNode) || null;\n  }, // Find an index of an element inside its container.\n  VPrototype.index = function () {\n    var index = 0;\n    var node = this.node.previousSibling;\n\n    while (node) {\n      // nodeType 1 for ELEMENT_NODE\n      if (node.nodeType === 1) index++;\n      node = node.previousSibling;\n    }\n\n    return index;\n  };\n\n  VPrototype.findParentByClass = function (className, terminator) {\n    var ownerSVGElement = this.node.ownerSVGElement;\n    var node = this.node.parentNode;\n\n    while (node && node !== terminator && node !== ownerSVGElement) {\n      var vel = V(node);\n\n      if (vel.hasClass(className)) {\n        return vel;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  }; // https://jsperf.com/get-common-parent\n\n\n  VPrototype.contains = function (el) {\n    var a = this.node;\n    var b = V.toNode(el);\n    var bup = b && b.parentNode;\n    return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);\n  }; // Convert global point into the coordinate space of this element.\n\n\n  VPrototype.toLocalPoint = function (x, y) {\n    var svg = this.svg().node;\n    var p = svg.createSVGPoint();\n    p.x = x;\n    p.y = y;\n\n    try {\n      var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n      var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n    } catch (e) {\n      // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n      // We have to make do with the original coordianates.\n      return p;\n    }\n\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  };\n\n  VPrototype.translateCenterToPoint = function (p) {\n    var bbox = this.getBBox({\n      target: this.svg()\n    });\n    var center = bbox.center();\n    this.translate(p.x - center.x, p.y - center.y);\n    return this;\n  }; // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n  // of markers. The easiest way of understanding on what this does is to imagine the element is an\n  // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n  // being auto-oriented (properly rotated) towards the `reference` point.\n  // `target` is the element relative to which the transformations are applied. Usually a viewport.\n\n\n  VPrototype.translateAndAutoOrient = function (position, reference, target) {\n    position = new g.Point(position);\n    reference = new g.Point(reference);\n    target || (target = this.svg()); // Clean-up previously set transformations except the scale. If we didn't clean up the\n    // previous transformations then they'd add up with the old ones. Scale is an exception as\n    // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n    // element is scaled by the factor 2, not 8.\n\n    var scale = this.scale();\n    this.attr('transform', '');\n    var bbox = this.getBBox({\n      target: target\n    }).scale(scale.sx, scale.sy); // 1. Translate to origin.\n\n    var translateToOrigin = V.createSVGTransform();\n    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.\n\n    var rotateAroundOrigin = V.createSVGTransform();\n    var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n    if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n\n    var translateFromOrigin = V.createSVGTransform();\n    var finalPosition = position.clone().move(reference, bbox.width / 2);\n    translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y); // 4. Get the current transformation matrix of this node\n\n    var ctm = this.getTransformToElement(target); // 5. Apply transformations and the scale\n\n    var transform = V.createSVGTransform();\n    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale.sx, scale.sy)))));\n    this.attr('transform', V.matrixToTransformString(transform.matrix));\n    return this;\n  };\n\n  VPrototype.animateAlongPath = function (attrs, path) {\n    path = V.toNode(path);\n    var id = V.ensureId(path);\n    var animateMotion = V('animateMotion', attrs);\n    var mpath = V('mpath', {\n      'xlink:href': '#' + id\n    });\n    animateMotion.append(mpath);\n    this.append(animateMotion);\n\n    try {\n      animateMotion.node.beginElement();\n    } catch (e) {\n      // Fallback for IE 9.\n      // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n      if (document.documentElement.getAttribute('smiling') === 'fake') {\n        /* global getTargets:true, Animator:true, animators:true id2anim:true */\n        // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n        var animation = animateMotion.node;\n        animation.animators = [];\n        var animationID = animation.getAttribute('id');\n        if (animationID) id2anim[animationID] = animation;\n        var targets = getTargets(animation);\n\n        for (var i = 0, len = targets.length; i < len; i++) {\n          var target = targets[i];\n          var animator = new Animator(animation, target, i);\n          animators.push(animator);\n          animation.animators[i] = animator;\n          animator.register();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  VPrototype.hasClass = function (className) {\n    return new RegExp('(\\\\s|^)' + className + '(\\\\s|$)').test(this.node.getAttribute('class'));\n  };\n\n  VPrototype.addClass = function (className) {\n    if (className && !this.hasClass(className)) {\n      var prevClasses = this.node.getAttribute('class') || '';\n      this.node.setAttribute('class', (prevClasses + ' ' + className).trim());\n    }\n\n    return this;\n  };\n\n  VPrototype.removeClass = function (className) {\n    if (className && this.hasClass(className)) {\n      var newClasses = this.node.getAttribute('class').replace(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)', 'g'), '$2');\n      this.node.setAttribute('class', newClasses);\n    }\n\n    return this;\n  };\n\n  VPrototype.toggleClass = function (className, toAdd) {\n    var toRemove = V.isUndefined(toAdd) ? this.hasClass(className) : !toAdd;\n\n    if (toRemove) {\n      this.removeClass(className);\n    } else {\n      this.addClass(className);\n    }\n\n    return this;\n  }; // Interpolate path by discrete points. The precision of the sampling\n  // is controlled by `interval`. In other words, `sample()` will generate\n  // a point on the path starting at the beginning of the path going to the end\n  // every `interval` pixels.\n  // The sampler can be very useful for e.g. finding intersection between two\n  // paths (finding the two closest points from two samples).\n\n\n  VPrototype.sample = function (interval) {\n    interval = interval || 1;\n    var node = this.node;\n    var length = node.getTotalLength();\n    var samples = [];\n    var distance = 0;\n    var sample;\n\n    while (distance < length) {\n      sample = node.getPointAtLength(distance);\n      samples.push({\n        x: sample.x,\n        y: sample.y,\n        distance: distance\n      });\n      distance += interval;\n    }\n\n    return samples;\n  };\n\n  VPrototype.convertToPath = function () {\n    var path = V('path');\n    path.attr(this.attr());\n    var d = this.convertToPathData();\n\n    if (d) {\n      path.attr('d', d);\n    }\n\n    return path;\n  };\n\n  VPrototype.convertToPathData = function () {\n    var tagName = this.tagName();\n\n    switch (tagName) {\n      case 'PATH':\n        return this.attr('d');\n\n      case 'LINE':\n        return V.convertLineToPathData(this.node);\n\n      case 'POLYGON':\n        return V.convertPolygonToPathData(this.node);\n\n      case 'POLYLINE':\n        return V.convertPolylineToPathData(this.node);\n\n      case 'ELLIPSE':\n        return V.convertEllipseToPathData(this.node);\n\n      case 'CIRCLE':\n        return V.convertCircleToPathData(this.node);\n\n      case 'RECT':\n        return V.convertRectToPathData(this.node);\n    }\n\n    throw new Error(tagName + ' cannot be converted to PATH.');\n  };\n\n  V.prototype.toGeometryShape = function () {\n    var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n\n    switch (this.tagName()) {\n      case 'RECT':\n        x = parseFloat(this.attr('x')) || 0;\n        y = parseFloat(this.attr('y')) || 0;\n        width = parseFloat(this.attr('width')) || 0;\n        height = parseFloat(this.attr('height')) || 0;\n        return new g.Rect(x, y, width, height);\n\n      case 'CIRCLE':\n        cx = parseFloat(this.attr('cx')) || 0;\n        cy = parseFloat(this.attr('cy')) || 0;\n        r = parseFloat(this.attr('r')) || 0;\n        return new g.Ellipse({\n          x: cx,\n          y: cy\n        }, r, r);\n\n      case 'ELLIPSE':\n        cx = parseFloat(this.attr('cx')) || 0;\n        cy = parseFloat(this.attr('cy')) || 0;\n        rx = parseFloat(this.attr('rx')) || 0;\n        ry = parseFloat(this.attr('ry')) || 0;\n        return new g.Ellipse({\n          x: cx,\n          y: cy\n        }, rx, ry);\n\n      case 'POLYLINE':\n        points = V.getPointsFromSvgNode(this);\n        return new g.Polyline(points);\n\n      case 'POLYGON':\n        points = V.getPointsFromSvgNode(this);\n        if (points.length > 1) points.push(points[0]);\n        return new g.Polyline(points);\n\n      case 'PATH':\n        d = this.attr('d');\n        if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n        return new g.Path(d);\n\n      case 'LINE':\n        x1 = parseFloat(this.attr('x1')) || 0;\n        y1 = parseFloat(this.attr('y1')) || 0;\n        x2 = parseFloat(this.attr('x2')) || 0;\n        y2 = parseFloat(this.attr('y2')) || 0;\n        return new g.Line({\n          x: x1,\n          y: y1\n        }, {\n          x: x2,\n          y: y2\n        });\n    } // Anything else is a rectangle\n\n\n    return this.getBBox();\n  }; // Find the intersection of a line starting in the center\n  // of the SVG `node` ending in the point `ref`.\n  // `target` is an SVG element to which `node`s transformations are relative to.\n  // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n  // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n  // an intersection is found. Returns `undefined` otherwise.\n\n\n  VPrototype.findIntersection = function (ref, target) {\n    var svg = this.svg().node;\n    target = target || svg;\n    var bbox = this.getBBox({\n      target: target\n    });\n    var center = bbox.center();\n    if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n    var spot;\n    var tagName = this.tagName(); // Little speed up optimization for `<rect>` element. We do not do conversion\n    // to path element and sampling but directly calculate the intersection through\n    // a transformed geometrical rectangle.\n\n    if (tagName === 'RECT') {\n      var gRect = new g.Rect(parseFloat(this.attr('x') || 0), parseFloat(this.attr('y') || 0), parseFloat(this.attr('width')), parseFloat(this.attr('height'))); // Get the rect transformation matrix with regards to the SVG document.\n\n      var rectMatrix = this.getTransformToElement(target); // Decompose the matrix to find the rotation angle.\n\n      var rectMatrixComponents = V.decomposeMatrix(rectMatrix); // Now we want to rotate the rectangle back so that we\n      // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n\n      var resetRotation = svg.createSVGTransform();\n      resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n      var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n      spot = new g.Rect(rect).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n    } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n      var pathNode = tagName === 'PATH' ? this : this.convertToPath();\n      var samples = pathNode.sample();\n      var minDistance = Infinity;\n      var closestSamples = [];\n      var i, sample, gp, centerDistance, refDistance, distance;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i]; // Convert the sample point in the local coordinate system to the global coordinate system.\n\n        gp = V.createSVGPoint(sample.x, sample.y);\n        gp = gp.matrixTransform(this.getTransformToElement(target));\n        sample = new g.Point(gp);\n        centerDistance = sample.distance(center); // Penalize a higher distance to the reference point by 10%.\n        // This gives better results. This is due to\n        // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\n        refDistance = sample.distance(ref) * 1.1;\n        distance = centerDistance + refDistance;\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestSamples = [{\n            sample: sample,\n            refDistance: refDistance\n          }];\n        } else if (distance < minDistance + 1) {\n          closestSamples.push({\n            sample: sample,\n            refDistance: refDistance\n          });\n        }\n      }\n\n      closestSamples.sort(function (a, b) {\n        return a.refDistance - b.refDistance;\n      });\n\n      if (closestSamples[0]) {\n        spot = closestSamples[0].sample;\n      }\n    }\n\n    return spot;\n  };\n  /**\n   * @private\n   * @param {string} name\n   * @param {string} value\n   * @returns {Vectorizer}\n   */\n\n\n  VPrototype.setAttribute = function (name, value) {\n    var el = this.node;\n\n    if (value === null) {\n      this.removeAttr(name);\n      return this;\n    }\n\n    var qualifiedName = V.qualifyAttr(name);\n\n    if (qualifiedName.ns) {\n      // Attribute names can be namespaced. E.g. `image` elements\n      // have a `xlink:href` attribute to set the source of the image.\n      el.setAttributeNS(qualifiedName.ns, name, value);\n    } else if (name === 'id') {\n      el.id = value;\n    } else {\n      el.setAttribute(name, value);\n    }\n\n    return this;\n  }; // Create an SVG document element.\n  // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n\n\n  V.createSvgDocument = function (content) {\n    if (content) {\n      const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n      const {\n        documentElement\n      } = V.parseXML(XMLString, {\n        async: false\n      });\n      return documentElement;\n    }\n\n    const svg = document.createElementNS(ns.svg, 'svg');\n    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n    svg.setAttribute('version', SVGVersion);\n    return svg;\n  };\n\n  V.createSVGStyle = function (stylesheet) {\n    const {\n      node\n    } = V('style', {\n      type: 'text/css'\n    }, [V.createCDATASection(stylesheet)]);\n    return node;\n  }, V.createCDATASection = function (data = '') {\n    const xml = document.implementation.createDocument(null, 'xml', null);\n    return xml.createCDATASection(data);\n  };\n  V.idCounter = 0; // A function returning a unique identifier for this client session with every call.\n\n  V.uniqueId = function () {\n    return 'v-' + ++V.idCounter;\n  };\n\n  V.toNode = function (el) {\n    return V.isV(el) ? el.node : el.nodeName && el || el[0];\n  };\n\n  V.ensureId = function (node) {\n    node = V.toNode(node);\n    return node.id || (node.id = V.uniqueId());\n  }; // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n  // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n  // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n  // when you want to compare the actual DOM text content without having to add the unicode character in\n  // the place of all spaces.\n\n\n  V.sanitizeText = function (text) {\n    return (text || '').replace(/ /g, '\\u00A0');\n  };\n\n  V.isUndefined = function (value) {\n    return typeof value === 'undefined';\n  };\n\n  V.isString = function (value) {\n    return typeof value === 'string';\n  };\n\n  V.isObject = function (value) {\n    return value && typeof value === 'object';\n  };\n\n  V.isArray = Array.isArray;\n\n  V.parseXML = function (data, opt) {\n    opt = opt || {};\n    var xml;\n\n    try {\n      var parser = new DOMParser();\n\n      if (!V.isUndefined(opt.async)) {\n        parser.async = opt.async;\n      }\n\n      xml = parser.parseFromString(data, 'text/xml');\n    } catch (error) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\n      throw new Error('Invalid XML: ' + data);\n    }\n\n    return xml;\n  };\n  /**\n   * @param {string} name\n   * @returns {{ns: string|null, local: string}} namespace and attribute name\n   */\n\n\n  V.qualifyAttr = function (name) {\n    if (name.indexOf(':') !== -1) {\n      var combinedKey = name.split(':');\n      return {\n        ns: ns[combinedKey[0]],\n        local: combinedKey[1]\n      };\n    }\n\n    return {\n      ns: null,\n      local: name\n    };\n  };\n\n  V.transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\n  V.transformSeparatorRegex = /[ ,]+/;\n  V.transformationListRegex = /^(\\w+)\\((.*)\\)/;\n\n  V.transformStringToMatrix = function (transform) {\n    var transformationMatrix = V.createSVGMatrix();\n    var matches = transform && transform.match(V.transformRegex);\n\n    if (!matches) {\n      return transformationMatrix;\n    }\n\n    for (var i = 0, n = matches.length; i < n; i++) {\n      var transformationString = matches[i];\n      var transformationMatch = transformationString.match(V.transformationListRegex);\n\n      if (transformationMatch) {\n        var sx, sy, tx, ty, angle;\n        var ctm = V.createSVGMatrix();\n        var args = transformationMatch[2].split(V.transformSeparatorRegex);\n\n        switch (transformationMatch[1].toLowerCase()) {\n          case 'scale':\n            sx = parseFloat(args[0]);\n            sy = args[1] === undefined ? sx : parseFloat(args[1]);\n            ctm = ctm.scaleNonUniform(sx, sy);\n            break;\n\n          case 'translate':\n            tx = parseFloat(args[0]);\n            ty = parseFloat(args[1]);\n            ctm = ctm.translate(tx, ty);\n            break;\n\n          case 'rotate':\n            angle = parseFloat(args[0]);\n            tx = parseFloat(args[1]) || 0;\n            ty = parseFloat(args[2]) || 0;\n\n            if (tx !== 0 || ty !== 0) {\n              ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n            } else {\n              ctm = ctm.rotate(angle);\n            }\n\n            break;\n\n          case 'skewx':\n            angle = parseFloat(args[0]);\n            ctm = ctm.skewX(angle);\n            break;\n\n          case 'skewy':\n            angle = parseFloat(args[0]);\n            ctm = ctm.skewY(angle);\n            break;\n\n          case 'matrix':\n            ctm.a = parseFloat(args[0]);\n            ctm.b = parseFloat(args[1]);\n            ctm.c = parseFloat(args[2]);\n            ctm.d = parseFloat(args[3]);\n            ctm.e = parseFloat(args[4]);\n            ctm.f = parseFloat(args[5]);\n            break;\n\n          default:\n            continue;\n        }\n\n        transformationMatrix = transformationMatrix.multiply(ctm);\n      }\n    }\n\n    return transformationMatrix;\n  };\n\n  V.matrixToTransformString = function (matrix) {\n    matrix || (matrix = true);\n    return 'matrix(' + (matrix.a !== undefined ? matrix.a : 1) + ',' + (matrix.b !== undefined ? matrix.b : 0) + ',' + (matrix.c !== undefined ? matrix.c : 0) + ',' + (matrix.d !== undefined ? matrix.d : 1) + ',' + (matrix.e !== undefined ? matrix.e : 0) + ',' + (matrix.f !== undefined ? matrix.f : 0) + ')';\n  };\n\n  V.parseTransformString = function (transform) {\n    var translate, rotate, scale;\n\n    if (transform) {\n      var separator = V.transformSeparatorRegex; // Allow reading transform string with a single matrix\n\n      if (transform.trim().indexOf('matrix') >= 0) {\n        var matrix = V.transformStringToMatrix(transform);\n        var decomposedMatrix = V.decomposeMatrix(matrix);\n        translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n        scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n        rotate = [decomposedMatrix.rotation];\n        var transformations = [];\n\n        if (translate[0] !== 0 || translate[1] !== 0) {\n          transformations.push('translate(' + translate + ')');\n        }\n\n        if (scale[0] !== 1 || scale[1] !== 1) {\n          transformations.push('scale(' + scale + ')');\n        }\n\n        if (rotate[0] !== 0) {\n          transformations.push('rotate(' + rotate + ')');\n        }\n\n        transform = transformations.join(' ');\n      } else {\n        var translateMatch = transform.match(/translate\\((.*?)\\)/);\n\n        if (translateMatch) {\n          translate = translateMatch[1].split(separator);\n        }\n\n        var rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n\n        if (rotateMatch) {\n          rotate = rotateMatch[1].split(separator);\n        }\n\n        var scaleMatch = transform.match(/scale\\((.*?)\\)/);\n\n        if (scaleMatch) {\n          scale = scaleMatch[1].split(separator);\n        }\n      }\n    }\n\n    var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n    return {\n      value: transform,\n      translate: {\n        tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,\n        ty: translate && translate[1] ? parseInt(translate[1], 10) : 0\n      },\n      rotate: {\n        angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,\n        cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : undefined,\n        cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : undefined\n      },\n      scale: {\n        sx: sx,\n        sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n      }\n    };\n  };\n\n  V.deltaTransformPoint = function (matrix, point) {\n    var dx = point.x * matrix.a + point.y * matrix.c + 0;\n    var dy = point.x * matrix.b + point.y * matrix.d + 0;\n    return {\n      x: dx,\n      y: dy\n    };\n  };\n\n  V.decomposeMatrix = function (matrix) {\n    // @see https://gist.github.com/2052247\n    // calculate delta transform point\n    var px = V.deltaTransformPoint(matrix, {\n      x: 0,\n      y: 1\n    });\n    var py = V.deltaTransformPoint(matrix, {\n      x: 1,\n      y: 0\n    }); // calculate skew\n\n    var skewX = 180 / PI * atan2(px.y, px.x) - 90;\n    var skewY = 180 / PI * atan2(py.y, py.x);\n    return {\n      translateX: matrix.e,\n      translateY: matrix.f,\n      scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n      scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n      skewX: skewX,\n      skewY: skewY,\n      rotation: skewX // rotation is the same as skew x\n\n    };\n  }; // Return the `scale` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\n\n  V.matrixToScale = function (matrix) {\n    var a, b, c, d;\n\n    if (matrix) {\n      a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n      d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n      b = matrix.b;\n      c = matrix.c;\n    } else {\n      a = d = 1;\n    }\n\n    return {\n      sx: b ? sqrt(a * a + b * b) : a,\n      sy: c ? sqrt(c * c + d * d) : d\n    };\n  }; // Return the `rotate` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\n\n  V.matrixToRotate = function (matrix) {\n    var p = {\n      x: 0,\n      y: 1\n    };\n\n    if (matrix) {\n      p = V.deltaTransformPoint(matrix, p);\n    }\n\n    return {\n      angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n    };\n  }; // Return the `translate` transformation from the following equation:\n  // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n\n\n  V.matrixToTranslate = function (matrix) {\n    return {\n      tx: matrix && matrix.e || 0,\n      ty: matrix && matrix.f || 0\n    };\n  };\n\n  V.isV = function (object) {\n    return object instanceof V;\n  }; // For backwards compatibility:\n\n\n  V.isVElement = V.isV; // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n\n  V.isSVGGraphicsElement = function (node) {\n    if (!node) return false;\n    node = V.toNode(node); // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n\n    return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n  };\n\n  var svgDocument = V('svg').node;\n\n  V.createSVGMatrix = function (matrix) {\n    var svgMatrix = svgDocument.createSVGMatrix();\n\n    for (var component in matrix) {\n      svgMatrix[component] = matrix[component];\n    }\n\n    return svgMatrix;\n  };\n\n  V.createSVGTransform = function (matrix) {\n    if (!V.isUndefined(matrix)) {\n      if (!(matrix instanceof SVGMatrix)) {\n        matrix = V.createSVGMatrix(matrix);\n      }\n\n      return svgDocument.createSVGTransformFromMatrix(matrix);\n    }\n\n    return svgDocument.createSVGTransform();\n  };\n\n  V.createSVGPoint = function (x, y) {\n    var p = svgDocument.createSVGPoint();\n    p.x = x;\n    p.y = y;\n    return p;\n  };\n\n  V.transformRect = function (r, matrix) {\n    var p = svgDocument.createSVGPoint();\n    p.x = r.x;\n    p.y = r.y;\n    var corner1 = p.matrixTransform(matrix);\n    p.x = r.x + r.width;\n    p.y = r.y;\n    var corner2 = p.matrixTransform(matrix);\n    p.x = r.x + r.width;\n    p.y = r.y + r.height;\n    var corner3 = p.matrixTransform(matrix);\n    p.x = r.x;\n    p.y = r.y + r.height;\n    var corner4 = p.matrixTransform(matrix);\n    var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n    var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n    var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n    var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n    return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n  };\n\n  V.transformPoint = function (p, matrix) {\n    return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n  };\n\n  V.transformLine = function (l, matrix) {\n    return new g.Line(V.transformPoint(l.start, matrix), V.transformPoint(l.end, matrix));\n  };\n\n  V.transformPolyline = function (p, matrix) {\n    var inPoints = p instanceof g.Polyline ? p.points : p;\n    if (!V.isArray(inPoints)) inPoints = [];\n    var outPoints = [];\n\n    for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n\n    return new g.Polyline(outPoints);\n  }; // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n  // an object (`{ fill: 'blue', stroke: 'red' }`).\n\n\n  V.styleToObject = function (styleString) {\n    var ret = {};\n    var styles = styleString.split(';');\n\n    for (var i = 0; i < styles.length; i++) {\n      var style = styles[i];\n      var pair = style.split('=');\n      ret[pair[0].trim()] = pair[1].trim();\n    }\n\n    return ret;\n  }; // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n\n\n  V.createSlicePathData = function (innerRadius, outerRadius, startAngle, endAngle) {\n    var svgArcMax = 2 * PI - 1e-6;\n    var r0 = innerRadius;\n    var r1 = outerRadius;\n    var a0 = startAngle;\n    var a1 = endAngle;\n    var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n    var df = da < PI ? '0' : '1';\n    var c0 = cos(a0);\n    var s0 = sin(a0);\n    var c1 = cos(a1);\n    var s1 = sin(a1);\n    return da >= svgArcMax ? r0 ? 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'M0,' + r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + -r0 + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0 + 'Z' : 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1 + 'Z' : r0 ? 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L' + r0 * c1 + ',' + r0 * s1 + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0 + 'Z' : 'M' + r1 * c0 + ',' + r1 * s0 + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1 + 'L0,0' + 'Z';\n  }; // Merge attributes from object `b` with attributes in object `a`.\n  // Note that this modifies the object `a`.\n  // Also important to note that attributes are merged but CSS classes are concatenated.\n\n\n  V.mergeAttrs = function (a, b) {\n    for (var attr in b) {\n      if (attr === 'class') {\n        // Concatenate classes.\n        a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n      } else if (attr === 'style') {\n        // `style` attribute can be an object.\n        if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n          // `style` stored in `a` is an object.\n          a[attr] = V.mergeAttrs(a[attr], b[attr]);\n        } else if (V.isObject(a[attr])) {\n          // `style` in `a` is an object but it's a string in `b`.\n          // Convert the style represented as a string to an object in `b`.\n          a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n        } else if (V.isObject(b[attr])) {\n          // `style` in `a` is a string, in `b` it's an object.\n          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n        } else {\n          // Both styles are strings.\n          a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n        }\n      } else {\n        a[attr] = b[attr];\n      }\n    }\n\n    return a;\n  };\n\n  V.annotateString = function (t, annotations, opt) {\n    annotations = annotations || [];\n    opt = opt || {};\n    var offset = opt.offset || 0;\n    var compacted = [];\n    var batch;\n    var ret = [];\n    var item;\n    var prev;\n\n    for (var i = 0; i < t.length; i++) {\n      item = ret[i] = t[i];\n\n      for (var j = 0; j < annotations.length; j++) {\n        var annotation = annotations[j];\n        var start = annotation.start + offset;\n        var end = annotation.end + offset;\n\n        if (i >= start && i < end) {\n          // Annotation applies.\n          if (V.isObject(item)) {\n            // There is more than one annotation to be applied => Merge attributes.\n            item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n          } else {\n            item = ret[i] = {\n              t: t[i],\n              attrs: annotation.attrs\n            };\n          }\n\n          if (opt.includeAnnotationIndices) {\n            (item.annotations || (item.annotations = [])).push(j);\n          }\n        }\n      }\n\n      prev = ret[i - 1];\n\n      if (!prev) {\n        batch = item;\n      } else if (V.isObject(item) && V.isObject(prev)) {\n        // Both previous item and the current one are annotations. If the attributes\n        // didn't change, merge the text.\n        if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n          batch.t += item.t;\n        } else {\n          compacted.push(batch);\n          batch = item;\n        }\n      } else if (V.isObject(item)) {\n        // Previous item was a string, current item is an annotation.\n        compacted.push(batch);\n        batch = item;\n      } else if (V.isObject(prev)) {\n        // Previous item was an annotation, current item is a string.\n        compacted.push(batch);\n        batch = item;\n      } else {\n        // Both previous and current item are strings.\n        batch = (batch || '') + item;\n      }\n    }\n\n    if (batch) {\n      compacted.push(batch);\n    }\n\n    return compacted;\n  };\n\n  V.findAnnotationsAtIndex = function (annotations, index) {\n    var found = [];\n\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (annotation.start < index && index <= annotation.end) {\n          found.push(annotation);\n        }\n      });\n    }\n\n    return found;\n  };\n\n  V.findAnnotationsBetweenIndexes = function (annotations, start, end) {\n    var found = [];\n\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {\n          found.push(annotation);\n        }\n      });\n    }\n\n    return found;\n  }; // Shift all the text annotations after character `index` by `offset` positions.\n\n\n  V.shiftAnnotations = function (annotations, index, offset) {\n    if (annotations) {\n      annotations.forEach(function (annotation) {\n        if (annotation.start < index && annotation.end >= index) {\n          annotation.end += offset;\n        } else if (annotation.start >= index) {\n          annotation.start += offset;\n          annotation.end += offset;\n        }\n      });\n    }\n\n    return annotations;\n  };\n\n  V.convertLineToPathData = function (line) {\n    line = V(line);\n    var d = ['M', line.attr('x1'), line.attr('y1'), 'L', line.attr('x2'), line.attr('y2')].join(' ');\n    return d;\n  };\n\n  V.convertPolygonToPathData = function (polygon) {\n    var points = V.getPointsFromSvgNode(polygon);\n    if (points.length === 0) return null;\n    return V.svgPointsToPath(points) + ' Z';\n  };\n\n  V.convertPolylineToPathData = function (polyline) {\n    var points = V.getPointsFromSvgNode(polyline);\n    if (points.length === 0) return null;\n    return V.svgPointsToPath(points);\n  };\n\n  V.svgPointsToPath = function (points) {\n    for (var i = 0, n = points.length; i < n; i++) {\n      points[i] = points[i].x + ' ' + points[i].y;\n    }\n\n    return 'M ' + points.join(' L');\n  };\n\n  V.getPointsFromSvgNode = function (node) {\n    node = V.toNode(node);\n    var points = [];\n    var nodePoints = node.points;\n\n    if (nodePoints) {\n      for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n        points.push(nodePoints.getItem(i));\n      }\n    }\n\n    return points;\n  };\n\n  V.KAPPA = 0.551784;\n\n  V.convertCircleToPathData = function (circle) {\n    circle = V(circle);\n    var cx = parseFloat(circle.attr('cx')) || 0;\n    var cy = parseFloat(circle.attr('cy')) || 0;\n    var r = parseFloat(circle.attr('r'));\n    var cd = r * V.KAPPA; // Control distance.\n\n    var d = ['M', cx, cy - r, // Move to the first point.\n    'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n    'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n    'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n    'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n    'Z'].join(' ');\n    return d;\n  };\n\n  V.convertEllipseToPathData = function (ellipse) {\n    ellipse = V(ellipse);\n    var cx = parseFloat(ellipse.attr('cx')) || 0;\n    var cy = parseFloat(ellipse.attr('cy')) || 0;\n    var rx = parseFloat(ellipse.attr('rx'));\n    var ry = parseFloat(ellipse.attr('ry')) || rx;\n    var cdx = rx * V.KAPPA; // Control distance x.\n\n    var cdy = ry * V.KAPPA; // Control distance y.\n\n    var d = ['M', cx, cy - ry, // Move to the first point.\n    'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n    'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n    'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n    'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n    'Z'].join(' ');\n    return d;\n  };\n\n  V.convertRectToPathData = function (rect) {\n    rect = V(rect);\n    return V.rectToPath({\n      x: parseFloat(rect.attr('x')) || 0,\n      y: parseFloat(rect.attr('y')) || 0,\n      width: parseFloat(rect.attr('width')) || 0,\n      height: parseFloat(rect.attr('height')) || 0,\n      rx: parseFloat(rect.attr('rx')) || 0,\n      ry: parseFloat(rect.attr('ry')) || 0\n    });\n  }; // Convert a rectangle to SVG path commands. `r` is an object of the form:\n  // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n  // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n  // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n  // that has only `rx` and `ry` attributes).\n\n\n  V.rectToPath = function (r) {\n    var d;\n    var x = r.x;\n    var y = r.y;\n    var width = r.width;\n    var height = r.height;\n    var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n    var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n    var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n    var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n    if (topRx || bottomRx || topRy || bottomRy) {\n      d = ['M', x, y + topRy, 'v', height - topRy - bottomRy, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, 'h', width - 2 * bottomRx, 'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, 'v', -(height - bottomRy - topRy), 'a', topRx, topRy, 0, 0, 0, -topRx, -topRy, 'h', -(width - 2 * topRx), 'a', topRx, topRy, 0, 0, 0, -topRx, topRy, 'Z'];\n    } else {\n      d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];\n    }\n\n    return d.join(' ');\n  }; // Take a path data string\n  // Return a normalized path data string\n  // If data cannot be parsed, return 'M 0 0'\n  // Adapted from Rappid normalizePath polyfill\n  // Highly inspired by Raphael Library (www.raphael.com)\n\n\n  V.normalizePathData = function () {\n    var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n    var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n    var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n    var math = Math;\n    var PI = math.PI;\n    var sin = math.sin;\n    var cos = math.cos;\n    var tan = math.tan;\n    var asin = math.asin;\n    var sqrt = math.sqrt;\n    var abs = math.abs;\n\n    function q2c(x1, y1, ax, ay, x2, y2) {\n      var _13 = 1 / 3;\n\n      var _23 = 2 / 3;\n\n      return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\n    }\n\n    function rotate(x, y, rad) {\n      var X = x * cos(rad) - y * sin(rad);\n      var Y = x * sin(rad) + y * cos(rad);\n      return {\n        x: X,\n        y: Y\n      };\n    }\n\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n      // for more information of where this math came from visit:\n      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n      var _120 = PI * 120 / 180;\n\n      var rad = PI / 180 * (+angle || 0);\n      var res = [];\n      var xy;\n\n      if (!recursive) {\n        xy = rotate(x1, y1, -rad);\n        x1 = xy.x;\n        y1 = xy.y;\n        xy = rotate(x2, y2, -rad);\n        x2 = xy.x;\n        y2 = xy.y;\n        var x = (x1 - x2) / 2;\n        var y = (y1 - y2) / 2;\n        var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n        if (h > 1) {\n          h = sqrt(h);\n          rx = h * rx;\n          ry = h * ry;\n        }\n\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n        var cx = k * rx * y / ry + (x1 + x2) / 2;\n        var cy = k * -ry * x / rx + (y1 + y2) / 2;\n        var f1 = asin(((y1 - cy) / ry).toFixed(9));\n        var f2 = asin(((y2 - cy) / ry).toFixed(9));\n        f1 = x1 < cx ? PI - f1 : f1;\n        f2 = x2 < cx ? PI - f2 : f2;\n        if (f1 < 0) f1 = PI * 2 + f1;\n        if (f2 < 0) f2 = PI * 2 + f2;\n        if (sweep_flag && f1 > f2) f1 = f1 - PI * 2;\n        if (!sweep_flag && f2 > f1) f2 = f2 - PI * 2;\n      } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n      }\n\n      var df = f2 - f1;\n\n      if (abs(df) > _120) {\n        var f2old = f2;\n        var x2old = x2;\n        var y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * cos(f2);\n        y2 = cy + ry * sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n      }\n\n      df = f2 - f1;\n      var c1 = cos(f1);\n      var s1 = sin(f1);\n      var c2 = cos(f2);\n      var s2 = sin(f2);\n      var t = tan(df / 4);\n      var hx = 4 / 3 * (rx * t);\n      var hy = 4 / 3 * (ry * t);\n      var m1 = [x1, y1];\n      var m2 = [x1 + hx * s1, y1 - hy * c1];\n      var m3 = [x2 + hx * s2, y2 - hy * c2];\n      var m4 = [x2, y2];\n      m2[0] = 2 * m1[0] - m2[0];\n      m2[1] = 2 * m1[1] - m2[1];\n\n      if (recursive) {\n        return [m2, m3, m4].concat(res);\n      } else {\n        res = [m2, m3, m4].concat(res).join().split(',');\n        var newres = [];\n        var ii = res.length;\n\n        for (var i = 0; i < ii; i++) {\n          newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n        }\n\n        return newres;\n      }\n    }\n\n    function parsePathString(pathString) {\n      if (!pathString) return null;\n      var paramCounts = {\n        a: 7,\n        c: 6,\n        h: 1,\n        l: 2,\n        m: 2,\n        q: 4,\n        s: 4,\n        t: 2,\n        v: 1,\n        z: 0\n      };\n      var data = [];\n      String(pathString).replace(pathCommand, function (a, b, c) {\n        var params = [];\n        var name = b.toLowerCase();\n        c.replace(pathValues, function (a, b) {\n          if (b) params.push(+b);\n        });\n\n        if (name === 'm' && params.length > 2) {\n          data.push([b].concat(params.splice(0, 2)));\n          name = 'l';\n          b = b === 'm' ? 'l' : 'L';\n        }\n\n        while (params.length >= paramCounts[name]) {\n          data.push([b].concat(params.splice(0, paramCounts[name])));\n          if (!paramCounts[name]) break;\n        }\n      });\n      return data;\n    }\n\n    function pathToAbsolute(pathArray) {\n      if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {\n        // rough assumption\n        pathArray = parsePathString(pathArray);\n      } // if invalid string, return 'M 0 0'\n\n\n      if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n      var res = [];\n      var x = 0;\n      var y = 0;\n      var mx = 0;\n      var my = 0;\n      var start = 0;\n      var pa0;\n      var ii = pathArray.length;\n\n      for (var i = start; i < ii; i++) {\n        var r = [];\n        res.push(r);\n        var pa = pathArray[i];\n        pa0 = pa[0];\n\n        if (pa0 != pa0.toUpperCase()) {\n          r[0] = pa0.toUpperCase();\n          var jj;\n          var j;\n\n          switch (r[0]) {\n            case 'A':\n              r[1] = pa[1];\n              r[2] = pa[2];\n              r[3] = pa[3];\n              r[4] = pa[4];\n              r[5] = pa[5];\n              r[6] = +pa[6] + x;\n              r[7] = +pa[7] + y;\n              break;\n\n            case 'V':\n              r[1] = +pa[1] + y;\n              break;\n\n            case 'H':\n              r[1] = +pa[1] + x;\n              break;\n\n            case 'M':\n              mx = +pa[1] + x;\n              my = +pa[2] + y;\n              jj = pa.length;\n\n              for (j = 1; j < jj; j++) {\n                r[j] = +pa[j] + (j % 2 ? x : y);\n              }\n\n              break;\n\n            default:\n              jj = pa.length;\n\n              for (j = 1; j < jj; j++) {\n                r[j] = +pa[j] + (j % 2 ? x : y);\n              }\n\n              break;\n          }\n        } else {\n          var kk = pa.length;\n\n          for (var k = 0; k < kk; k++) {\n            r[k] = pa[k];\n          }\n        }\n\n        switch (r[0]) {\n          case 'Z':\n            x = +mx;\n            y = +my;\n            break;\n\n          case 'H':\n            x = r[1];\n            break;\n\n          case 'V':\n            y = r[1];\n            break;\n\n          case 'M':\n            mx = r[r.length - 2];\n            my = r[r.length - 1];\n            x = r[r.length - 2];\n            y = r[r.length - 1];\n            break;\n\n          default:\n            x = r[r.length - 2];\n            y = r[r.length - 1];\n            break;\n        }\n      }\n\n      return res;\n    }\n\n    function normalize(path) {\n      var p = pathToAbsolute(path);\n      var attrs = {\n        x: 0,\n        y: 0,\n        bx: 0,\n        by: 0,\n        X: 0,\n        Y: 0,\n        qx: null,\n        qy: null\n      };\n\n      function processPath(path, d, pcom) {\n        var nx, ny;\n        if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n        if (!(path[0] in {\n          T: 1,\n          Q: 1\n        })) {\n          d.qx = null;\n          d.qy = null;\n        }\n\n        switch (path[0]) {\n          case 'M':\n            d.X = path[1];\n            d.Y = path[2];\n            break;\n\n          case 'A':\n            if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n              // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n              // \"If either rx or ry is 0, then this arc is treated as a\n              // straight line segment (a \"lineto\") joining the endpoints.\"\n              path = ['L', path[6], path[7]];\n            } else {\n              path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n            }\n\n            break;\n\n          case 'S':\n            if (pcom === 'C' || pcom === 'S') {\n              // In 'S' case we have to take into account, if the previous command is C/S.\n              nx = d.x * 2 - d.bx; // And reflect the previous\n\n              ny = d.y * 2 - d.by; // command's control point relative to the current point.\n            } else {\n              // or some else or nothing\n              nx = d.x;\n              ny = d.y;\n            }\n\n            path = ['C', nx, ny].concat(path.slice(1));\n            break;\n\n          case 'T':\n            if (pcom === 'Q' || pcom === 'T') {\n              // In 'T' case we have to take into account, if the previous command is Q/T.\n              d.qx = d.x * 2 - d.qx; // And make a reflection similar\n\n              d.qy = d.y * 2 - d.qy; // to case 'S'.\n            } else {\n              // or something else or nothing\n              d.qx = d.x;\n              d.qy = d.y;\n            }\n\n            path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n            break;\n\n          case 'Q':\n            d.qx = path[1];\n            d.qy = path[2];\n            path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n            break;\n\n          case 'H':\n            path = ['L'].concat(path[1], d.y);\n            break;\n\n          case 'V':\n            path = ['L'].concat(d.x, path[1]);\n            break;\n\n          case 'L':\n            break;\n\n          case 'Z':\n            break;\n        }\n\n        return path;\n      }\n\n      function fixArc(pp, i) {\n        if (pp[i].length > 7) {\n          pp[i].shift();\n          var pi = pp[i];\n\n          while (pi.length) {\n            pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n\n            pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n          }\n\n          pp.splice(i, 1);\n          ii = p.length;\n        }\n      }\n\n      var pcoms = []; // path commands of original path p\n\n      var pfirst = ''; // temporary holder for original path command\n\n      var pcom = ''; // holder for previous path command of original path\n\n      var ii = p.length;\n\n      for (var i = 0; i < ii; i++) {\n        if (p[i]) pfirst = p[i][0]; // save current path command\n\n        if (pfirst !== 'C') {\n          // C is not saved yet, because it may be result of conversion\n          pcoms[i] = pfirst; // Save current path command\n\n          if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n        }\n\n        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n        if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n        // which may produce multiple 'C's\n        // so we have to make sure that 'C' is also 'C' in original path\n\n        fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n        var seg = p[i];\n        var seglen = seg.length;\n        attrs.x = seg[seglen - 2];\n        attrs.y = seg[seglen - 1];\n        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n      } // make sure normalized path data string starts with an M segment\n\n\n      if (!p[0][0] || p[0][0] !== 'M') {\n        p.unshift(['M', 0, 0]);\n      }\n\n      return p;\n    }\n\n    return function (pathData) {\n      return normalize(pathData).join(',').split(',').join(' ');\n    };\n  }();\n\n  V.namespace = ns;\n  V.g = g;\n  return V;\n}();\n\nexport default V;","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/V/index.mjs"],"names":["g","V","hasSvg","window","SVGAngle","document","implementation","hasFeature","Error","ns","svg","xmlns","xml","xlink","xhtml","SVGVersion","math","Math","PI","atan2","sqrt","min","max","cos","sin","el","attrs","children","apply","Object","create","prototype","arguments","isV","node","isString","toLowerCase","createSvgDocument","svgDoc","childNodes","length","arrayOfVels","i","len","childNode","push","importNode","firstChild","createElementNS","ensureId","setAttributes","append","VPrototype","defineProperty","enumerable","get","id","set","getTransformToElement","target","isSVGGraphicsElement","targetCTM","toNode","getScreenCTM","nodeCTM","inverse","multiply","createSVGMatrix","transform","matrix","opt","isUndefined","transformStringToMatrix","attr","absolute","matrixToTransformString","svgTransform","createSVGTransform","baseVal","appendItem","translate","tx","ty","transformAttr","parseTransformString","value","replace","trim","newTx","newTy","newTranslate","rotate","angle","cx","cy","newAngle","newOrigin","undefined","newRotate","scale","sx","sy","newScale","bbox","withoutTransformations","box","ownerSVGElement","Rect","getBBox","e","x","clientLeft","y","clientTop","width","clientWidth","height","clientHeight","transformRect","options","outputBBox","recursive","n","currentChild","childBBox","union","createTextPathNode","vel","textPathElement","d","linkedPath","appendTo","defs","isObject","annotateTextLine","lineNode","lineAnnotations","includeAnnotationIndices","eol","lineHeight","baseSize","maxFontSize","fontMetrics","lastJ","j","annotation","fontSize","annotationAttrs","vTSpan","tspanNode","t","textContent","annotationClass","addClass","annotations","parseFloat","createTextNode","appendChild","emRegex","convertEmToPx","em","numerical","test","calculateDY","alignment","linesMetrics","baseSizePx","Array","isArray","lineMetrics","flMaxFont","rLineHeights","lineHeightPx","iLineHeight","llMaxFont","dy","text","content","sanitizeText","displayEmpty","textPath","verticalAnchor","textVerticalAnchor","namedVerticalAnchor","iai","defaultLineHeight","autoLineHeight","empty","doc","containerNode","createDocumentFragment","offset","lines","split","annotatedY","lastI","lineClassName","line","annotateString","lineNodeStyle","style","fillOpacity","strokeOpacity","setAttribute","className","rh","removeAttr","name","qualifiedName","qualifyAttr","hasAttributeNS","local","removeAttributeNS","hasAttribute","removeAttribute","attributes","getAttribute","attrName","hasOwnProperty","normalizePath","tagName","normalizePathData","remove","parentNode","removeChild","key","els","prepend","child","before","parent","insertBefore","SVGSVGElement","toUpperCase","context","defsNode","getElementsByTagName","clone","cloneNode","uniqueId","findOne","selector","found","querySelector","find","vels","nodes","querySelectorAll","outputArray","nodeType","index","previousSibling","findParentByClass","terminator","hasClass","contains","a","b","bup","compareDocumentPosition","toLocalPoint","p","createSVGPoint","globalPoint","matrixTransform","globalToLocalMatrix","translateCenterToPoint","center","translateAndAutoOrient","position","reference","Point","translateToOrigin","setTranslate","rotateAroundOrigin","angleBetween","setRotate","translateFromOrigin","finalPosition","move","ctm","setMatrix","animateAlongPath","path","animateMotion","mpath","beginElement","documentElement","animation","animators","animationID","id2anim","targets","getTargets","animator","Animator","register","RegExp","prevClasses","removeClass","newClasses","toggleClass","toAdd","toRemove","sample","interval","getTotalLength","samples","distance","getPointAtLength","convertToPath","convertToPathData","convertLineToPathData","convertPolygonToPathData","convertPolylineToPathData","convertEllipseToPathData","convertCircleToPathData","convertRectToPathData","toGeometryShape","r","rx","ry","points","x1","x2","y1","y2","Ellipse","getPointsFromSvgNode","Polyline","Path","isDataSupported","Line","findIntersection","ref","intersectionWithLineFromCenterToPoint","spot","gRect","rectMatrix","rectMatrixComponents","decomposeMatrix","resetRotation","rotation","rect","pathNode","minDistance","Infinity","closestSamples","gp","centerDistance","refDistance","sort","setAttributeNS","XMLString","parseXML","async","createSVGStyle","stylesheet","type","createCDATASection","data","createDocument","idCounter","nodeName","parser","DOMParser","parseFromString","error","indexOf","combinedKey","transformRegex","transformSeparatorRegex","transformationListRegex","transformationMatrix","matches","match","transformationString","transformationMatch","args","scaleNonUniform","skewX","skewY","c","f","separator","decomposedMatrix","translateX","translateY","scaleX","scaleY","transformations","join","translateMatch","rotateMatch","scaleMatch","parseInt","deltaTransformPoint","point","dx","px","py","matrixToScale","matrixToRotate","normalizeAngle","toDeg","matrixToTranslate","object","isVElement","SVGElement","svgDocument","svgMatrix","component","SVGMatrix","createSVGTransformFromMatrix","corner1","corner2","corner3","corner4","minX","maxX","minY","maxY","transformPoint","transformLine","l","start","end","transformPolyline","inPoints","outPoints","styleToObject","styleString","ret","styles","pair","createSlicePathData","innerRadius","outerRadius","startAngle","endAngle","svgArcMax","r0","r1","a0","a1","da","df","c0","s0","c1","s1","mergeAttrs","compacted","batch","item","prev","JSON","stringify","findAnnotationsAtIndex","forEach","findAnnotationsBetweenIndexes","shiftAnnotations","polygon","svgPointsToPath","polyline","nodePoints","numberOfItems","getItem","KAPPA","circle","cd","ellipse","cdx","cdy","rectToPath","topRx","bottomRx","topRy","bottomRy","spaces","pathCommand","pathValues","tan","asin","abs","q2c","ax","ay","_13","_23","rad","X","Y","a2c","large_arc_flag","sweep_flag","_120","res","xy","h","rx2","ry2","k","f1","toFixed","f2","f2old","x2old","y2old","c2","s2","hx","hy","m1","m2","m3","m4","concat","newres","ii","parsePathString","pathString","paramCounts","m","q","s","v","z","String","params","splice","pathToAbsolute","pathArray","mx","my","pa0","pa","jj","kk","normalize","bx","by","qx","qy","processPath","pcom","nx","ny","T","Q","slice","fixArc","pp","shift","pi","pcoms","pfirst","seg","seglen","unshift","pathData","namespace"],"mappings":"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","sourcesContent":["// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\nimport * as g from '../g/index.mjs';\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' &&\n        !!(\n            window.SVGAngle ||\n            document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\n        );\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new g.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new g.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new g.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (fontSize === undefined) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            default:\n            case 'top':\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) lineMetrics = {};\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        var qualifiedName = V.qualifyAttr(name);\n        var el = this.node;\n\n        if (qualifiedName.ns) {\n            if (el.hasAttributeNS(qualifiedName.ns, qualifiedName.local)) {\n                el.removeAttributeNS(qualifiedName.ns, qualifiedName.local);\n            }\n        } else if (el.hasAttribute(name)) {\n            el.removeAttribute(name);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(name);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new g.Point(position);\n        reference =  new g.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n    VPrototype.hasClass = function(className) {\n\n        return new RegExp('(\\\\s|^)' + className + '(\\\\s|$)').test(this.node.getAttribute('class'));\n    };\n\n    VPrototype.addClass = function(className) {\n\n        if (className && !this.hasClass(className)) {\n            var prevClasses = this.node.getAttribute('class') || '';\n            this.node.setAttribute('class', (prevClasses + ' ' + className).trim());\n        }\n\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n\n        if (className && this.hasClass(className)) {\n            var newClasses = this.node.getAttribute('class').replace(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)', 'g'), '$2');\n            this.node.setAttribute('class', newClasses);\n        }\n\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n\n        var toRemove = V.isUndefined(toAdd) ? this.hasClass(className) : !toAdd;\n\n        if (toRemove) {\n            this.removeClass(className);\n        } else {\n            this.addClass(className);\n        }\n\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new g.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new g.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new g.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new g.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!g.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new g.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new g.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new g.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new g.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new g.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        var el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        var qualifiedName = V.qualifyAttr(name);\n\n        if (qualifiedName.ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(qualifiedName.ns, name, value);\n        } else if (name === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    V.transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\n    V.transformSeparatorRegex = /[ ,]+/;\n    V.transformationListRegex = /^(\\w+)\\((.*)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        var transformationMatrix = V.createSVGMatrix();\n        var matches = transform && transform.match(V.transformRegex);\n        if (!matches) {\n            return transformationMatrix;\n        }\n\n        for (var i = 0, n = matches.length; i < n; i++) {\n            var transformationString = matches[i];\n\n            var transformationMatch = transformationString.match(V.transformationListRegex);\n            if (transformationMatch) {\n                var sx, sy, tx, ty, angle;\n                var ctm = V.createSVGMatrix();\n                var args = transformationMatch[2].split(V.transformSeparatorRegex);\n                switch (transformationMatch[1].toLowerCase()) {\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n                    default:\n                        continue;\n                }\n\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Allow reading transform string with a single matrix\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                var translateMatch = transform.match(/translate\\((.*?)\\)/);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                var rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                var scaleMatch = transform.match(/scale\\((.*?)\\)/);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: g.normalizeAngle(g.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new g.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new g.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new g.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof g.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new g.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Adapted from Rappid normalizePath polyfill\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = g;\n\n    return V;\n\n})();\n\nexport default V;\n"]},"metadata":{},"sourceType":"module"}