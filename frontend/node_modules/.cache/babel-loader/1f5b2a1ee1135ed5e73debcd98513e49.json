{"ast":null,"code":"import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs'; // Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n  defaults: {\n    position: {\n      x: 0,\n      y: 0\n    },\n    size: {\n      width: 1,\n      height: 1\n    },\n    angle: 0\n  },\n  initialize: function () {\n    this._initializePorts();\n\n    Cell.prototype.initialize.apply(this, arguments);\n  },\n\n  /**\n   * @abstract\n   */\n  _initializePorts: function () {// implemented in ports.js\n  },\n  _refreshPorts: function () {// implemented in ports.js\n  },\n  isElement: function () {\n    return true;\n  },\n  position: function (x, y, opt) {\n    var isSetter = isNumber(y);\n    opt = (isSetter ? opt : x) || {}; // option `parentRelative` for setting the position relative to the element's parent.\n\n    if (opt.parentRelative) {\n      // Getting the parent's position requires the collection.\n      // Cell.parent() holds cell id only.\n      if (!this.graph) throw new Error('Element must be part of a graph.');\n      var parent = this.getParentCell();\n      var parentPosition = parent && !parent.isLink() ? parent.get('position') : {\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (isSetter) {\n      if (opt.parentRelative) {\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n\n      if (opt.deep) {\n        var currentPosition = this.get('position');\n        this.translate(x - currentPosition.x, y - currentPosition.y, opt);\n      } else {\n        this.set('position', {\n          x: x,\n          y: y\n        }, opt);\n      }\n\n      return this;\n    } else {\n      // Getter returns a geometry point.\n      var elementPosition = Point(this.get('position'));\n      return opt.parentRelative ? elementPosition.difference(parentPosition) : elementPosition;\n    }\n  },\n  translate: function (tx, ty, opt) {\n    tx = tx || 0;\n    ty = ty || 0;\n\n    if (tx === 0 && ty === 0) {\n      // Like nothing has happened.\n      return this;\n    }\n\n    opt = opt || {}; // Pass the initiator of the translation.\n\n    opt.translateBy = opt.translateBy || this.id;\n    var position = this.get('position') || {\n      x: 0,\n      y: 0\n    };\n    var ra = opt.restrictedArea;\n\n    if (ra && opt.translateBy === this.id) {\n      if (typeof ra === 'function') {\n        var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n        tx = newPosition.x - position.x;\n        ty = newPosition.y - position.y;\n      } else {\n        // We are restricting the translation for the element itself only. We get\n        // the bounding box of the element including all its embeds.\n        // All embeds have to be translated the exact same way as the element.\n        var bbox = this.getBBox({\n          deep: true\n        }); //- - - - - - - - - - - - -> ra.x + ra.width\n        // - - - -> position.x      |\n        // -> bbox.x\n        //                ▓▓▓▓▓▓▓   |\n        //         ░░░░░░░▓▓▓▓▓▓▓\n        //         ░░░░░░░░░        |\n        //   ▓▓▓▓▓▓▓▓░░░░░░░\n        //   ▓▓▓▓▓▓▓▓               |\n        //   <-dx->                     | restricted area right border\n        //         <-width->        |   ░ translated element\n        //   <- - bbox.width - ->       ▓ embedded element\n\n        var dx = position.x - bbox.x;\n        var dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n        // while complies the restrictions.\n\n        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n        tx = x - position.x;\n        ty = y - position.y;\n      }\n    }\n\n    var translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    }; // To find out by how much an element was translated in event 'change:position' handlers.\n\n    opt.tx = tx;\n    opt.ty = ty;\n\n    if (opt.transition) {\n      if (!isObject(opt.transition)) opt.transition = {};\n      this.transition('position', translatedPosition, assign({}, opt.transition, {\n        valueFunction: interpolate.object\n      })); // Recursively call `translate()` on all the embeds cells.\n\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n    } else {\n      this.startBatch('translate', opt);\n      this.set('position', translatedPosition, opt);\n      invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n      this.stopBatch('translate', opt);\n    }\n\n    return this;\n  },\n  size: function (width, height, opt) {\n    var currentSize = this.get('size'); // Getter\n    // () signature\n\n    if (width === undefined) {\n      return {\n        width: currentSize.width,\n        height: currentSize.height\n      };\n    } // Setter\n    // (size, opt) signature\n\n\n    if (isObject(width)) {\n      opt = height;\n      height = isNumber(width.height) ? width.height : currentSize.height;\n      width = isNumber(width.width) ? width.width : currentSize.width;\n    }\n\n    return this.resize(width, height, opt);\n  },\n  resize: function (width, height, opt) {\n    opt = opt || {};\n    this.startBatch('resize', opt);\n\n    if (opt.direction) {\n      var currentSize = this.get('size');\n\n      switch (opt.direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height;\n          break;\n\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width;\n          break;\n      } // Get the angle and clamp its value between 0 and 360 degrees.\n\n\n      var angle = normalizeAngle(this.get('angle') || 0); // This is a rectangle in size of the un-rotated element.\n\n      var bbox = this.getBBox();\n      var origin;\n\n      if (angle) {\n        var quadrant = {\n          'top-right': 0,\n          'right': 0,\n          'top-left': 1,\n          'top': 1,\n          'bottom-left': 2,\n          'left': 2,\n          'bottom-right': 3,\n          'bottom': 3\n        }[opt.direction];\n\n        if (opt.absolute) {\n          // We are taking the element's rotation into account\n          quadrant += Math.floor((angle + 45) / 90);\n          quadrant %= 4;\n        } // Pick the corner point on the element, which meant to stay on its place before and\n        // after the rotation.\n\n\n        var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]](); // Find  an image of the previous indent point. This is the position, where is the\n        // point actually located on the screen.\n\n        var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle); // Every point on the element rotates around a circle with the centre of rotation\n        // in the middle of the element while the whole element is being rotated. That means\n        // that the distance from a point in the corner of the element (supposed its always rect) to\n        // the center of the element doesn't change during the rotation and therefore it equals\n        // to a distance on un-rotated element.\n        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n        var radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n        // and ending at the center of the element. We call this angle `alpha`.\n        // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n        // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n        //\n        // 3 | 2\n        // --c-- Quadrant positions around the element's center `c`\n        // 0 | 1\n        //\n\n        var alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n        // going through the center of the element) and line crossing the indent of the fixed point and the center\n        // of the element. This is the angle we need but on the un-rotated element.\n\n        alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated by and that's it.\n\n        alpha -= toRad(angle); // With this angle and distance we can easily calculate the centre of the un-rotated element.\n        // Note that fromPolar constructor accepts an angle in radians.\n\n        var center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width on the left\n        // and half a height to the top from the center. This will be the origin of rectangle\n        // we were looking for.\n\n        origin = Point(center).offset(width / -2, height / -2);\n      } else {\n        // calculation for the origin Point when there is no rotation of the element\n        origin = bbox.topLeft();\n\n        switch (opt.direction) {\n          case 'top':\n          case 'top-right':\n            origin.offset(0, bbox.height - height);\n            break;\n\n          case 'left':\n          case 'bottom-left':\n            origin.offset(bbox.width - width, 0);\n            break;\n\n          case 'top-left':\n            origin.offset(bbox.width - width, bbox.height - height);\n            break;\n        }\n      } // Resize the element (before re-positioning it).\n\n\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt); // Finally, re-position the element.\n\n      this.position(origin.x, origin.y, opt);\n    } else {\n      // Resize the element.\n      this.set('size', {\n        width: width,\n        height: height\n      }, opt);\n    }\n\n    this.stopBatch('resize', opt);\n    return this;\n  },\n  scale: function (sx, sy, origin, opt) {\n    var scaledBBox = this.getBBox().scale(sx, sy, origin);\n    this.startBatch('scale', opt);\n    this.position(scaledBBox.x, scaledBBox.y, opt);\n    this.resize(scaledBBox.width, scaledBBox.height, opt);\n    this.stopBatch('scale');\n    return this;\n  },\n  fitEmbeds: function (opt = {}) {\n    // Getting the children's size and position requires the collection.\n    // Cell.get('embeds') helds an array of cell ids only.\n    const {\n      graph\n    } = this;\n    if (!graph) throw new Error('Element must be part of a graph.');\n    const embeddedCells = this.getEmbeddedCells().filter(cell => cell.isElement());\n    if (embeddedCells.length === 0) return this;\n    this.startBatch('fit-embeds', opt);\n\n    if (opt.deep) {\n      // Recursively apply fitEmbeds on all embeds first.\n      invoke(embeddedCells, 'fitEmbeds', opt);\n    } // Compute cell's size and position based on the children bbox\n    // and given padding.\n\n\n    const {\n      left,\n      right,\n      top,\n      bottom\n    } = normalizeSides(opt.padding);\n    let {\n      x,\n      y,\n      width,\n      height\n    } = graph.getCellsBBox(embeddedCells); // Apply padding computed above to the bbox.\n\n    x -= left;\n    y -= top;\n    width += left + right;\n    height += bottom + top; // Set new element dimensions finally.\n\n    this.set({\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    }, opt);\n    this.stopBatch('fit-embeds');\n    return this;\n  },\n  // Rotate element by `angle` degrees, optionally around `origin` point.\n  // If `origin` is not provided, it is considered to be the center of the element.\n  // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n  // the difference from the previous angle.\n  rotate: function (angle, absolute, origin, opt) {\n    if (origin) {\n      var center = this.getBBox().center();\n      var size = this.get('size');\n      var position = this.get('position');\n      center.rotate(origin, this.get('angle') - angle);\n      var dx = center.x - size.width / 2 - position.x;\n      var dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle: angle,\n        absolute: absolute,\n        origin: origin\n      });\n      this.position(position.x + dx, position.y + dy, opt);\n      this.rotate(angle, absolute, null, opt);\n      this.stopBatch('rotate');\n    } else {\n      this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n    }\n\n    return this;\n  },\n  angle: function () {\n    return normalizeAngle(this.get('angle') || 0);\n  },\n  getBBox: function (opt) {\n    opt = opt || {};\n\n    if (opt.deep && this.graph) {\n      // Get all the embedded elements using breadth first algorithm,\n      // that doesn't use recursion.\n      var elements = this.getEmbeddedCells({\n        deep: true,\n        breadthFirst: true\n      }); // Add the model itself.\n\n      elements.push(this);\n      return this.graph.getCellsBBox(elements);\n    }\n\n    var position = this.get('position');\n    var size = this.get('size');\n    return new Rect(position.x, position.y, size.width, size.height);\n  },\n  getPointFromConnectedLink: function (link, endType) {\n    // Center of the model\n    var bbox = this.getBBox();\n    var center = bbox.center(); // Center of a port\n\n    var endDef = link.get(endType);\n    if (!endDef) return center;\n    var portId = endDef.port;\n    if (!portId || !this.hasPort(portId)) return center;\n    var portGroup = this.portProp(portId, ['group']);\n    var portsPositions = this.getPortsPositions(portGroup);\n    var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n    var angle = this.angle();\n    if (angle) portCenter.rotate(center, -angle);\n    return portCenter;\n  }\n});\nassign(Element.prototype, elementPortPrototype);","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/dia/Element.mjs"],"names":["Cell","Point","toRad","normalizeAngle","Rect","isNumber","isObject","interpolate","assign","invoke","normalizeSides","elementPortPrototype","Element","extend","defaults","position","x","y","size","width","height","angle","initialize","_initializePorts","prototype","apply","arguments","_refreshPorts","isElement","opt","isSetter","parentRelative","graph","Error","parent","getParentCell","parentPosition","isLink","get","deep","currentPosition","translate","set","elementPosition","difference","tx","ty","translateBy","id","ra","restrictedArea","newPosition","call","bbox","getBBox","dx","dy","Math","max","min","translatedPosition","transition","valueFunction","object","getEmbeddedCells","startBatch","stopBatch","currentSize","undefined","resize","direction","origin","quadrant","absolute","floor","fixedPoint","imageFixedPoint","rotate","center","radius","sqrt","alpha","PI","atan","fromPolar","offset","topLeft","scale","sx","sy","scaledBBox","fitEmbeds","embeddedCells","filter","cell","length","left","right","top","bottom","padding","getCellsBBox","elements","breadthFirst","push","getPointFromConnectedLink","link","endType","endDef","portId","port","hasPort","portGroup","portProp","portsPositions","getPortsPositions","portCenter"],"mappings":"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","sourcesContent":["import { Cell } from './Cell.mjs';\nimport { Point, toRad, normalizeAngle, Rect } from '../g/index.mjs';\nimport { isNumber, isObject, interpolate, assign, invoke, normalizeSides } from '../util/index.mjs';\nimport { elementPortPrototype } from './ports.mjs';\n\n// Element base model.\n// -----------------------------\n\nexport const Element = Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        var isSetter = isNumber(y);\n\n        opt = (isSetter ? opt : x) || {};\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        if (opt.parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            var parent = this.getParentCell();\n            var parentPosition = parent && !parent.isLink()\n                ? parent.get('position')\n                : { x: 0, y: 0 };\n        }\n\n        if (isSetter) {\n\n            if (opt.parentRelative) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (opt.deep) {\n                var currentPosition = this.get('position');\n                this.translate(x - currentPosition.x, y - currentPosition.y, opt);\n            } else {\n                this.set('position', { x: x, y: y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            var elementPosition = Point(this.get('position'));\n\n            return opt.parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                ▓▓▓▓▓▓▓   |\n                //         ░░░░░░░▓▓▓▓▓▓▓\n                //         ░░░░░░░░░        |\n                //   ▓▓▓▓▓▓▓▓░░░░░░░\n                //   ▓▓▓▓▓▓▓▓               |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |   ░ translated element\n                //   <- - bbox.width - ->       ▓ embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!isObject(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, assign({}, opt.transition, {\n                valueFunction: interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            invoke(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if (isObject(width)) {\n            opt = height;\n            height = isNumber(width.height) ? width.height : currentSize.height;\n            width = isNumber(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = normalizeAngle(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = Point(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= toRad(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = Point(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') helds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const embeddedCells = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (embeddedCells.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // Recursively apply fitEmbeds on all embeds first.\n            invoke(embeddedCells, 'fitEmbeds', opt);\n        }\n\n        // Compute cell's size and position based on the children bbox\n        // and given padding.\n        const { left, right, top, bottom } = normalizeSides(opt.padding);\n        let { x, y, width, height } = graph.getCellsBBox(embeddedCells);\n        // Apply padding computed above to the bbox.\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n\n        // Set new element dimensions finally.\n        this.set({\n            position: { x, y },\n            size: { width, height }\n        }, opt);\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return normalizeAngle(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt) {\n\n        opt = opt || {};\n\n        if (opt.deep && this.graph) {\n\n            // Get all the embedded elements using breadth first algorithm,\n            // that doesn't use recursion.\n            var elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n\n            return this.graph.getCellsBBox(elements);\n        }\n\n        var position = this.get('position');\n        var size = this.get('size');\n\n        return new Rect(position.x, position.y, size.width, size.height);\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\nassign(Element.prototype, elementPortPrototype);\n\n"]},"metadata":{},"sourceType":"module"}