{"ast":null,"code":"import { uniq, toArray, isEmpty } from './util.mjs'; // Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\n\nexport function cloneCells(cells) {\n  cells = uniq(cells); // A map of the form [original cell ID] -> [clone] helping\n  // us to reconstruct references for source/target and parent/embeds.\n  // This is also the returned value.\n\n  const cloneMap = toArray(cells).reduce(function (map, cell) {\n    map[cell.id] = cell.clone();\n    return map;\n  }, {});\n  toArray(cells).forEach(function (cell) {\n    const clone = cloneMap[cell.id]; // assert(clone exists)\n\n    if (clone.isLink()) {\n      const source = clone.source();\n      const target = clone.target();\n\n      if (source.id && cloneMap[source.id]) {\n        // Source points to an element and the element is among the clones.\n        // => Update the source of the cloned link.\n        clone.prop('source/id', cloneMap[source.id].id);\n      }\n\n      if (target.id && cloneMap[target.id]) {\n        // Target points to an element and the element is among the clones.\n        // => Update the target of the cloned link.\n        clone.prop('target/id', cloneMap[target.id].id);\n      }\n    } // Find the parent of the original cell\n\n\n    const parent = cell.get('parent');\n\n    if (parent && cloneMap[parent]) {\n      clone.set('parent', cloneMap[parent].id);\n    } // Find the embeds of the original cell\n\n\n    const embeds = toArray(cell.get('embeds')).reduce(function (newEmbeds, embed) {\n      // Embedded cells that are not being cloned can not be carried\n      // over with other embedded cells.\n      if (cloneMap[embed]) {\n        newEmbeds.push(cloneMap[embed].id);\n      }\n\n      return newEmbeds;\n    }, []);\n\n    if (!isEmpty(embeds)) {\n      clone.set('embeds', embeds);\n    }\n  });\n  return cloneMap;\n}","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/util/cloneCells.mjs"],"names":["uniq","toArray","isEmpty","cloneCells","cells","cloneMap","reduce","map","cell","id","clone","forEach","isLink","source","target","prop","parent","get","set","embeds","newEmbeds","embed","push"],"mappings":"AAAA,SAASA,IAAT,EAAeC,OAAf,EAAwBC,OAAxB,QAAuC,YAAvC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,UAAT,CAAoBC,KAApB,EAA2B;AAE9BA,EAAAA,KAAK,GAAGJ,IAAI,CAACI,KAAD,CAAZ,CAF8B,CAI9B;AACA;AACA;;AACA,QAAMC,QAAQ,GAAGJ,OAAO,CAACG,KAAD,CAAP,CAAeE,MAAf,CAAsB,UAASC,GAAT,EAAcC,IAAd,EAAoB;AACvDD,IAAAA,GAAG,CAACC,IAAI,CAACC,EAAN,CAAH,GAAeD,IAAI,CAACE,KAAL,EAAf;AACA,WAAOH,GAAP;AACH,GAHgB,EAGd,EAHc,CAAjB;AAKAN,EAAAA,OAAO,CAACG,KAAD,CAAP,CAAeO,OAAf,CAAuB,UAASH,IAAT,EAAe;AAElC,UAAME,KAAK,GAAGL,QAAQ,CAACG,IAAI,CAACC,EAAN,CAAtB,CAFkC,CAGlC;;AAEA,QAAIC,KAAK,CAACE,MAAN,EAAJ,EAAoB;AAChB,YAAMC,MAAM,GAAGH,KAAK,CAACG,MAAN,EAAf;AACA,YAAMC,MAAM,GAAGJ,KAAK,CAACI,MAAN,EAAf;;AACA,UAAID,MAAM,CAACJ,EAAP,IAAaJ,QAAQ,CAACQ,MAAM,CAACJ,EAAR,CAAzB,EAAsC;AAClC;AACA;AACAC,QAAAA,KAAK,CAACK,IAAN,CAAW,WAAX,EAAwBV,QAAQ,CAACQ,MAAM,CAACJ,EAAR,CAAR,CAAoBA,EAA5C;AACH;;AACD,UAAIK,MAAM,CAACL,EAAP,IAAaJ,QAAQ,CAACS,MAAM,CAACL,EAAR,CAAzB,EAAsC;AAClC;AACA;AACAC,QAAAA,KAAK,CAACK,IAAN,CAAW,WAAX,EAAwBV,QAAQ,CAACS,MAAM,CAACL,EAAR,CAAR,CAAoBA,EAA5C;AACH;AACJ,KAlBiC,CAoBlC;;;AACA,UAAMO,MAAM,GAAGR,IAAI,CAACS,GAAL,CAAS,QAAT,CAAf;;AACA,QAAID,MAAM,IAAIX,QAAQ,CAACW,MAAD,CAAtB,EAAgC;AAC5BN,MAAAA,KAAK,CAACQ,GAAN,CAAU,QAAV,EAAoBb,QAAQ,CAACW,MAAD,CAAR,CAAiBP,EAArC;AACH,KAxBiC,CA0BlC;;;AACA,UAAMU,MAAM,GAAGlB,OAAO,CAACO,IAAI,CAACS,GAAL,CAAS,QAAT,CAAD,CAAP,CAA4BX,MAA5B,CAAmC,UAASc,SAAT,EAAoBC,KAApB,EAA2B;AACzE;AACA;AACA,UAAIhB,QAAQ,CAACgB,KAAD,CAAZ,EAAqB;AACjBD,QAAAA,SAAS,CAACE,IAAV,CAAejB,QAAQ,CAACgB,KAAD,CAAR,CAAgBZ,EAA/B;AACH;;AACD,aAAOW,SAAP;AACH,KAPc,EAOZ,EAPY,CAAf;;AASA,QAAI,CAAClB,OAAO,CAACiB,MAAD,CAAZ,EAAsB;AAClBT,MAAAA,KAAK,CAACQ,GAAN,CAAU,QAAV,EAAoBC,MAApB;AACH;AACJ,GAvCD;AAyCA,SAAOd,QAAP;AACH","sourcesContent":["import { uniq, toArray, isEmpty } from './util.mjs';\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nexport function cloneCells(cells) {\n\n    cells = uniq(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = toArray(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    toArray(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = toArray(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!isEmpty(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n"]},"metadata":{},"sourceType":"module"}