{"ast":null,"code":"import Backbone from 'backbone';\nimport { uniqueId, result, merge, forIn, isObject, isEqual, isString, cloneDeep, omit, uuid, isEmpty, assign, uniq, toArray, defaults, setByPath, unsetByPath, getByPath, timing, interpolate, nextFrame, without, cancelFrame, defaultsDeep, has } from '../util/util.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes.mjs';\nimport * as g from '../g/index.mjs'; // Cell base model.\n// --------------------------\n\nexport const Cell = Backbone.Model.extend({\n  // This is the same as Backbone.Model with the only difference that is uses util.merge\n  // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n  constructor: function (attributes, options) {\n    var defaults;\n    var attrs = attributes || {};\n    this.cid = uniqueId('c');\n    this.attributes = {};\n    if (options && options.collection) this.collection = options.collection;\n    if (options && options.parse) attrs = this.parse(attrs, options) || {};\n\n    if (defaults = result(this, 'defaults')) {\n      //<custom code>\n      // Replaced the call to _.defaults with util.merge.\n      attrs = merge({}, defaults, attrs); //</custom code>\n    }\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  },\n  translate: function (dx, dy, opt) {\n    throw new Error('Must define a translate() method.');\n  },\n  toJSON: function () {\n    var defaultAttrs = this.constructor.prototype.defaults.attrs || {};\n    var attrs = this.attributes.attrs;\n    var finalAttrs = {}; // Loop through all the attributes and\n    // omit the default attributes as they are implicitly reconstructable by the cell 'type'.\n\n    forIn(attrs, function (attr, selector) {\n      var defaultAttr = defaultAttrs[selector];\n      forIn(attr, function (value, name) {\n        // attr is mainly flat though it might have one more level (consider the `style` attribute).\n        // Check if the `value` is object and if yes, go one level deep.\n        if (isObject(value) && !Array.isArray(value)) {\n          forIn(value, function (value2, name2) {\n            if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n              finalAttrs[selector] = finalAttrs[selector] || {};\n              (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n            }\n          });\n        } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n          // `value` is not an object, default attribute for such a selector does not exist\n          // or it is different than the attribute value set on the model.\n          finalAttrs[selector] = finalAttrs[selector] || {};\n          finalAttrs[selector][name] = value;\n        }\n      });\n    });\n    var attributes = cloneDeep(omit(this.attributes, 'attrs'));\n    attributes.attrs = finalAttrs;\n    return attributes;\n  },\n  initialize: function (options) {\n    if (!options || !options.id) {\n      this.set('id', this.generateId(), {\n        silent: true\n      });\n    }\n\n    this._transitionIds = {}; // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n\n    this.processPorts();\n    this.on('change:attrs', this.processPorts, this);\n  },\n  generateId: function () {\n    return uuid();\n  },\n\n  /**\n   * @deprecated\n   */\n  processPorts: function () {\n    // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n    // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n    // set to that port, we remove those links as well (to follow the same behaviour as\n    // with a removed element).\n    var previousPorts = this.ports; // Collect ports from the `attrs` object.\n\n    var ports = {};\n    forIn(this.get('attrs'), function (attrs, selector) {\n      if (attrs && attrs.port) {\n        // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n        if (attrs.port.id !== undefined) {\n          ports[attrs.port.id] = attrs.port;\n        } else {\n          ports[attrs.port] = {\n            id: attrs.port\n          };\n        }\n      }\n    }); // Collect ports that have been removed (compared to the previous ports) - if any.\n    // Use hash table for quick lookup.\n\n    var removedPorts = {};\n    forIn(previousPorts, function (port, id) {\n      if (!ports[id]) removedPorts[id] = true;\n    }); // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n\n    if (this.graph && !isEmpty(removedPorts)) {\n      var inboundLinks = this.graph.getConnectedLinks(this, {\n        inbound: true\n      });\n      inboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('target').port]) link.remove();\n      });\n      var outboundLinks = this.graph.getConnectedLinks(this, {\n        outbound: true\n      });\n      outboundLinks.forEach(function (link) {\n        if (removedPorts[link.get('source').port]) link.remove();\n      });\n    } // Update the `ports` object.\n\n\n    this.ports = ports;\n  },\n  remove: function (opt = {}) {\n    // Store the graph in a variable because `this.graph` won't be accessible\n    // after `this.trigger('remove', ...)` down below.\n    const {\n      graph,\n      collection\n    } = this;\n\n    if (!graph) {\n      // The collection is a common Backbone collection (not the graph collection).\n      if (collection) collection.remove(this, opt);\n      return this;\n    }\n\n    graph.startBatch('remove'); // First, unembed this cell from its parent cell if there is one.\n\n    const parentCell = this.getParentCell();\n\n    if (parentCell) {\n      parentCell.unembed(this, opt);\n    } // Remove also all the cells, which were embedded into this cell\n\n\n    const embeddedCells = this.getEmbeddedCells();\n\n    for (let i = 0, n = embeddedCells.length; i < n; i++) {\n      const embed = embeddedCells[i];\n\n      if (embed) {\n        embed.remove(opt);\n      }\n    }\n\n    this.trigger('remove', this, graph.attributes.cells, opt);\n    graph.stopBatch('remove');\n    return this;\n  },\n  toFront: function (opt) {\n    var graph = this.graph;\n\n    if (graph) {\n      opt = opt || {};\n      var z = graph.maxZIndex();\n      var cells;\n\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      z = z - cells.length + 1;\n      var collection = graph.get('cells');\n      var shouldUpdate = collection.indexOf(this) !== collection.length - cells.length;\n\n      if (!shouldUpdate) {\n        shouldUpdate = cells.some(function (cell, index) {\n          return cell.get('z') !== z + index;\n        });\n      }\n\n      if (shouldUpdate) {\n        this.startBatch('to-front');\n        z = z + cells.length;\n        cells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-front');\n      }\n    }\n\n    return this;\n  },\n  toBack: function (opt) {\n    var graph = this.graph;\n\n    if (graph) {\n      opt = opt || {};\n      var z = graph.minZIndex();\n      var cells;\n\n      if (opt.deep) {\n        cells = this.getEmbeddedCells({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      var collection = graph.get('cells');\n      var shouldUpdate = collection.indexOf(this) !== 0;\n\n      if (!shouldUpdate) {\n        shouldUpdate = cells.some(function (cell, index) {\n          return cell.get('z') !== z + index;\n        });\n      }\n\n      if (shouldUpdate) {\n        this.startBatch('to-back');\n        z -= cells.length;\n        cells.forEach(function (cell, index) {\n          cell.set('z', z + index, opt);\n        });\n        this.stopBatch('to-back');\n      }\n    }\n\n    return this;\n  },\n  parent: function (parent, opt) {\n    // getter\n    if (parent === undefined) return this.get('parent'); // setter\n\n    return this.set('parent', parent, opt);\n  },\n  embed: function (cell, opt) {\n    if (this === cell || this.isEmbeddedIn(cell)) {\n      throw new Error('Recursive embedding not allowed.');\n    } else {\n      this.startBatch('embed');\n      var embeds = assign([], this.get('embeds')); // We keep all element ids after link ids.\n\n      embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n      cell.parent(this.id, opt);\n      this.set('embeds', uniq(embeds), opt);\n      this.stopBatch('embed');\n    }\n\n    return this;\n  },\n  unembed: function (cell, opt) {\n    this.startBatch('unembed');\n    cell.unset('parent', opt);\n    this.set('embeds', without(this.get('embeds'), cell.id), opt);\n    this.stopBatch('unembed');\n    return this;\n  },\n  getParentCell: function () {\n    // unlike link.source/target, cell.parent stores id directly as a string\n    var parentId = this.parent();\n    var graph = this.graph;\n    return parentId && graph && graph.getCell(parentId) || null;\n  },\n  // Return an array of ancestor cells.\n  // The array is ordered from the parent of the cell\n  // to the most distant ancestor.\n  getAncestors: function () {\n    var ancestors = [];\n\n    if (!this.graph) {\n      return ancestors;\n    }\n\n    var parentCell = this.getParentCell();\n\n    while (parentCell) {\n      ancestors.push(parentCell);\n      parentCell = parentCell.getParentCell();\n    }\n\n    return ancestors;\n  },\n  getEmbeddedCells: function (opt) {\n    opt = opt || {}; // Cell models can only be retrieved when this element is part of a collection.\n    // There is no way this element knows about other cells otherwise.\n    // This also means that calling e.g. `translate()` on an element with embeds before\n    // adding it to a graph does not translate its embeds.\n\n    if (this.graph) {\n      var cells;\n\n      if (opt.deep) {\n        if (opt.breadthFirst) {\n          // breadthFirst algorithm\n          cells = [];\n          var queue = this.getEmbeddedCells();\n\n          while (queue.length > 0) {\n            var parent = queue.shift();\n            cells.push(parent);\n            queue.push.apply(queue, parent.getEmbeddedCells());\n          }\n        } else {\n          // depthFirst algorithm\n          cells = this.getEmbeddedCells();\n          cells.forEach(function (cell) {\n            cells.push.apply(cells, cell.getEmbeddedCells(opt));\n          });\n        }\n      } else {\n        cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n      }\n\n      return cells;\n    }\n\n    return [];\n  },\n  isEmbeddedIn: function (cell, opt) {\n    var cellId = isString(cell) ? cell : cell.id;\n    var parentId = this.parent();\n    opt = defaults({\n      deep: true\n    }, opt); // See getEmbeddedCells().\n\n    if (this.graph && opt.deep) {\n      while (parentId) {\n        if (parentId === cellId) {\n          return true;\n        }\n\n        parentId = this.graph.getCell(parentId).parent();\n      }\n\n      return false;\n    } else {\n      // When this cell is not part of a collection check\n      // at least whether it's a direct child of given cell.\n      return parentId === cellId;\n    }\n  },\n  // Whether or not the cell is embedded in any other cell.\n  isEmbedded: function () {\n    return !!this.parent();\n  },\n  // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n  // Shallow cloning simply clones the cell and returns a new cell with different ID.\n  // Deep cloning clones the cell and all its embedded cells recursively.\n  clone: function (opt) {\n    opt = opt || {};\n\n    if (!opt.deep) {\n      // Shallow cloning.\n      var clone = Backbone.Model.prototype.clone.apply(this, arguments); // We don't want the clone to have the same ID as the original.\n\n      clone.set('id', this.generateId()); // A shallow cloned element does not carry over the original embeds.\n\n      clone.unset('embeds'); // And can not be embedded in any cell\n      // as the clone is not part of the graph.\n\n      clone.unset('parent');\n      return clone;\n    } else {\n      // Deep cloning.\n      // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n      return toArray(cloneCells([this].concat(this.getEmbeddedCells({\n        deep: true\n      }))));\n    }\n  },\n  // A convenient way to set nested properties.\n  // This method merges the properties you'd like to set with the ones\n  // stored in the cell and makes sure change events are properly triggered.\n  // You can either set a nested property with one object\n  // or use a property path.\n  // The most simple use case is:\n  // `cell.prop('name/first', 'John')` or\n  // `cell.prop({ name: { first: 'John' } })`.\n  // Nested arrays are supported too:\n  // `cell.prop('series/0/data/0/degree', 50)` or\n  // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n  prop: function (props, value, opt) {\n    var delim = '/';\n\n    var _isString = isString(props);\n\n    if (_isString || Array.isArray(props)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      if (arguments.length > 1) {\n        var path;\n        var pathArray;\n\n        if (_isString) {\n          path = props;\n          pathArray = path.split('/');\n        } else {\n          path = props.join(delim);\n          pathArray = props.slice();\n        }\n\n        var property = pathArray[0];\n        var pathArrayLength = pathArray.length;\n        opt = opt || {};\n        opt.propertyPath = path;\n        opt.propertyValue = value;\n        opt.propertyPathArray = pathArray;\n\n        if (pathArrayLength === 1) {\n          // Property is not nested. We can simply use `set()`.\n          return this.set(property, value, opt);\n        }\n\n        var update = {}; // Initialize the nested object. Subobjects are either arrays or objects.\n        // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n        // Note that this imposes a limitation on object keys one can use with Inspector.\n        // Pure integer keys will cause issues and are therefore not allowed.\n\n        var initializer = update;\n        var prevProperty = property;\n\n        for (var i = 1; i < pathArrayLength; i++) {\n          var pathItem = pathArray[i];\n          var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n          initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n          prevProperty = pathItem;\n        } // Fill update with the `value` on `path`.\n\n\n        update = setByPath(update, pathArray, value, '/');\n        var baseAttributes = merge({}, this.attributes); // if rewrite mode enabled, we replace value referenced by path with\n        // the new one (we don't merge).\n\n        opt.rewrite && unsetByPath(baseAttributes, path, '/'); // Merge update with the model attributes.\n\n        var attributes = merge(baseAttributes, update); // Finally, set the property to the updated attributes.\n\n        return this.set(property, attributes[property], opt);\n      } else {\n        return getByPath(this.attributes, props, delim);\n      }\n    }\n\n    return this.set(merge({}, this.attributes, props), value);\n  },\n  // A convenient way to unset nested properties\n  removeProp: function (path, opt) {\n    opt = opt || {};\n    var pathArray = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` attribute\n    // the cellView will recognize a `dirty` flag and re-render itself\n    // in order to remove the attribute from SVG element.\n\n    var property = pathArray[0];\n    if (property === 'attrs') opt.dirty = true;\n\n    if (pathArray.length === 1) {\n      // A top level property\n      return this.unset(path, opt);\n    } // A nested property\n\n\n    var nestedPath = pathArray.slice(1);\n    var propertyValue = cloneDeep(this.get(property));\n    unsetByPath(propertyValue, nestedPath, '/');\n    return this.set(property, propertyValue, opt);\n  },\n  // A convenient way to set nested attributes.\n  attr: function (attrs, value, opt) {\n    var args = Array.from(arguments);\n\n    if (args.length === 0) {\n      return this.get('attrs');\n    }\n\n    if (Array.isArray(attrs)) {\n      args[0] = ['attrs'].concat(attrs);\n    } else if (isString(attrs)) {\n      // Get/set an attribute by a special path syntax that delimits\n      // nested objects by the colon character.\n      args[0] = 'attrs/' + attrs;\n    } else {\n      args[0] = {\n        'attrs': attrs\n      };\n    }\n\n    return this.prop.apply(this, args);\n  },\n  // A convenient way to unset nested attributes\n  removeAttr: function (path, opt) {\n    if (Array.isArray(path)) {\n      return this.removeProp(['attrs'].concat(path));\n    }\n\n    return this.removeProp('attrs/' + path, opt);\n  },\n  transition: function (path, value, opt, delim) {\n    delim = delim || '/';\n    var defaults = {\n      duration: 100,\n      delay: 10,\n      timingFunction: timing.linear,\n      valueFunction: interpolate.number\n    };\n    opt = assign(defaults, opt);\n    var firstFrameTime = 0;\n    var interpolatingFunction;\n\n    var setter = function (runtime) {\n      var id, progress, propertyValue;\n      firstFrameTime = firstFrameTime || runtime;\n      runtime -= firstFrameTime;\n      progress = runtime / opt.duration;\n\n      if (progress < 1) {\n        this._transitionIds[path] = id = nextFrame(setter);\n      } else {\n        progress = 1;\n        delete this._transitionIds[path];\n      }\n\n      propertyValue = interpolatingFunction(opt.timingFunction(progress));\n      opt.transitionId = id;\n      this.prop(path, propertyValue, opt);\n      if (!id) this.trigger('transition:end', this, path);\n    }.bind(this);\n\n    var initiator = function (callback) {\n      this.stopTransitions(path);\n      interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n      this._transitionIds[path] = nextFrame(callback);\n      this.trigger('transition:start', this, path);\n    }.bind(this);\n\n    return setTimeout(initiator, opt.delay, setter);\n  },\n  getTransitions: function () {\n    return Object.keys(this._transitionIds);\n  },\n  stopTransitions: function (path, delim) {\n    delim = delim || '/';\n    var pathArray = path && path.split(delim);\n    Object.keys(this._transitionIds).filter(pathArray && function (key) {\n      return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n    }).forEach(function (key) {\n      cancelFrame(this._transitionIds[key]);\n      delete this._transitionIds[key];\n      this.trigger('transition:end', this, key);\n    }, this);\n    return this;\n  },\n  // A shorcut making it easy to create constructs like the following:\n  // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n  addTo: function (graph, opt) {\n    graph.addCell(this, opt);\n    return this;\n  },\n  // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n  // making it easy to create constructs like the following:\n  // `cell.findView(paper).highlight()`\n  findView: function (paper) {\n    return paper.findViewByModel(this);\n  },\n  isElement: function () {\n    return false;\n  },\n  isLink: function () {\n    return false;\n  },\n  startBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.startBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n\n    return this;\n  },\n  stopBatch: function (name, opt) {\n    if (this.graph) {\n      this.graph.stopBatch(name, assign({}, opt, {\n        cell: this\n      }));\n    }\n\n    return this;\n  },\n  getChangeFlag: function (attributes) {\n    var flag = 0;\n    if (!attributes) return flag;\n\n    for (var key in attributes) {\n      if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n      flag |= attributes[key];\n    }\n\n    return flag;\n  },\n  angle: function () {\n    // To be overridden.\n    return 0;\n  },\n  position: function () {\n    // To be overridden.\n    return new g.Point(0, 0);\n  },\n  getPointFromConnectedLink: function () {\n    // To be overridden\n    return new g.Point();\n  },\n  getBBox: function () {\n    // To be overridden\n    return new g.Rect(0, 0, 0, 0);\n  }\n}, {\n  getAttributeDefinition: function (attrName) {\n    var defNS = this.attributes;\n    var globalDefNS = attributes;\n    return defNS && defNS[attrName] || globalDefNS[attrName];\n  },\n  define: function (type, defaults, protoProps, staticProps) {\n    protoProps = assign({\n      defaults: defaultsDeep({\n        type: type\n      }, defaults, this.prototype.defaults)\n    }, protoProps);\n    var Cell = this.extend(protoProps, staticProps); // es5 backward compatibility\n\n    /* global joint: true */\n\n    if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n      setByPath(joint.shapes, type, Cell, '.');\n    }\n    /* global joint: false */\n\n\n    return Cell;\n  }\n});","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/dia/Cell.mjs"],"names":["Backbone","uniqueId","result","merge","forIn","isObject","isEqual","isString","cloneDeep","omit","uuid","isEmpty","assign","uniq","toArray","defaults","setByPath","unsetByPath","getByPath","timing","interpolate","nextFrame","without","cancelFrame","defaultsDeep","has","cloneCells","attributes","g","Cell","Model","extend","constructor","options","attrs","cid","collection","parse","set","changed","initialize","apply","arguments","translate","dx","dy","opt","Error","toJSON","defaultAttrs","prototype","finalAttrs","attr","selector","defaultAttr","value","name","Array","isArray","value2","name2","id","generateId","silent","_transitionIds","processPorts","on","previousPorts","ports","get","port","undefined","removedPorts","graph","inboundLinks","getConnectedLinks","inbound","forEach","link","remove","outboundLinks","outbound","startBatch","parentCell","getParentCell","unembed","embeddedCells","getEmbeddedCells","i","n","length","embed","trigger","cells","stopBatch","toFront","z","maxZIndex","deep","breadthFirst","unshift","shouldUpdate","indexOf","some","cell","index","toBack","minZIndex","parent","isEmbeddedIn","embeds","isLink","unset","parentId","getCell","getAncestors","ancestors","push","queue","shift","map","cellId","isEmbedded","clone","concat","prop","props","delim","_isString","path","pathArray","split","join","slice","property","pathArrayLength","propertyPath","propertyValue","propertyPathArray","update","initializer","prevProperty","pathItem","isArrayIndex","Number","isFinite","baseAttributes","rewrite","removeProp","dirty","nestedPath","args","from","removeAttr","transition","duration","delay","timingFunction","linear","valueFunction","number","firstFrameTime","interpolatingFunction","setter","runtime","progress","transitionId","bind","initiator","callback","stopTransitions","setTimeout","getTransitions","Object","keys","filter","key","addTo","addCell","findView","paper","findViewByModel","isElement","getChangeFlag","flag","hasOwnProperty","hasChanged","angle","position","Point","getPointFromConnectedLink","getBBox","Rect","getAttributeDefinition","attrName","defNS","globalDefNS","define","type","protoProps","staticProps","joint","shapes"],"mappings":"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","sourcesContent":["import Backbone from 'backbone';\nimport {\n    uniqueId,\n    result,\n    merge,\n    forIn,\n    isObject,\n    isEqual,\n    isString,\n    cloneDeep,\n    omit,\n    uuid,\n    isEmpty,\n    assign,\n    uniq,\n    toArray,\n    defaults,\n    setByPath,\n    unsetByPath,\n    getByPath,\n    timing,\n    interpolate,\n    nextFrame,\n    without,\n    cancelFrame,\n    defaultsDeep,\n    has\n} from '../util/util.mjs';\nimport { cloneCells } from '../util/cloneCells.mjs';\nimport { attributes } from './attributes.mjs';\nimport * as g from '../g/index.mjs';\n\n\n// Cell base model.\n// --------------------------\n\nexport const Cell = Backbone.Model.extend({\n\n    // This is the same as Backbone.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        this.cid = uniqueId('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = result(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            attrs = merge({}, defaults, attrs);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function() {\n\n        var defaultAttrs = this.constructor.prototype.defaults.attrs || {};\n        var attrs = this.attributes.attrs;\n        var finalAttrs = {};\n\n        // Loop through all the attributes and\n        // omit the default attributes as they are implicitly reconstructable by the cell 'type'.\n        forIn(attrs, function(attr, selector) {\n\n            var defaultAttr = defaultAttrs[selector];\n\n            forIn(attr, function(value, name) {\n\n                // attr is mainly flat though it might have one more level (consider the `style` attribute).\n                // Check if the `value` is object and if yes, go one level deep.\n                if (isObject(value) && !Array.isArray(value)) {\n\n                    forIn(value, function(value2, name2) {\n\n                        if (!defaultAttr || !defaultAttr[name] || !isEqual(defaultAttr[name][name2], value2)) {\n\n                            finalAttrs[selector] = finalAttrs[selector] || {};\n                            (finalAttrs[selector][name] || (finalAttrs[selector][name] = {}))[name2] = value2;\n                        }\n                    });\n\n                } else if (!defaultAttr || !isEqual(defaultAttr[name], value)) {\n                    // `value` is not an object, default attribute for such a selector does not exist\n                    // or it is different than the attribute value set on the model.\n\n                    finalAttrs[selector] = finalAttrs[selector] || {};\n                    finalAttrs[selector][name] = value;\n                }\n            });\n        });\n\n        var attributes = cloneDeep(omit(this.attributes, 'attrs'));\n        attributes.attrs = finalAttrs;\n\n        return attributes;\n    },\n\n    initialize: function(options) {\n\n        if (!options || !options.id) {\n\n            this.set('id', this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    generateId: function() {\n        return uuid();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        forIn(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        forIn(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !isEmpty(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common Backbone collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n\n        var graph = this.graph;\n        if (graph) {\n\n            opt = opt || {};\n\n            var z = graph.maxZIndex();\n\n            var cells;\n\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            z = z - cells.length + 1;\n\n            var collection = graph.get('cells');\n            var shouldUpdate = (collection.indexOf(this) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = cells.some(function(cell, index) {\n                    return cell.get('z') !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                cells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n\n        var graph = this.graph;\n        if (graph) {\n\n            opt = opt || {};\n\n            var z = graph.minZIndex();\n\n            var cells;\n\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            var collection = graph.get('cells');\n            var shouldUpdate = (collection.indexOf(this) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = cells.some(function(cell, index) {\n                    return cell.get('z') !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                cells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt) {\n\n        if (this === cell || this.isEmbeddedIn(cell)) {\n\n            throw new Error('Recursive embedding not allowed.');\n\n        } else {\n\n            this.startBatch('embed');\n\n            var embeds = assign([], this.get('embeds'));\n\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n\n            cell.parent(this.id, opt);\n            this.set('embeds', uniq(embeds), opt);\n\n            this.stopBatch('embed');\n        }\n\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n\n        this.startBatch('unembed');\n\n        cell.unset('parent', opt);\n        this.set('embeds', without(this.get('embeds'), cell.id), opt);\n\n        this.stopBatch('unembed');\n\n        return this;\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (this.graph) {\n\n            var cells;\n\n            if (opt.deep) {\n\n                if (opt.breadthFirst) {\n\n                    // breadthFirst algorithm\n                    cells = [];\n                    var queue = this.getEmbeddedCells();\n\n                    while (queue.length > 0) {\n\n                        var parent = queue.shift();\n                        cells.push(parent);\n                        queue.push.apply(queue, parent.getEmbeddedCells());\n                    }\n\n                } else {\n\n                    // depthFirst algorithm\n                    cells = this.getEmbeddedCells();\n                    cells.forEach(function(cell) {\n                        cells.push.apply(cells, cell.getEmbeddedCells(opt));\n                    });\n                }\n\n            } else {\n\n                cells = toArray(this.get('embeds')).map(this.graph.getCell, this.graph);\n            }\n\n            return cells;\n        }\n        return [];\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = isString(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = defaults({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = Backbone.Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set('id', this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return toArray(cloneCells([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = isString(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                opt = opt || {};\n                opt.propertyPath = path;\n                opt.propertyValue = value;\n                opt.propertyPathArray = pathArray;\n\n                if (pathArrayLength === 1) {\n                    // Property is not nested. We can simply use `set()`.\n                    return this.set(property, value, opt);\n                }\n\n                var update = {};\n                // Initialize the nested object. Subobjects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = setByPath(update, pathArray, value, '/');\n\n                var baseAttributes = merge({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                opt.rewrite && unsetByPath(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = merge(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], opt);\n\n            } else {\n\n                return getByPath(this.attributes, props, delim);\n            }\n        }\n\n        return this.set(merge({}, this.attributes, props), value);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = cloneDeep(this.get(property));\n\n        unsetByPath(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if (isString(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: timing.linear,\n            valueFunction: interpolate.number\n        };\n\n        opt = assign(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = nextFrame(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        var initiator = function(callback) {\n\n            this.stopTransitions(path);\n\n            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = nextFrame(callback);\n\n            this.trigger('transition:start', this, path);\n\n        }.bind(this);\n\n        return setTimeout(initiator, opt.delay, setter);\n    },\n\n    getTransitions: function() {\n\n        return Object.keys(this._transitionIds);\n    },\n\n    stopTransitions: function(path, delim) {\n\n        delim = delim || '/';\n\n        var pathArray = path && path.split(delim);\n\n        Object.keys(this._transitionIds).filter(pathArray && function(key) {\n\n            return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));\n\n        }).forEach(function(key) {\n\n            cancelFrame(this._transitionIds[key]);\n\n            delete this._transitionIds[key];\n\n            this.trigger('transition:end', this, key);\n\n        }, this);\n\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.basic.Rect).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, assign({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new g.Point(0, 0);\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new g.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new g.Rect(0, 0, 0, 0);\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = assign({\n            defaults: defaultsDeep({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* global joint: true */\n        if (typeof joint !== 'undefined' && has(joint, 'shapes')) {\n            setByPath(joint.shapes, type, Cell, '.');\n        }\n        /* global joint: false */\n        return Cell;\n    }\n});\n\n"]},"metadata":{},"sourceType":"module"}