{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n  if (util.isPlainObject(offset)) {\n    const {\n      x,\n      y\n    } = offset;\n\n    if (isFinite(y)) {\n      const line = new g.Line(p2, p1);\n      const {\n        start,\n        end\n      } = line.parallel(y);\n      p2 = start;\n      p1 = end;\n    }\n\n    offset = x;\n  }\n\n  if (!isFinite(offset)) return p1;\n  var length = p1.distance(p2);\n  if (offset === 0 && length > 0) return p1;\n  return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n  var stroke = magnet.getAttribute('stroke-width');\n  if (stroke === null) return 0;\n  return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n  let coordinate, a, b, direction;\n  const {\n    start,\n    end\n  } = line;\n\n  switch (type) {\n    case 'left':\n      coordinate = 'x';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n\n    case 'right':\n      coordinate = 'x';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n\n    case 'top':\n      coordinate = 'y';\n      a = end;\n      b = start;\n      direction = -1;\n      break;\n\n    case 'bottom':\n      coordinate = 'y';\n      a = start;\n      b = end;\n      direction = 1;\n      break;\n\n    default:\n      return;\n  }\n\n  if (start[coordinate] < end[coordinate]) {\n    a[coordinate] = b[coordinate];\n  } else {\n    b[coordinate] = a[coordinate];\n  }\n\n  if (isFinite(offset)) {\n    a[coordinate] += direction * offset;\n    b[coordinate] += direction * offset;\n  }\n} // Connection Points\n\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n  let {\n    offset,\n    alignOffset,\n    align\n  } = opt;\n  if (align) alignLine(line, align, alignOffset);\n  return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n  var bbox = view.getNodeBBox(magnet);\n  if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n  var intersections = line.intersect(bbox);\n  var cp = intersections ? line.start.chooseClosest(intersections) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n  var angle = view.model.angle();\n\n  if (angle === 0) {\n    return bboxIntersection(line, view, magnet, opt);\n  }\n\n  var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n  if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n  var center = bboxWORotation.center();\n  var lineWORotation = line.clone().rotate(center, angle);\n  var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n  var cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle) : line.end;\n  return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n  if (!magnet) return null;\n  var node = magnet;\n\n  do {\n    var tagName = node.tagName;\n    if (typeof tagName !== 'string') return null;\n    tagName = tagName.toUpperCase();\n\n    if (tagName === 'G') {\n      node = node.firstElementChild;\n    } else if (tagName === 'TITLE') {\n      node = node.nextElementSibling;\n    } else break;\n  } while (node);\n\n  return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n  var node, intersection;\n  var selector = opt.selector;\n  var anchor = line.end;\n\n  if (typeof selector === 'string') {\n    node = view.findBySelector(selector)[0];\n  } else if (Array.isArray(selector)) {\n    node = util.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n\n  if (!V.isSVGGraphicsElement(node)) {\n    if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n    node = magnet;\n  }\n\n  var localShape = view.getNodeShape(node);\n  var magnetMatrix = view.getNodeMatrix(node);\n  var translateMatrix = view.getRootTranslateMatrix();\n  var rotateMatrix = view.getRootRotateMatrix();\n  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  var localMatrix = targetMatrix.inverse();\n  var localLine = V.transformLine(line, localMatrix);\n  var localRef = localLine.start.clone();\n  var data = view.getNodeData(node);\n\n  if (opt.insideout === false) {\n    if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n    var localBBox = data[BNDR_SHAPE_BBOX];\n    if (localBBox.containsPoint(localRef)) return anchor;\n  } // Caching segment subdivisions for paths\n\n\n  var pathOpt;\n\n  if (localShape instanceof g.Path) {\n    var precision = opt.precision || 2;\n    if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({\n      precision: precision\n    });\n    pathOpt = {\n      precision: precision,\n      segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n    };\n  }\n\n  if (opt.extrapolate === true) localLine.setLength(1e6);\n  intersection = localLine.intersect(localShape, pathOpt);\n\n  if (intersection) {\n    // More than one intersection\n    if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n  } else if (opt.sticky === true) {\n    // No intersection, find the closest point instead\n    if (localShape instanceof g.Rect) {\n      intersection = localShape.pointNearestToPoint(localRef);\n    } else if (localShape instanceof g.Ellipse) {\n      intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOpt);\n    }\n  }\n\n  var cp = intersection ? V.transformPoint(intersection, targetMatrix) : anchor;\n  var cpOffset = opt.offset || 0;\n  if (opt.stroke) cpOffset += stroke(node) / 2;\n  return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/connectionPoints/index.mjs"],"names":["g","V","util","offsetPoint","p1","p2","offset","isPlainObject","x","y","isFinite","line","Line","start","end","parallel","length","distance","move","Math","min","stroke","magnet","getAttribute","parseFloat","alignLine","type","coordinate","a","b","direction","anchorConnectionPoint","_view","_magnet","opt","alignOffset","align","bboxIntersection","view","bbox","getNodeBBox","inflate","intersections","intersect","cp","chooseClosest","rectangleIntersection","angle","model","bboxWORotation","getNodeUnrotatedBBox","center","lineWORotation","clone","rotate","setLength","findShapeNode","node","tagName","toUpperCase","firstElementChild","nextElementSibling","BNDR_SUBDIVISIONS","BNDR_SHAPE_BBOX","boundaryIntersection","intersection","selector","anchor","findBySelector","Array","isArray","getByPath","isSVGGraphicsElement","localShape","getNodeShape","magnetMatrix","getNodeMatrix","translateMatrix","getRootTranslateMatrix","rotateMatrix","getRootRotateMatrix","targetMatrix","multiply","localMatrix","inverse","localLine","transformLine","localRef","data","getNodeData","insideout","localBBox","containsPoint","pathOpt","Path","precision","getSegmentSubdivisions","segmentSubdivisions","extrapolate","sticky","Rect","pointNearestToPoint","Ellipse","intersectionWithLineFromCenterToPoint","closestPoint","transformPoint","cpOffset","rectangle","boundary"],"mappings":"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","sourcesContent":["import * as g from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport * as util from '../util/index.mjs';\n\nfunction offsetPoint(p1, p2, offset) {\n    if (util.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new g.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findBySelector(selector)[0];\n    } else if (Array.isArray(selector)) {\n        node = util.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!V.isSVGGraphicsElement(node)) {\n        if (node === magnet || !V.isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = V.transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof g.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (V.isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof g.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof g.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? V.transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nexport const anchor = anchorConnectionPoint;\nexport const bbox = bboxIntersection;\nexport const rectangle = rectangleIntersection;\nexport const boundary = boundaryIntersection;\n"]},"metadata":{},"sourceType":"module"}