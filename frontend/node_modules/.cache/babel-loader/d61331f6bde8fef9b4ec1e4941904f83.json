{"ast":null,"code":"import { Point, Path, Polyline } from '../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../util/util.mjs';\nimport $ from 'jquery';\nimport V from '../V/index.mjs';\n\nfunction setWrapper(attrName, dimension) {\n  return function (value, refBBox) {\n    var isValuePercentage = isPercentage(value);\n    value = parseFloat(value);\n\n    if (isValuePercentage) {\n      value /= 100;\n    }\n\n    var attrs = {};\n\n    if (isFinite(value)) {\n      var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n\n    return attrs;\n  };\n}\n\nfunction positionWrapper(axis, dimension, origin) {\n  return function (value, refBBox) {\n    var valuePercentage = isPercentage(value);\n    value = parseFloat(value);\n\n    if (valuePercentage) {\n      value /= 100;\n    }\n\n    var delta;\n\n    if (isFinite(value)) {\n      var refOrigin = refBBox[origin]();\n\n      if (valuePercentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n\n    var point = Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\n\nfunction offsetWrapper(axis, dimension, corner) {\n  return function (value, nodeBBox) {\n    var delta;\n\n    if (value === 'middle') {\n      delta = nodeBBox[dimension] / 2;\n    } else if (value === corner) {\n      delta = nodeBBox[dimension];\n    } else if (isFinite(value)) {\n      // TODO: or not to do a breaking change?\n      delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;\n    } else if (isPercentage(value)) {\n      delta = nodeBBox[dimension] * parseFloat(value) / 100;\n    } else {\n      delta = 0;\n    }\n\n    var point = Point();\n    point[axis] = -(nodeBBox[axis] + delta);\n    return point;\n  };\n}\n\nfunction shapeWrapper(shapeConstructor, opt) {\n  var cacheName = 'joint-shape';\n  var resetOffset = opt && opt.resetOffset;\n  return function (value, refBBox, node) {\n    var $node = $(node);\n    var cache = $node.data(cacheName);\n\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      var cachedShape = shapeConstructor(value);\n      cache = {\n        value: value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $node.data(cacheName, cache);\n    }\n\n    var shape = cache.shape.clone();\n    var shapeBBox = cache.shapeBBox.clone();\n    var shapeOrigin = shapeBBox.origin();\n    var refOrigin = refBBox.origin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0\n\n    var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n\n    return shape;\n  };\n} // `d` attribute for SVGPaths\n\n\nfunction dWrapper(opt) {\n  function pathConstructor(value) {\n    return new Path(V.normalizePathData(value));\n  }\n\n  var shape = shapeWrapper(pathConstructor, opt);\n  return function (value, refBBox, node) {\n    var path = shape(value, refBBox, node);\n    return {\n      d: path.serialize()\n    };\n  };\n} // `points` attribute for SVGPolylines and SVGPolygons\n\n\nfunction pointsWrapper(opt) {\n  var shape = shapeWrapper(Polyline, opt);\n  return function (value, refBBox, node) {\n    var polyline = shape(value, refBBox, node);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}\n\nfunction atConnectionWrapper(method, opt) {\n  var zeroVector = new Point(1, 0);\n  return function (value) {\n    var p, angle;\n    var tangent = this[method](value);\n\n    if (tangent) {\n      angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = this.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) return {\n      transform: 'translate(' + p.x + ',' + p.y + ')'\n    };\n    return {\n      transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')'\n    };\n  };\n}\n\nfunction isTextInUse(_value, _node, attrs) {\n  return attrs.text !== undefined;\n}\n\nfunction isLinkView() {\n  return this.model.isLink();\n}\n\nfunction contextMarker(context) {\n  var marker = {}; // Stroke\n  // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n  // (for which 'fill' attribute is set to 'none').\n\n  var stroke = context.stroke;\n\n  if (typeof stroke === 'string') {\n    marker['stroke'] = stroke;\n    marker['fill'] = stroke;\n  } // Opacity\n  // Again the context 'fill-opacity' is ignored.\n\n\n  var strokeOpacity = context.strokeOpacity;\n  if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n  if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n\n  if (strokeOpacity !== undefined) {\n    marker['stroke-opacity'] = strokeOpacity;\n    marker['fill-opacity'] = strokeOpacity;\n  }\n\n  return marker;\n}\n\nconst attributesNS = {\n  xlinkHref: {\n    set: 'xlink:href'\n  },\n  xlinkShow: {\n    set: 'xlink:show'\n  },\n  xlinkRole: {\n    set: 'xlink:role'\n  },\n  xlinkType: {\n    set: 'xlink:type'\n  },\n  xlinkArcrole: {\n    set: 'xlink:arcrole'\n  },\n  xlinkTitle: {\n    set: 'xlink:title'\n  },\n  xlinkActuate: {\n    set: 'xlink:actuate'\n  },\n  xmlSpace: {\n    set: 'xml:space'\n  },\n  xmlBase: {\n    set: 'xml:base'\n  },\n  xmlLang: {\n    set: 'xml:lang'\n  },\n  preserveAspectRatio: {\n    set: 'preserveAspectRatio'\n  },\n  requiredExtension: {\n    set: 'requiredExtension'\n  },\n  requiredFeatures: {\n    set: 'requiredFeatures'\n  },\n  systemLanguage: {\n    set: 'systemLanguage'\n  },\n  externalResourcesRequired: {\n    set: 'externalResourceRequired'\n  },\n  filter: {\n    qualify: isPlainObject,\n    set: function (filter) {\n      return 'url(#' + this.paper.defineFilter(filter) + ')';\n    }\n  },\n  fill: {\n    qualify: isPlainObject,\n    set: function (fill) {\n      return 'url(#' + this.paper.defineGradient(fill) + ')';\n    }\n  },\n  stroke: {\n    qualify: isPlainObject,\n    set: function (stroke) {\n      return 'url(#' + this.paper.defineGradient(stroke) + ')';\n    }\n  },\n  sourceMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  targetMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), {\n        'transform': 'rotate(180)'\n      }, marker);\n      return {\n        'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  vertexMarker: {\n    qualify: isPlainObject,\n    set: function (marker, refBBox, node, attrs) {\n      marker = assign(contextMarker(attrs), marker);\n      return {\n        'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')'\n      };\n    }\n  },\n  text: {\n    qualify: function (_text, _node, attrs) {\n      return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n    },\n    set: function (text, _refBBox, node, attrs) {\n      var $node = $(node);\n      var cacheName = 'joint-text';\n      var cache = $node.data(cacheName);\n      var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n      var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\n      var textHash = JSON.stringify([text, textAttrs]); // Update the text only if there was a change in the string\n      // or any of its attributes.\n\n      if (cache === undefined || cache !== textHash) {\n        // Chrome bug:\n        // Tspans positions defined as `em` are not updated\n        // when container `font-size` change.\n        if (fontSize) node.setAttribute('font-size', fontSize); // Text Along Path Selector\n\n        var textPath = textAttrs.textPath;\n\n        if (isObject(textPath)) {\n          var pathSelector = textPath.selector;\n\n          if (typeof pathSelector === 'string') {\n            var pathNode = this.findBySelector(pathSelector)[0];\n\n            if (pathNode instanceof SVGPathElement) {\n              textAttrs.textPath = assign({\n                'xlink:href': '#' + pathNode.id\n              }, textPath);\n            }\n          }\n        }\n\n        V(node).text('' + text, textAttrs);\n        $node.data(cacheName, textHash);\n      }\n    }\n  },\n  textWrap: {\n    qualify: isPlainObject,\n    set: function (value, refBBox, node, attrs) {\n      // option `width`\n      var width = value.width || 0;\n\n      if (isPercentage(width)) {\n        refBBox.width *= parseFloat(width) / 100;\n      } else if (width <= 0) {\n        refBBox.width += width;\n      } else {\n        refBBox.width = width;\n      } // option `height`\n\n\n      var height = value.height || 0;\n\n      if (isPercentage(height)) {\n        refBBox.height *= parseFloat(height) / 100;\n      } else if (height <= 0) {\n        refBBox.height += height;\n      } else {\n        refBBox.height = height;\n      } // option `text`\n\n\n      var wrappedText;\n      var text = value.text;\n      if (text === undefined) text = attrs.text;\n\n      if (text !== undefined) {\n        wrappedText = breakText('' + text, refBBox, {\n          'font-weight': attrs['font-weight'] || attrs.fontWeight,\n          'font-size': attrs['font-size'] || attrs.fontSize,\n          'font-family': attrs['font-family'] || attrs.fontFamily,\n          'lineHeight': attrs.lineHeight,\n          'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n        }, {\n          // Provide an existing SVG Document here\n          // instead of creating a temporary one over again.\n          svgDocument: this.paper.svg,\n          ellipsis: value.ellipsis,\n          hyphen: value.hyphen,\n          maxLineCount: value.maxLineCount\n        });\n      } else {\n        wrappedText = '';\n      }\n\n      attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n    }\n  },\n  title: {\n    qualify: function (title, node) {\n      // HTMLElement title is specified via an attribute (i.e. not an element)\n      return node instanceof SVGElement;\n    },\n    set: function (title, refBBox, node) {\n      var $node = $(node);\n      var cacheName = 'joint-title';\n      var cache = $node.data(cacheName);\n\n      if (cache === undefined || cache !== title) {\n        $node.data(cacheName, title); // Generally <title> element should be the first child element of its parent.\n\n        var firstChild = node.firstChild;\n\n        if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n          // Update an existing title\n          firstChild.textContent = title;\n        } else {\n          // Create a new title\n          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n          titleNode.textContent = title;\n          node.insertBefore(titleNode, firstChild);\n        }\n      }\n    }\n  },\n  lineHeight: {\n    qualify: isTextInUse\n  },\n  textVerticalAnchor: {\n    qualify: isTextInUse\n  },\n  textPath: {\n    qualify: isTextInUse\n  },\n  annotations: {\n    qualify: isTextInUse\n  },\n  eol: {\n    qualify: isTextInUse\n  },\n  displayEmpty: {\n    qualify: isTextInUse\n  },\n  // `port` attribute contains the `id` of the port that the underlying magnet represents.\n  port: {\n    set: function (port) {\n      return port === null || port.id === undefined ? port : port.id;\n    }\n  },\n  // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n  style: {\n    qualify: isPlainObject,\n    set: function (styles, refBBox, node) {\n      $(node).css(styles);\n    }\n  },\n  html: {\n    set: function (html, refBBox, node) {\n      $(node).html(html + '');\n    }\n  },\n  ref: {// We do not set `ref` attribute directly on an element.\n    // The attribute itself does not qualify for relative positioning.\n  },\n  // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n  // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n  // otherwise, `refX` is the left coordinate of the bounding box\n  refX: {\n    position: positionWrapper('x', 'width', 'origin')\n  },\n  refY: {\n    position: positionWrapper('y', 'height', 'origin')\n  },\n  // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n  // coordinate of the reference element.\n  refDx: {\n    position: positionWrapper('x', 'width', 'corner')\n  },\n  refDy: {\n    position: positionWrapper('y', 'height', 'corner')\n  },\n  // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n  // the reference element size\n  // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n  // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n  refWidth: {\n    set: setWrapper('width', 'width')\n  },\n  refHeight: {\n    set: setWrapper('height', 'height')\n  },\n  refRx: {\n    set: setWrapper('rx', 'width')\n  },\n  refRy: {\n    set: setWrapper('ry', 'height')\n  },\n  refRInscribed: {\n    set: function (attrName) {\n      var widthFn = setWrapper(attrName, 'width');\n      var heightFn = setWrapper(attrName, 'height');\n      return function (value, refBBox) {\n        var fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n        return fn(value, refBBox);\n      };\n    }('r')\n  },\n  refRCircumscribed: {\n    set: function (value, refBBox) {\n      var isValuePercentage = isPercentage(value);\n      value = parseFloat(value);\n\n      if (isValuePercentage) {\n        value /= 100;\n      }\n\n      var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n      var rValue;\n\n      if (isFinite(value)) {\n        if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;else rValue = Math.max(value + diagonalLength, 0);\n      }\n\n      return {\n        r: rValue\n      };\n    }\n  },\n  refCx: {\n    set: setWrapper('cx', 'width')\n  },\n  refCy: {\n    set: setWrapper('cy', 'height')\n  },\n  // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n  // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n  xAlignment: {\n    offset: offsetWrapper('x', 'width', 'right')\n  },\n  // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n  // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n  yAlignment: {\n    offset: offsetWrapper('y', 'height', 'bottom')\n  },\n  resetOffset: {\n    offset: function (val, nodeBBox) {\n      return val ? {\n        x: -nodeBBox.x,\n        y: -nodeBBox.y\n      } : {\n        x: 0,\n        y: 0\n      };\n    }\n  },\n  refDResetOffset: {\n    set: dWrapper({\n      resetOffset: true\n    })\n  },\n  refDKeepOffset: {\n    set: dWrapper({\n      resetOffset: false\n    })\n  },\n  refPointsResetOffset: {\n    set: pointsWrapper({\n      resetOffset: true\n    })\n  },\n  refPointsKeepOffset: {\n    set: pointsWrapper({\n      resetOffset: false\n    })\n  },\n  // LinkView Attributes\n  connection: {\n    qualify: isLinkView,\n    set: function ({\n      stubs = 0\n    }) {\n      let d;\n\n      if (isFinite(stubs) && stubs !== 0) {\n        let offset;\n\n        if (stubs < 0) {\n          offset = (this.getConnectionLength() + stubs) / 2;\n        } else {\n          offset = stubs;\n        }\n\n        const path = this.getConnection();\n        const sourceParts = path.divideAtLength(offset);\n        const targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n\n      return {\n        d: d || this.getSerializedConnection()\n      };\n    }\n  },\n  atConnectionLengthKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: true\n    })\n  },\n  atConnectionLengthIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtLength', {\n      rotate: false\n    })\n  },\n  atConnectionRatioKeepGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: true\n    })\n  },\n  atConnectionRatioIgnoreGradient: {\n    qualify: isLinkView,\n    set: atConnectionWrapper('getTangentAtRatio', {\n      rotate: false\n    })\n  }\n}; // Aliases\n\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient; // This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\n\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight; // Aliases for backwards compatibility\n\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\nexport const attributes = attributesNS;","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/dia/attributes.mjs"],"names":["Point","Path","Polyline","assign","isPlainObject","pick","isObject","isPercentage","breakText","$","V","setWrapper","attrName","dimension","value","refBBox","isValuePercentage","parseFloat","attrs","isFinite","attrValue","Math","max","positionWrapper","axis","origin","valuePercentage","delta","refOrigin","point","offsetWrapper","corner","nodeBBox","shapeWrapper","shapeConstructor","opt","cacheName","resetOffset","node","$node","cache","data","cachedShape","shape","shapeBBox","bbox","clone","shapeOrigin","x","y","fitScale","maxRectScaleToFit","sx","width","sy","height","scale","translate","dWrapper","pathConstructor","normalizePathData","path","d","serialize","pointsWrapper","polyline","points","atConnectionWrapper","method","zeroVector","p","angle","tangent","rotate","vector","vectorAngle","start","transform","isTextInUse","_value","_node","text","undefined","isLinkView","model","isLink","contextMarker","context","marker","stroke","strokeOpacity","opacity","attributesNS","xlinkHref","set","xlinkShow","xlinkRole","xlinkType","xlinkArcrole","xlinkTitle","xlinkActuate","xmlSpace","xmlBase","xmlLang","preserveAspectRatio","requiredExtension","requiredFeatures","systemLanguage","externalResourcesRequired","filter","qualify","paper","defineFilter","fill","defineGradient","sourceMarker","defineMarker","targetMarker","vertexMarker","_text","textWrap","_refBBox","textAttrs","fontSize","textHash","JSON","stringify","setAttribute","textPath","pathSelector","selector","pathNode","findBySelector","SVGPathElement","id","wrappedText","fontWeight","fontFamily","lineHeight","letterSpacing","svgDocument","svg","ellipsis","hyphen","maxLineCount","call","title","SVGElement","firstChild","tagName","toUpperCase","textContent","titleNode","document","createElementNS","namespaceURI","insertBefore","textVerticalAnchor","annotations","eol","displayEmpty","port","style","styles","css","html","ref","refX","position","refY","refDx","refDy","refWidth","refHeight","refRx","refRy","refRInscribed","widthFn","heightFn","fn","refRCircumscribed","diagonalLength","sqrt","rValue","r","refCx","refCy","xAlignment","offset","yAlignment","val","refDResetOffset","refDKeepOffset","refPointsResetOffset","refPointsKeepOffset","connection","stubs","getConnectionLength","getConnection","sourceParts","divideAtLength","targetParts","getSerializedConnection","atConnectionLengthKeepGradient","atConnectionLengthIgnoreGradient","atConnectionRatioKeepGradient","atConnectionRatioIgnoreGradient","refR","refD","refPoints","atConnectionLength","atConnectionRatio","refX2","refY2","refWidth2","refHeight2","attributes"],"mappings":"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","sourcesContent":["import { Point, Path, Polyline } from '../g/index.mjs';\nimport { assign, isPlainObject, pick, isObject, isPercentage, breakText } from '../util/util.mjs';\nimport $ from 'jquery';\nimport V from '../V/index.mjs';\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = isPercentage(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = Point();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if (isPercentage(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var $node = $(node);\n        var cache = $node.data(cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            $node.data(cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new Path(V.normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregared here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context.strokeOpacity;\n    if (strokeOpacity === undefined) strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nconst attributesNS = {\n\n    xlinkHref: {\n        set: 'xlink:href'\n    },\n\n    xlinkShow: {\n        set: 'xlink:show'\n    },\n\n    xlinkRole: {\n        set: 'xlink:role'\n    },\n\n    xlinkType: {\n        set: 'xlink:type'\n    },\n\n    xlinkArcrole: {\n        set: 'xlink:arcrole'\n    },\n\n    xlinkTitle: {\n        set: 'xlink:title'\n    },\n\n    xlinkActuate: {\n        set: 'xlink:actuate'\n    },\n\n    xmlSpace: {\n        set: 'xml:space'\n    },\n\n    xmlBase: {\n        set: 'xml:base'\n    },\n\n    xmlLang: {\n        set: 'xml:lang'\n    },\n\n    preserveAspectRatio: {\n        set: 'preserveAspectRatio'\n    },\n\n    requiredExtension: {\n        set: 'requiredExtension'\n    },\n\n    requiredFeatures: {\n        set: 'requiredFeatures'\n    },\n\n    systemLanguage: {\n        set: 'systemLanguage'\n    },\n\n    externalResourcesRequired: {\n        set: 'externalResourceRequired'\n    },\n\n    filter: {\n        qualify: isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n\n    fill: {\n        qualify: isPlainObject,\n        set: function(fill) {\n            return 'url(#' + this.paper.defineGradient(fill) + ')';\n        }\n    },\n\n    stroke: {\n        qualify: isPlainObject,\n        set: function(stroke) {\n            return 'url(#' + this.paper.defineGradient(stroke) + ')';\n        }\n    },\n\n    sourceMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    targetMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    vertexMarker: {\n        qualify: isPlainObject,\n        set: function(marker, refBBox, node, attrs) {\n            marker = assign(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    text: {\n        qualify: function(_text, _node, attrs) {\n            return !attrs.textWrap || !isPlainObject(attrs.textWrap);\n        },\n        set: function(text, _refBBox, node, attrs) {\n            var $node = $(node);\n            var cacheName = 'joint-text';\n            var cache = $node.data(cacheName);\n            var textAttrs = pick(attrs, 'lineHeight', 'annotations', 'textPath', 'x', 'textVerticalAnchor', 'eol', 'displayEmpty');\n            var fontSize = textAttrs.fontSize = attrs['font-size'] || attrs['fontSize'];\n            var textHash = JSON.stringify([text, textAttrs]);\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // Tspans positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                var textPath = textAttrs.textPath;\n                if (isObject(textPath)) {\n                    var pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        var pathNode = this.findBySelector(pathSelector)[0];\n                        if (pathNode instanceof SVGPathElement) {\n                            textAttrs.textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, textAttrs);\n                $node.data(cacheName, textHash);\n            }\n        }\n    },\n\n    textWrap: {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            // option `width`\n            var width = value.width || 0;\n            if (isPercentage(width)) {\n                refBBox.width *= parseFloat(width) / 100;\n            } else if (width <= 0) {\n                refBBox.width += width;\n            } else {\n                refBBox.width = width;\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                refBBox.height *= parseFloat(height) / 100;\n            } else if (height <= 0) {\n                refBBox.height += height;\n            } else {\n                refBBox.height = height;\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n                wrappedText = breakText('' + text, refBBox, {\n                    'font-weight': attrs['font-weight'] || attrs.fontWeight,\n                    'font-size': attrs['font-size'] || attrs.fontSize,\n                    'font-family': attrs['font-family'] || attrs.fontFamily,\n                    'lineHeight': attrs.lineHeight,\n                    'letter-spacing': 'letter-spacing' in attrs ? attrs['letter-spacing'] : attrs.letterSpacing\n                }, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    maxLineCount: value.maxLineCount\n                });\n            } else {\n                wrappedText = '';\n            }\n            attributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        }\n    },\n\n    title: {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var $node = $(node);\n            var cacheName = 'joint-title';\n            var cache = $node.data(cacheName);\n            if (cache === undefined || cache !== title) {\n                $node.data(cacheName, title);\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstChild;\n                if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n\n    lineHeight: {\n        qualify: isTextInUse\n    },\n\n    textVerticalAnchor: {\n        qualify: isTextInUse\n    },\n\n    textPath: {\n        qualify: isTextInUse\n    },\n\n    annotations: {\n        qualify: isTextInUse\n    },\n\n    eol: {\n        qualify: isTextInUse\n    },\n\n    displayEmpty: {\n        qualify: isTextInUse\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    port: {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the subelement.\n    style: {\n        qualify: isPlainObject,\n        set: function(styles, refBBox, node) {\n            $(node).css(styles);\n        }\n    },\n\n    html: {\n        set: function(html, refBBox, node) {\n            $(node).html(html + '');\n        }\n    },\n\n    ref: {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n\n    refX: {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    refY: {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    refDx: {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    refDy: {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    refWidth: {\n        set: setWrapper('width', 'width')\n    },\n\n    refHeight: {\n        set: setWrapper('height', 'height')\n    },\n\n    refRx: {\n        set: setWrapper('rx', 'width')\n    },\n\n    refRy: {\n        set: setWrapper('ry', 'height')\n    },\n\n    refRInscribed: {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    refRCircumscribed: {\n        set: function(value, refBBox) {\n            var isValuePercentage = isPercentage(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n\n    refCx: {\n        set: setWrapper('cx', 'width')\n    },\n\n    refCy: {\n        set: setWrapper('cy', 'height')\n    },\n\n    // `x-alignment` when set to `middle` causes centering of the subelement around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n\n    xAlignment: {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the subelement around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n\n    yAlignment: {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    resetOffset: {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n\n    },\n\n    refDResetOffset: {\n        set: dWrapper({ resetOffset: true })\n    },\n\n    refDKeepOffset: {\n        set: dWrapper({ resetOffset: false })\n    },\n\n    refPointsResetOffset: {\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    refPointsKeepOffset: {\n        set: pointsWrapper({ resetOffset: false })\n    },\n\n    // LinkView Attributes\n\n    connection: {\n        qualify: isLinkView,\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const sourceParts = path.divideAtLength(offset);\n                const targetParts = path.divideAtLength(-offset);\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    atConnectionLengthKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    atConnectionLengthIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    atConnectionRatioKeepGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    atConnectionRatioIgnoreGradient: {\n        qualify: isLinkView,\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n};\n\n// Aliases\nattributesNS.refR = attributesNS.refRInscribed;\nattributesNS.refD = attributesNS.refDResetOffset;\nattributesNS.refPoints = attributesNS.refPointsResetOffset;\nattributesNS.atConnectionLength = attributesNS.atConnectionLengthKeepGradient;\nattributesNS.atConnectionRatio = attributesNS.atConnectionRatioKeepGradient;\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nattributesNS.refX2 = attributesNS.refX;\nattributesNS.refY2 = attributesNS.refY;\nattributesNS.refWidth2 = attributesNS.refWidth;\nattributesNS.refHeight2 = attributesNS.refHeight;\n\n// Aliases for backwards compatibility\nattributesNS['ref-x'] = attributesNS.refX;\nattributesNS['ref-y'] = attributesNS.refY;\nattributesNS['ref-dy'] = attributesNS.refDy;\nattributesNS['ref-dx'] = attributesNS.refDx;\nattributesNS['ref-width'] = attributesNS.refWidth;\nattributesNS['ref-height'] = attributesNS.refHeight;\nattributesNS['x-alignment'] = attributesNS.xAlignment;\nattributesNS['y-alignment'] = attributesNS.yAlignment;\n\nexport const attributes = attributesNS;\n\n"]},"metadata":{},"sourceType":"module"}