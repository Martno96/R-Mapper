{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { nanoid } from 'nanoid';\nimport * as joint from 'jointjs';\nimport { shapes, dia } from 'jointjs';\nimport * as standard from 'jointjs/src/shapes/standard.mjs';\nimport { bondCategories } from '../constants'; // window.joint = joint\n// graph: () => {\n//   let graph = new joint.dia.Graph\n//   graph.toJSON()\n//   return graph\n// },\n// console.log(joint.shapes)\n\nlet initGraph = new joint.dia.Graph({}, {\n  cellNamespace: joint.shapes\n}); // let rectio = new joint.shapes.standard.Rectangle()\n// rectio.position(150, 50)\n// rectio.resize(100, 40)\n// rectio.attr({\n//   body: {\n//     fill: 'green'\n//   },\n//   label: {\n//     text: 'bob',\n//     fill: 'white'\n//   }\n// })\n// // console.log(rectio)\n// rectio.addTo(initGraph)\n\nconsole.log(\"--- Initialized graph in redux store! ---\");\nlet jsonGraph = initGraph.toJSON(initGraph); // console.log(jsonGraph)\n// console.log(JSON.stringify(jsonGraph))\n// const parsy = JSON.stringify(jsonGraph)\n// console.log(JSON.parse(parsy))\n\nconst initialItems = localStorage.getItem('cast') ? JSON.parse(localStorage.getItem('cast')) : {\n  graph: JSON.stringify(jsonGraph),\n  characters: [{\n    id: nanoid(),\n    name: \"Smirgus\",\n    bio: \"sabka jcbskbqkib bdkabsd sabkdbka dbkasbjkdb kdbajsbd\"\n  }, {\n    id: nanoid(),\n    name: \"Virp\",\n    bio: \"olbdkabsd sabkdbka sabka jcbskbqkib dbkasbjkdb kdbajsbd\"\n  }, {\n    id: nanoid(),\n    name: \"Plonky\",\n    bio: \"sabka dbkasbjkdb jcbskbqkib sabkdbka kdbajsbd bdkabsd \"\n  }],\n  bonds: [{\n    id: nanoid(),\n    category: \"Familial Bonds\",\n    source: \"Plonky\",\n    subtype: \"has kids with\",\n    target: \"Smirgus\",\n    summary: \"sabka sabkdbka dbkasbjkdb kdbajsbd\"\n  }],\n  first: 0\n};\nexport const cast = createSlice({\n  name: \"cast\",\n  initialState: initialItems,\n  reducers: {\n    addCharacter: (store, action) => {\n      //localStorage.setItem('username', JSON.stringify(action.payload))\n      store.characters = [...store.characters, {\n        id: nanoid(),\n        name: action.payload.name,\n        bio: action.payload.bio\n      }];\n    },\n    addBond: (store, action) => {\n      //localStorage.setItem('username', JSON.stringify(action.payload))\n      //validate that values are okay\n      if (typeof action.payload.category === 'string' && action.payload.category !== '' && typeof action.payload.source === 'string' && action.payload.source !== '' && typeof action.payload.subtype === 'string' && action.payload.subtype !== '' && typeof action.payload.target === 'string' && action.payload.target !== '' && typeof action.payload.category === 'string' && action.payload.category !== '' && typeof action.payload.details === 'string' && action.payload.details !== '') {\n        store.bonds = [...store.bonds, {\n          id: nanoid(),\n          category: action.payload.category,\n          source: action.payload.source,\n          subtype: action.payload.subtype,\n          target: action.payload.target,\n          summary: action.payload.details\n        }];\n      } else {\n        console.error(\"addBond reducer caught payload properties either not being strings AND/OR being empty strings\");\n        console.log(action.payload.category);\n        console.log(action.payload.source);\n        console.log(action.payload.subtype);\n        console.log(action.payload.target);\n        console.log(action.payload.details);\n      }\n    },\n    loadGraph: (store, action) => {},\n    saveGraph: (store, action) => {},\n    drawMap: (store, action) => {\n      console.log(\"--- drawMap reducer called! ---\");\n      const elementPositionsToRetainV2 = action.payload.model.getElements().map(element => {\n        return element.get('position');\n      });\n      console.log(\"elementPositionsToRetainV2\");\n      console.log(elementPositionsToRetainV2);\n      console.log(\"paper model\");\n      console.log(action.payload.model.toJSON()); //NOTE: the goal for this here array SHOULD BE to get the NEW coordinates for each CHARACTER\n      //in the character ARRAY! :D (wait but what about Bonds???? they will have positons too right?)\n\n      console.log(\"getElements()\");\n      console.log(action.payload.model.getElements());\n      const elementPositionsToRetain = action.payload.model.getElements().map(element => {\n        if (element.attributes.type === \"standard.Rectangle\") {\n          return {\n            type: \"character\",\n            name: element.attributes.attrs.label.text,\n            position: element.getBBox().center()\n          };\n        } else if (element.attributes.type === \"standard.Ellipse\") {\n          return {\n            type: \"bond details\",\n            position: element.getBBox().center()\n          };\n        } else {\n          return {};\n        }\n      }); // const elementPositionsToRetain = action.payload.model.toJSON().cells.map(cell => {\n      //   if (cell.type === \"standard.Rectangle\") {\n      //     return { type: \"character\", name: cell.attrs.label.text, position: cell.getBBox().center() }\n      //   } else if (cell.type === \"standard.Ellipse\") {\n      //     return { type: \"bond details\", position: cell.getBBox().center() }\n      //   } else {\n      //     return {}\n      //   }\n      // })\n\n      console.log(\"positions to retain array:\");\n      console.log(elementPositionsToRetain); //ISSUE(?): using the characters array as a forEach below is problematic because\n      //the character array won't map 1-to-1 with the cells array in the graph, since cells \n      //A) include Links too and B) also may not be in the same order as the characters \n      //in the characters array\n      //No, wait... if I simply itterate through the characters array and at each character\n      //find the Element in the stored graph with the same label as the character name, then\n      //I can at the same time\n      //Potential fixes:\n      //> itterate using the STORED GRAPH cells array instead, but check if it is an Element or a Link,\n      // then accordingly do what? If it is an Element it must be a character, so\n      // let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\n      // updatedGraph.fromJSON(JSON.parse(store.graph)) //get existing graph from store\n      // updatedGraph.clear()\n      // console.log(\"Unpacked store graph:\")\n      // console.log(updatedGraph)\n      //draw Characters\n\n      store.characters.forEach((character, index) => {\n        let positionX, positionY;\n\n        if (elementPositionsToRetain.find(element => element.name === character.name) !== undefined) {\n          //element is already in graph since previously\n          console.log(\"found element\");\n          positionX = elementPositionsToRetain.find(element => element.name === character.name).position.x;\n          positionY = elementPositionsToRetain.find(element => element.name === character.name).position.y;\n        } else {\n          //character is new and should be added to graph\n          console.log(\"new element\");\n          positionX = index * 10;\n          positionY = index * 10;\n          let rect = new joint.shapes.standard.Rectangle();\n          rect.position(positionX, positionY); //instead read positions from corresponding graph in payload (model)\n\n          rect.resize(100, 40);\n          rect.attr({\n            body: {\n              fill: 'green'\n            },\n            label: {\n              text: character.name,\n              fill: 'white'\n            }\n          });\n          rect.addTo(action.payload.model);\n        }\n\n        console.log(`x: ${positionX}`);\n        console.log(`y: ${positionY}`);\n      }); //draw Bonds\n\n      const markup = [{\n        tagName: 'circle',\n        selector: 'body'\n      }, {\n        tagName: 'text',\n        selector: 'label'\n      }];\n      store.bonds.forEach((bond, index) => {\n        const sourceElement = action.payload.model.getElements().find(element => element.attributes.attrs.label.text === bond.source);\n        const targetElement = action.payload.model.getElements().find(element => element.attributes.attrs.label.text === bond.target);\n        let link = new joint.shapes.standard.Link();\n        link.source(sourceElement);\n        link.target(targetElement);\n        link.appendLabel({\n          markup: markup,\n          attrs: {\n            label: {\n              text: bond.subtype\n            },\n            body: {\n              ref: 'label',\n              fill: '#ffffff',\n              stroke: '#000000',\n              strokeWidth: 2,\n              refR: 0.5,\n              refCx: 1,\n              refCy: 1\n            }\n          } // bondSubtype: {\n          //   text: bond.subtype,\n          //   fill: '#000000',\n          //   fontSize: 14,\n          //   textAnchor: 'middle',\n          //   yAlignment: 'middle',\n          //   pointerEvents: 'none'\n          // },\n          // bondNodeBody: {\n          //   fill: '#ffffff',\n          //   stroke: '#000000',\n          //   strokeWidth: 1\n          // }\n\n        });\n        link.addTo(action.payload.model);\n      });\n      console.log(action.payload.model.toJSON());\n      console.log(\"--- Stored graph in redux store! ---\");\n      store.graph = JSON.stringify(action.payload.model.toJSON()); //update store\n    },\n    clearFirst: (store, action) => {\n      store.first++;\n    }\n  }\n}); // drawCharacters: (store, action) => {\n//   console.log(\"draw character\")\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\n//   // console.log(JSON.parse(store.graph))\n//   updatedGraph.fromJSON(JSON.parse(store.graph)) //get existing graph from store\n//  // console.log(updatedGraph)\n//   store.characters.forEach((character, index) => {\n//     let rect = new joint.shapes.standard.Rectangle();\n//     rect.position(150+index*10, 50+index*10);\n//     rect.resize(100, 40);\n//     rect.attr({\n//       body: {\n//         fill: 'green'\n//       },\n//       label: {\n//         text: character.name,\n//         fill: 'white'\n//       }\n//     });\n//    // console.log(rect)\n//     rect.addTo(updatedGraph)\n//    // console.log(`added ${character.name} to graph!`)\n//   })\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\n// },\n// drawBonds: (store, action) => {\n//   console.log(\"is running? Uwu\")\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\n//   updatedGraph.fromJSON(store.graph) //get existing graph from store\n//   const characterElements = updatedGraph.getElements()\n//   // const markup = [\n//   //   {\n//   //     tagName: 'bond-node-body',\n//   //     selector: 'body'\n//   //   }, {\n//   //     tagName: 'bond-summary-text',\n//   //     selector: 'label'\n//   //   }\n//   // ]\n//   store.bonds.forEach((bond, index) => {\n//     const sourceElement = updatedGraph.getElements().find(element => element.attr.label.text === bond.source)\n//     const targetElement = updatedGraph.getElements().find(element => element.attr.label.text === bond.target)\n//    // console.log(sourceElement)\n//    // console.log(targetElement)\n//     //the issue with this section of code is that I was trying to take a normal object and put it into the graph xD\n//     // const sourceElement = store.characters.find(character => character.id === bond.source)\n//     // const targetElement = store.characters.find(character => character.id === bond.target)\n//     //I gotta reach into the actual graph Element! Once I am inside this forEach, MOST of the bonds array usage is done\n//     //search among character Elements in graph using the label name of bond.source etc.\n//     let link = new joint.shapes.standard.Link();\n//     link.source(sourceElement);\n//     link.target(targetElement);\n//     link.appendLabel({\n//       attrs: {\n//         text: {\n//           text: bond.subtype\n//         }\n//       }\n//     })\n//     link.addTo(updatedGraph)\n//   })\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\n// },\n// drawTest: (store, action) => {\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\n//   updatedGraph.fromJSON(store.graph) //get existing graph from store\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\n// },\n// console.log(\"updatedGraph.getElements():\")\n// console.log(updatedGraph.getElements())\n// console.log(\"Bond details:\")\n// console.log(bond.details)\n// console.log(\"Bond sourceElement:\")\n// console.log(sourceElement)\n// console.log(\"Bond targetElement:\")\n// console.log(targetElement)\n\nexport const saveChanges = input => {// let isStart = input.type ? false : true\n  // let endpoint = \"\"\n  // let postBody = {}\n  // return (dispatch, getState) => {\n  //   const state = getState()\n  //   if (isStart) {\n  //     endpoint = \"start\"\n  //     postBody = JSON.stringify({\n  //       username: input\n  //     })\n  //   } else {\n  //     endpoint = \"action\"\n  //     postBody = JSON.stringify({\n  //       username: state.game.username,\n  //       type: input.type,\n  //       direction: input.direction\n  //     })\n  //     dispatch(game.actions.logAction(JSON.parse(postBody)))\n  //   }\n  //   dispatch(game.actions.setLoadProgress(33))\n  //   fetch(`https://wk16-backend.herokuapp.com/${endpoint}`, {\n  //     method: \"POST\",\n  //     headers: {\n  //       'Content-Type': 'application/json;charset=utf-8'\n  //     },\n  //     body: postBody\n  //   })\n  //     .then(res => {\n  //       dispatch(game.actions.setLoadProgress(55))\n  //       return res.json()\n  //     })\n  //     .then(update => {\n  //       dispatch(game.actions.setLoadProgress(77))\n  //       return dispatch(game.actions.setGameState(update))\n  //     })\n  //     .catch(error => dispatch(game.actions.setError(error.message)))\n  //     .finally(() => dispatch(game.actions.setLoadProgress(100))) \n  //   }\n};\nexport default cast;","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/src/reducers/cast.js"],"names":["createSlice","nanoid","joint","shapes","dia","standard","bondCategories","initGraph","Graph","cellNamespace","console","log","jsonGraph","toJSON","initialItems","localStorage","getItem","JSON","parse","graph","stringify","characters","id","name","bio","bonds","category","source","subtype","target","summary","first","cast","initialState","reducers","addCharacter","store","action","payload","addBond","details","error","loadGraph","saveGraph","drawMap","elementPositionsToRetainV2","model","getElements","map","element","get","elementPositionsToRetain","attributes","type","attrs","label","text","position","getBBox","center","forEach","character","index","positionX","positionY","find","undefined","x","y","rect","Rectangle","resize","attr","body","fill","addTo","markup","tagName","selector","bond","sourceElement","targetElement","link","Link","appendLabel","ref","stroke","strokeWidth","refR","refCx","refCy","clearFirst","saveChanges","input"],"mappings":"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f,CAAqBjC,MAArB,EAAZ;AACAH,MAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ;AACAyB,MAAAA,KAAK,CAACjB,KAAN,GAAcF,IAAI,CAACG,SAAL,CAAeiB,MAAM,CAACC,OAAP,CAAeQ,KAAf,CAAqBjC,MAArB,EAAf,CAAd,CA5I0B,CA4IkC;AAC7D,KAzLO;AA0LR8E,IAAAA,UAAU,EAAE,CAACvD,KAAD,EAAQC,MAAR,KAAmB;AAC7BD,MAAAA,KAAK,CAACL,KAAN;AACD;AA5LO;AAHqB,CAAF,CAAxB,C,CAmMP;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAM6D,WAAW,GAAIC,KAAD,IAAW,CACpC;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD,CAxCM;AA0CP,eAAe7D,IAAf","sourcesContent":["import { createSlice } from '@reduxjs/toolkit'\r\nimport { nanoid } from 'nanoid'\r\nimport * as joint from 'jointjs'\r\nimport { shapes, dia } from 'jointjs'\r\nimport * as standard from 'jointjs/src/shapes/standard.mjs'\r\n\r\n\r\nimport { bondCategories } from '../constants'\r\n\r\n// window.joint = joint\r\n// graph: () => {\r\n//   let graph = new joint.dia.Graph\r\n//   graph.toJSON()\r\n//   return graph\r\n// },\r\n// console.log(joint.shapes)\r\nlet initGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes })\r\n\r\n// let rectio = new joint.shapes.standard.Rectangle()\r\n// rectio.position(150, 50)\r\n// rectio.resize(100, 40)\r\n// rectio.attr({\r\n//   body: {\r\n//     fill: 'green'\r\n//   },\r\n//   label: {\r\n//     text: 'bob',\r\n//     fill: 'white'\r\n//   }\r\n// })\r\n// // console.log(rectio)\r\n// rectio.addTo(initGraph)\r\n\r\nconsole.log(\"--- Initialized graph in redux store! ---\")\r\nlet jsonGraph = initGraph.toJSON(initGraph)\r\n// console.log(jsonGraph)\r\n// console.log(JSON.stringify(jsonGraph))\r\n// const parsy = JSON.stringify(jsonGraph)\r\n// console.log(JSON.parse(parsy))\r\n\r\nconst initialItems = localStorage.getItem('cast')\r\n? JSON.parse(localStorage.getItem('cast'))\r\n: {\r\n  graph: JSON.stringify(jsonGraph),\r\n  characters: [\r\n    {\r\n      id: nanoid(),\r\n      name: \"Smirgus\",\r\n      bio: \"sabka jcbskbqkib bdkabsd sabkdbka dbkasbjkdb kdbajsbd\"\r\n    },\r\n    {\r\n      id: nanoid(),\r\n      name: \"Virp\",\r\n      bio: \"olbdkabsd sabkdbka sabka jcbskbqkib dbkasbjkdb kdbajsbd\"\r\n    },\r\n    {\r\n      id: nanoid(),\r\n      name: \"Plonky\",\r\n      bio: \"sabka dbkasbjkdb jcbskbqkib sabkdbka kdbajsbd bdkabsd \"\r\n    }\r\n  ],\r\n  bonds: [\r\n    {\r\n      id: nanoid(),\r\n      category: \"Familial Bonds\",\r\n      source: \"Plonky\",\r\n      subtype: \"has kids with\",\r\n      target: \"Smirgus\",\r\n      summary: \"sabka sabkdbka dbkasbjkdb kdbajsbd\"\r\n    }\r\n  ],\r\n  first: 0\r\n}\r\n\r\nexport const cast = createSlice ({\r\n  name: \"cast\",\r\n  initialState: initialItems,\r\n  reducers: {\r\n    addCharacter: (store, action) => {\r\n      //localStorage.setItem('username', JSON.stringify(action.payload))\r\n      store.characters = [...store.characters, {\r\n        id: nanoid(),\r\n        name: action.payload.name,\r\n        bio: action.payload.bio\r\n      }]\r\n    },\r\n    addBond: (store, action) => {\r\n      //localStorage.setItem('username', JSON.stringify(action.payload))\r\n      \r\n      //validate that values are okay\r\n      if (\r\n        typeof action.payload.category === 'string' && action.payload.category !== '' &&\r\n        typeof action.payload.source === 'string' && action.payload.source !== '' &&\r\n        typeof action.payload.subtype === 'string' && action.payload.subtype !== '' &&\r\n        typeof action.payload.target === 'string' && action.payload.target !== '' &&\r\n        typeof action.payload.category === 'string' && action.payload.category !== '' &&\r\n        typeof action.payload.details === 'string' && action.payload.details !== ''\r\n      ) {\r\n        store.bonds = [...store.bonds, {\r\n          id: nanoid(),\r\n          category: action.payload.category,\r\n          source: action.payload.source,\r\n          subtype: action.payload.subtype,\r\n          target: action.payload.target,\r\n          summary: action.payload.details\r\n        }]\r\n      } else {\r\n        console.error(\"addBond reducer caught payload properties either not being strings AND/OR being empty strings\")\r\n        console.log(action.payload.category)\r\n        console.log(action.payload.source)\r\n        console.log(action.payload.subtype)\r\n        console.log(action.payload.target)\r\n        console.log(action.payload.details)\r\n      }\r\n    },\r\n    loadGraph: (store, action) => {\r\n\r\n    },\r\n    saveGraph: (store, action) => {\r\n\r\n    },\r\n    drawMap: (store, action) => {\r\n      console.log(\"--- drawMap reducer called! ---\")\r\n\r\n      const elementPositionsToRetainV2 = action.payload.model.getElements().map(element => {\r\n        return element.get('position')\r\n      })\r\n\r\n      console.log(\"elementPositionsToRetainV2\")\r\n      console.log(elementPositionsToRetainV2)\r\n\r\n      console.log(\"paper model\")\r\n      console.log(action.payload.model.toJSON())\r\n\r\n      //NOTE: the goal for this here array SHOULD BE to get the NEW coordinates for each CHARACTER\r\n      //in the character ARRAY! :D (wait but what about Bonds???? they will have positons too right?)\r\n      console.log(\"getElements()\")\r\n      console.log(action.payload.model.getElements())\r\n      \r\n      const elementPositionsToRetain = action.payload.model.getElements().map(element => {\r\n        if (element.attributes.type === \"standard.Rectangle\") {\r\n          return { type: \"character\", name: element.attributes.attrs.label.text, position: element.getBBox().center() }\r\n        } else if (element.attributes.type === \"standard.Ellipse\") {\r\n          return { type: \"bond details\", position: element.getBBox().center() }\r\n        } else {\r\n          return {}\r\n        }\r\n      })\r\n\r\n      // const elementPositionsToRetain = action.payload.model.toJSON().cells.map(cell => {\r\n      //   if (cell.type === \"standard.Rectangle\") {\r\n      //     return { type: \"character\", name: cell.attrs.label.text, position: cell.getBBox().center() }\r\n      //   } else if (cell.type === \"standard.Ellipse\") {\r\n      //     return { type: \"bond details\", position: cell.getBBox().center() }\r\n      //   } else {\r\n      //     return {}\r\n      //   }\r\n      // })\r\n      console.log(\"positions to retain array:\")\r\n      console.log(elementPositionsToRetain)\r\n\r\n          //ISSUE(?): using the characters array as a forEach below is problematic because\r\n          //the character array won't map 1-to-1 with the cells array in the graph, since cells \r\n          //A) include Links too and B) also may not be in the same order as the characters \r\n          //in the characters array\r\n          //No, wait... if I simply itterate through the characters array and at each character\r\n          //find the Element in the stored graph with the same label as the character name, then\r\n          //I can at the same time\r\n          //Potential fixes:\r\n          //> itterate using the STORED GRAPH cells array instead, but check if it is an Element or a Link,\r\n          // then accordingly do what? If it is an Element it must be a character, so\r\n\r\n      // let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\r\n      // updatedGraph.fromJSON(JSON.parse(store.graph)) //get existing graph from store\r\n      // updatedGraph.clear()\r\n      // console.log(\"Unpacked store graph:\")\r\n      // console.log(updatedGraph)\r\n\r\n      //draw Characters\r\n      store.characters.forEach((character, index) => {\r\n        let positionX, positionY\r\n        if (elementPositionsToRetain.find(element => element.name === character.name) !== undefined) {\r\n          //element is already in graph since previously\r\n          console.log(\"found element\")\r\n          positionX = elementPositionsToRetain.find(element => element.name === character.name).position.x\r\n          positionY = elementPositionsToRetain.find(element => element.name === character.name).position.y\r\n        } else {\r\n          //character is new and should be added to graph\r\n          console.log(\"new element\")\r\n          positionX = index*10\r\n          positionY = index*10\r\n          let rect = new joint.shapes.standard.Rectangle();\r\n          rect.position(positionX, positionY); //instead read positions from corresponding graph in payload (model)\r\n          rect.resize(100, 40);\r\n          rect.attr({\r\n            body: {\r\n              fill: 'green'\r\n            },\r\n            label: {\r\n              text: character.name,\r\n              fill: 'white'\r\n            }\r\n          });\r\n        rect.addTo(action.payload.model)\r\n        }\r\n        console.log(`x: ${positionX}`)\r\n        console.log(`y: ${positionY}`)        \r\n      })\r\n\r\n      //draw Bonds\r\n      const markup = [\r\n        {\r\n          tagName: 'circle',\r\n          selector: 'body'\r\n        }, {\r\n          tagName: 'text',\r\n          selector: 'label'\r\n        }\r\n      ]\r\n\r\n      store.bonds.forEach((bond, index) => {\r\n        const sourceElement = action.payload.model.getElements().find(element => element.attributes.attrs.label.text === bond.source)\r\n        const targetElement = action.payload.model.getElements().find(element => element.attributes.attrs.label.text === bond.target)\r\n        let link = new joint.shapes.standard.Link();\r\n        link.source(sourceElement);\r\n        link.target(targetElement);\r\n        link.appendLabel({\r\n          markup: markup,\r\n          attrs: {\r\n            label: {\r\n              text: bond.subtype\r\n            },\r\n            body: {\r\n              ref: 'label',\r\n              fill: '#ffffff',\r\n              stroke: '#000000',\r\n              strokeWidth: 2,\r\n              refR: 0.5,\r\n              refCx: 1,\r\n              refCy: 1\r\n            }\r\n          }\r\n          // bondSubtype: {\r\n          //   text: bond.subtype,\r\n          //   fill: '#000000',\r\n          //   fontSize: 14,\r\n          //   textAnchor: 'middle',\r\n          //   yAlignment: 'middle',\r\n          //   pointerEvents: 'none'\r\n          // },\r\n          // bondNodeBody: {\r\n\r\n          //   fill: '#ffffff',\r\n          //   stroke: '#000000',\r\n          //   strokeWidth: 1\r\n          // }\r\n        })\r\n        link.addTo(action.payload.model)\r\n      })\r\n      console.log(action.payload.model.toJSON())\r\n      console.log(\"--- Stored graph in redux store! ---\")\r\n      store.graph = JSON.stringify(action.payload.model.toJSON()) //update store\r\n    },\r\n    clearFirst: (store, action) => {\r\n      store.first++\r\n    }\r\n  }\r\n})\r\n\r\n// drawCharacters: (store, action) => {\r\n//   console.log(\"draw character\")\r\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\r\n//   // console.log(JSON.parse(store.graph))\r\n\r\n//   updatedGraph.fromJSON(JSON.parse(store.graph)) //get existing graph from store\r\n//  // console.log(updatedGraph)\r\n//   store.characters.forEach((character, index) => {\r\n//     let rect = new joint.shapes.standard.Rectangle();\r\n//     rect.position(150+index*10, 50+index*10);\r\n//     rect.resize(100, 40);\r\n//     rect.attr({\r\n//       body: {\r\n//         fill: 'green'\r\n//       },\r\n//       label: {\r\n//         text: character.name,\r\n//         fill: 'white'\r\n//       }\r\n//     });\r\n//    // console.log(rect)\r\n//     rect.addTo(updatedGraph)\r\n//    // console.log(`added ${character.name} to graph!`)\r\n//   })\r\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\r\n// },\r\n// drawBonds: (store, action) => {\r\n//   console.log(\"is running? Uwu\")\r\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\r\n//   updatedGraph.fromJSON(store.graph) //get existing graph from store\r\n//   const characterElements = updatedGraph.getElements()\r\n\r\n//   // const markup = [\r\n//   //   {\r\n//   //     tagName: 'bond-node-body',\r\n//   //     selector: 'body'\r\n//   //   }, {\r\n//   //     tagName: 'bond-summary-text',\r\n//   //     selector: 'label'\r\n//   //   }\r\n//   // ]\r\n\r\n//   store.bonds.forEach((bond, index) => {\r\n//     const sourceElement = updatedGraph.getElements().find(element => element.attr.label.text === bond.source)\r\n//     const targetElement = updatedGraph.getElements().find(element => element.attr.label.text === bond.target)\r\n//    // console.log(sourceElement)\r\n//    // console.log(targetElement)\r\n//     //the issue with this section of code is that I was trying to take a normal object and put it into the graph xD\r\n//     // const sourceElement = store.characters.find(character => character.id === bond.source)\r\n//     // const targetElement = store.characters.find(character => character.id === bond.target)\r\n\r\n//     //I gotta reach into the actual graph Element! Once I am inside this forEach, MOST of the bonds array usage is done\r\n//     //search among character Elements in graph using the label name of bond.source etc.\r\n\r\n//     let link = new joint.shapes.standard.Link();\r\n//     link.source(sourceElement);\r\n//     link.target(targetElement);\r\n//     link.appendLabel({\r\n//       attrs: {\r\n//         text: {\r\n//           text: bond.subtype\r\n//         }\r\n//       }\r\n//     })\r\n//     link.addTo(updatedGraph)\r\n//   })\r\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\r\n// },\r\n// drawTest: (store, action) => {\r\n//   let updatedGraph = new joint.dia.Graph({}, { cellNamespace: joint.shapes }) //init new graph instance\r\n//   updatedGraph.fromJSON(store.graph) //get existing graph from store\r\n  \r\n//   store.graph = JSON.stringify(updatedGraph.toJSON()) //update store\r\n// },\r\n\r\n\r\n// console.log(\"updatedGraph.getElements():\")\r\n// console.log(updatedGraph.getElements())\r\n// console.log(\"Bond details:\")\r\n// console.log(bond.details)\r\n// console.log(\"Bond sourceElement:\")\r\n// console.log(sourceElement)\r\n// console.log(\"Bond targetElement:\")\r\n// console.log(targetElement)\r\n\r\nexport const saveChanges = (input) => {\r\n  // let isStart = input.type ? false : true\r\n  // let endpoint = \"\"\r\n  // let postBody = {}\r\n\r\n  // return (dispatch, getState) => {\r\n  //   const state = getState()\r\n  //   if (isStart) {\r\n  //     endpoint = \"start\"\r\n  //     postBody = JSON.stringify({\r\n  //       username: input\r\n  //     })\r\n  //   } else {\r\n  //     endpoint = \"action\"\r\n  //     postBody = JSON.stringify({\r\n  //       username: state.game.username,\r\n  //       type: input.type,\r\n  //       direction: input.direction\r\n  //     })\r\n  //     dispatch(game.actions.logAction(JSON.parse(postBody)))\r\n  //   }\r\n  //   dispatch(game.actions.setLoadProgress(33))\r\n  //   fetch(`https://wk16-backend.herokuapp.com/${endpoint}`, {\r\n  //     method: \"POST\",\r\n  //     headers: {\r\n  //       'Content-Type': 'application/json;charset=utf-8'\r\n  //     },\r\n  //     body: postBody\r\n  //   })\r\n  //     .then(res => {\r\n  //       dispatch(game.actions.setLoadProgress(55))\r\n  //       return res.json()\r\n  //     })\r\n  //     .then(update => {\r\n  //       dispatch(game.actions.setLoadProgress(77))\r\n  //       return dispatch(game.actions.setGameState(update))\r\n  //     })\r\n  //     .catch(error => dispatch(game.actions.setError(error.message)))\r\n  //     .finally(() => dispatch(game.actions.setLoadProgress(100))) \r\n  //   }\r\n}\r\n\r\nexport default cast"]},"metadata":{},"sourceType":"module"}