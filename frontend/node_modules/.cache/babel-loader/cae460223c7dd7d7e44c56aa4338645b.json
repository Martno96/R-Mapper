{"ast":null,"code":"import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport { assign, guid, omit, parseDOMJSON, isFunction, isObject, isPlainObject, isBoolean, isEmpty, isString, toKebabCase, sortedIndex, merge, uniq } from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\nconst HighlightingTypes = {\n  DEFAULT: 'default',\n  EMBEDDING: 'embedding',\n  CONNECTING: 'connecting',\n  MAGNET_AVAILABILITY: 'magnetAvailability',\n  ELEMENT_AVAILABILITY: 'elementAvailability'\n}; // CellView base view and controller.\n// --------------------------------------------\n// This is the base view and controller for `ElementView` and `LinkView`.\n\nexport const CellView = View.extend({\n  tagName: 'g',\n  svgElement: true,\n  selector: 'root',\n  metrics: null,\n  className: function () {\n    var classNames = ['cell'];\n    var type = this.model.get('type');\n\n    if (type) {\n      type.toLowerCase().split('.').forEach(function (value, index, list) {\n        classNames.push('type-' + list.slice(0, index + 1).join('-'));\n      });\n    }\n\n    return classNames.join(' ');\n  },\n  _presentationAttributes: null,\n  _flags: null,\n  setFlags: function () {\n    var flags = {};\n    var attributes = {};\n    var shift = 0;\n    var i, n, label;\n    var presentationAttributes = this.presentationAttributes;\n\n    for (var attribute in presentationAttributes) {\n      if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n      var labels = presentationAttributes[attribute];\n      if (!Array.isArray(labels)) labels = [labels];\n\n      for (i = 0, n = labels.length; i < n; i++) {\n        label = labels[i];\n        var flag = flags[label];\n\n        if (!flag) {\n          flag = flags[label] = 1 << shift++;\n        }\n\n        attributes[attribute] |= flag;\n      }\n    }\n\n    var initFlag = this.initFlag;\n    if (!Array.isArray(initFlag)) initFlag = [initFlag];\n\n    for (i = 0, n = initFlag.length; i < n; i++) {\n      label = initFlag[i];\n      if (!flags[label]) flags[label] = 1 << shift++;\n    } // 26 - 30 are reserved for paper flags\n    // 31+ overflows maximal number\n\n\n    if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n    this._flags = flags;\n    this._presentationAttributes = attributes;\n  },\n  hasFlag: function (flag, label) {\n    return flag & this.getFlag(label);\n  },\n  removeFlag: function (flag, label) {\n    return flag ^ flag & this.getFlag(label);\n  },\n  getFlag: function (label) {\n    var flags = this._flags;\n    if (!flags) return 0;\n    var flag = 0;\n\n    if (Array.isArray(label)) {\n      for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n    } else {\n      flag |= flags[label];\n    }\n\n    return flag;\n  },\n  attributes: function () {\n    var cell = this.model;\n    return {\n      'model-id': cell.id,\n      'data-type': cell.attributes.type\n    };\n  },\n  constructor: function (options) {\n    // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n    // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n    // still be associated to the same object among all those clients. This is necessary for real-time\n    // collaboration mechanism.\n    options.id = options.id || guid(this);\n    View.call(this, options);\n  },\n  initialize: function () {\n    this.setFlags();\n    View.prototype.initialize.apply(this, arguments);\n    this.cleanNodesCache(); // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n\n    this.$el.data('view', this);\n    this.startListening();\n  },\n  startListening: function () {\n    this.listenTo(this.model, 'change', this.onAttributesChange);\n  },\n  onAttributesChange: function (model, opt) {\n    var flag = model.getChangeFlag(this._presentationAttributes);\n    if (opt.updateHandled || !flag) return;\n    if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER'); // TODO: tool changes does not need to be sync\n    // Fix Segments tools\n\n    if (opt.tool) opt.async = false;\n    this.requestUpdate(flag, opt);\n  },\n  requestUpdate: function (flags, opt) {\n    const {\n      paper\n    } = this;\n\n    if (paper && flags > 0) {\n      paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n    }\n  },\n  parseDOMJSON: function (markup, root) {\n    var doc = parseDOMJSON(markup);\n    var selectors = doc.selectors;\n    var groups = doc.groupSelectors;\n\n    for (var group in groups) {\n      if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n      selectors[group] = groups[group];\n    }\n\n    if (root) {\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n      selectors[rootSelector] = root;\n    }\n\n    return {\n      fragment: doc.fragment,\n      selectors: selectors\n    };\n  },\n  // Return `true` if cell link is allowed to perform a certain UI `feature`.\n  // Example: `can('vertexMove')`, `can('labelMove')`.\n  can: function (feature) {\n    var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;\n    return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;\n  },\n  findBySelector: function (selector, root, selectors) {\n    root || (root = this.el);\n    selectors || (selectors = this.selectors); // These are either descendants of `this.$el` of `this.$el` itself.\n    // `.` is a special selector used to select the wrapping `<g>` element.\n\n    if (!selector || selector === '.') return [root];\n\n    if (selectors) {\n      var nodes = selectors[selector];\n\n      if (nodes) {\n        if (Array.isArray(nodes)) return nodes;\n        return [nodes];\n      }\n    } // Maintaining backwards compatibility\n    // e.g. `circle:first` would fail with querySelector() call\n\n\n    if (config.useCSSSelectors) return $(root).find(selector).toArray();\n    return [];\n  },\n  notify: function (eventName) {\n    if (this.paper) {\n      var args = Array.prototype.slice.call(arguments, 1); // Trigger the event on both the element itself and also on the paper.\n\n      this.trigger.apply(this, [eventName].concat(args)); // Paper event handlers receive the view object as the first argument.\n\n      this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n    }\n  },\n  getBBox: function (opt) {\n    var bbox;\n\n    if (opt && opt.useModelGeometry) {\n      var model = this.model;\n      bbox = model.getBBox().bbox(model.angle());\n    } else {\n      bbox = this.getNodeBBox(this.el);\n    }\n\n    return this.paper.localToPaperRect(bbox);\n  },\n  getNodeBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    var rotateMatrix = this.getRootRotateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix));\n  },\n  getNodeUnrotatedBBox: function (magnet) {\n    var rect = this.getNodeBoundingRect(magnet);\n    var magnetMatrix = this.getNodeMatrix(magnet);\n    var translateMatrix = this.getRootTranslateMatrix();\n    return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n  },\n  getRootTranslateMatrix: function () {\n    var model = this.model;\n    var position = model.position();\n    var mt = V.createSVGMatrix().translate(position.x, position.y);\n    return mt;\n  },\n  getRootRotateMatrix: function () {\n    var mr = V.createSVGMatrix();\n    var model = this.model;\n    var angle = model.angle();\n\n    if (angle) {\n      var bbox = model.getBBox();\n      var cx = bbox.width / 2;\n      var cy = bbox.height / 2;\n      mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n    }\n\n    return mr;\n  },\n  _notifyHighlight: function (eventName, el, opt = {}) {\n    const {\n      el: rootNode\n    } = this;\n    let node;\n\n    if (typeof el === 'string') {\n      [node = rootNode] = this.findBySelector(el);\n    } else {\n      [node = rootNode] = this.$(el);\n    } // set partial flag if the highlighted element is not the entire view.\n\n\n    opt.partial = node !== rootNode; // translate type flag into a type string\n\n    if (opt.type === undefined) {\n      let type;\n\n      switch (true) {\n        case opt.embedding:\n          type = HighlightingTypes.EMBEDDING;\n          break;\n\n        case opt.connecting:\n          type = HighlightingTypes.CONNECTING;\n          break;\n\n        case opt.magnetAvailability:\n          type = HighlightingTypes.MAGNET_AVAILABILITY;\n          break;\n\n        case opt.elementAvailability:\n          type = HighlightingTypes.ELEMENT_AVAILABILITY;\n          break;\n\n        default:\n          type = HighlightingTypes.DEFAULT;\n          break;\n      }\n\n      opt.type = type;\n    }\n\n    this.notify(eventName, node, opt);\n    return this;\n  },\n  highlight: function (el, opt) {\n    return this._notifyHighlight('cell:highlight', el, opt);\n  },\n  unhighlight: function (el, opt = {}) {\n    return this._notifyHighlight('cell:unhighlight', el, opt);\n  },\n  // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n  // an element found, return the root element of the cell view.\n  findMagnet: function (el) {\n    const root = this.el;\n    let magnet = this.$(el)[0];\n\n    if (!magnet) {\n      magnet = root;\n    }\n\n    do {\n      const magnetAttribute = magnet.getAttribute('magnet');\n      const isMagnetRoot = magnet === root;\n\n      if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n        return magnet;\n      }\n\n      if (isMagnetRoot) {\n        // If the overall cell has set `magnet === false`, then return `undefined` to\n        // announce there is no magnet found for this cell.\n        // This is especially useful to set on cells that have 'ports'. In this case,\n        // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n        return undefined;\n      }\n\n      magnet = magnet.parentNode;\n    } while (magnet);\n\n    return undefined;\n  },\n  findProxyNode: function (el, type) {\n    el || (el = this.el);\n    const nodeSelector = el.getAttribute(`${type}-selector`);\n\n    if (nodeSelector) {\n      const [proxyNode] = this.findBySelector(nodeSelector);\n      if (proxyNode) return proxyNode;\n    }\n\n    return el;\n  },\n  // Construct a unique selector for the `el` element within this view.\n  // `prevSelector` is being collected through the recursive call.\n  // No value for `prevSelector` is expected when using this method.\n  getSelector: function (el, prevSelector) {\n    var selector;\n\n    if (el === this.el) {\n      if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n      return selector;\n    }\n\n    if (el) {\n      var nthChild = V(el).index() + 1;\n      selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n      if (prevSelector) {\n        selector += ' > ' + prevSelector;\n      }\n\n      selector = this.getSelector(el.parentNode, selector);\n    }\n\n    return selector;\n  },\n  getLinkEnd: function (magnet, ...args) {\n    var model = this.model;\n    var id = model.id;\n    var port = this.findAttribute('port', magnet); // Find a unique `selector` of the element under pointer that is a magnet.\n\n    var selector = magnet.getAttribute('joint-selector');\n    var end = {\n      id: id\n    };\n    if (selector != null) end.magnet = selector;\n\n    if (port != null) {\n      end.port = port;\n\n      if (!model.hasPort(port) && !selector) {\n        // port created via the `port` attribute (not API)\n        end.selector = this.getSelector(magnet);\n      }\n    } else if (selector == null && this.el !== magnet) {\n      end.selector = this.getSelector(magnet);\n    }\n\n    return this.customizeLinkEnd(end, magnet, ...args);\n  },\n  customizeLinkEnd: function (end, magnet, x, y, link, endType) {\n    const {\n      paper\n    } = this;\n    const {\n      connectionStrategy\n    } = paper.options;\n\n    if (typeof connectionStrategy === 'function') {\n      var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n      if (strategy) return strategy;\n    }\n\n    return end;\n  },\n  getMagnetFromLinkEnd: function (end) {\n    var root = this.el;\n    var port = end.port;\n    var selector = end.magnet;\n    var model = this.model;\n    var magnet;\n\n    if (port != null && model.isElement() && model.hasPort(port)) {\n      magnet = this.findPortNode(port, selector) || root;\n    } else {\n      if (!selector) selector = end.selector;\n\n      if (!selector && port != null) {\n        // link end has only `id` and `port` property referencing\n        // a port created via the `port` attribute (not API).\n        selector = '[port=\"' + port + '\"]';\n      }\n\n      magnet = this.findBySelector(selector, root, this.selectors)[0];\n    }\n\n    return this.findProxyNode(magnet, 'magnet');\n  },\n  getAttributeDefinition: function (attrName) {\n    return this.model.constructor.getAttributeDefinition(attrName);\n  },\n  setNodeAttributes: function (node, attrs) {\n    if (!isEmpty(attrs)) {\n      if (node instanceof SVGElement) {\n        V(node).attr(attrs);\n      } else {\n        $(node).attr(attrs);\n      }\n    }\n  },\n  processNodeAttributes: function (node, attrs) {\n    var attrName, attrVal, def, i, n;\n    var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n    var relatives = []; // divide the attributes between normal and special\n\n    for (attrName in attrs) {\n      if (!attrs.hasOwnProperty(attrName)) continue;\n      attrVal = attrs[attrName];\n      def = this.getAttributeDefinition(attrName);\n\n      if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\n        if (isString(def.set)) {\n          normalAttrs || (normalAttrs = {});\n          normalAttrs[def.set] = attrVal;\n        }\n\n        if (attrVal !== null) {\n          relatives.push(attrName, def);\n        }\n      } else {\n        normalAttrs || (normalAttrs = {});\n        normalAttrs[toKebabCase(attrName)] = attrVal;\n      }\n    } // handle the rest of attributes via related method\n    // from the special attributes namespace.\n\n\n    for (i = 0, n = relatives.length; i < n; i += 2) {\n      attrName = relatives[i];\n      def = relatives[i + 1];\n      attrVal = attrs[attrName];\n\n      if (isFunction(def.set)) {\n        setAttrs || (setAttrs = {});\n        setAttrs[attrName] = attrVal;\n      }\n\n      if (isFunction(def.position)) {\n        positionAttrs || (positionAttrs = {});\n        positionAttrs[attrName] = attrVal;\n      }\n\n      if (isFunction(def.offset)) {\n        offsetAttrs || (offsetAttrs = {});\n        offsetAttrs[attrName] = attrVal;\n      }\n    }\n\n    return {\n      raw: attrs,\n      normal: normalAttrs,\n      set: setAttrs,\n      position: positionAttrs,\n      offset: offsetAttrs\n    };\n  },\n  updateRelativeAttributes: function (node, attrs, refBBox, opt) {\n    opt || (opt = {});\n    var attrName, attrVal, def;\n    var rawAttrs = attrs.raw || {};\n    var nodeAttrs = attrs.normal || {};\n    var setAttrs = attrs.set;\n    var positionAttrs = attrs.position;\n    var offsetAttrs = attrs.offset;\n\n    for (attrName in setAttrs) {\n      attrVal = setAttrs[attrName];\n      def = this.getAttributeDefinition(attrName); // SET - set function should return attributes to be set on the node,\n      // which will affect the node dimensions based on the reference bounding\n      // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n\n      var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\n      if (isObject(setResult)) {\n        assign(nodeAttrs, setResult);\n      } else if (setResult !== undefined) {\n        nodeAttrs[attrName] = setResult;\n      }\n    }\n\n    if (node instanceof HTMLElement) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.setNodeAttributes(node, nodeAttrs);\n      return;\n    } // The final translation of the subelement.\n\n\n    var nodeTransform = nodeAttrs.transform;\n    var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n    var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n\n    if (nodeTransform) {\n      nodeAttrs = omit(nodeAttrs, 'transform');\n      nodeMatrix.e = nodeMatrix.f = 0;\n    } // Calculate node scale determined by the scalable group\n    // only if later needed.\n\n\n    var sx, sy, translation;\n\n    if (positionAttrs || offsetAttrs) {\n      var nodeScale = this.getNodeScale(node, opt.scalableNode);\n      sx = nodeScale.sx;\n      sy = nodeScale.sy;\n    }\n\n    var positioned = false;\n\n    for (attrName in positionAttrs) {\n      attrVal = positionAttrs[attrName];\n      def = this.getAttributeDefinition(attrName); // POSITION - position function should return a point from the\n      // reference bounding box. The default position of the node is x:0, y:0 of\n      // the reference bounding box or could be further specify by some\n      // SVG attributes e.g. `x`, `y`\n\n      translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n\n      if (translation) {\n        nodePosition.offset(Point(translation).scale(sx, sy));\n        positioned || (positioned = true);\n      }\n    } // The node bounding box could depend on the `size` set from the previous loop.\n    // Here we know, that all the size attributes have been already set.\n\n\n    this.setNodeAttributes(node, nodeAttrs);\n    var offseted = false;\n\n    if (offsetAttrs) {\n      // Check if the node is visible\n      var nodeBoundingRect = this.getNodeBoundingRect(node);\n\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n\n        for (attrName in offsetAttrs) {\n          attrVal = offsetAttrs[attrName];\n          def = this.getAttributeDefinition(attrName); // OFFSET - offset function should return a point from the element\n          // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n          // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n\n          translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\n\n          if (translation) {\n            nodePosition.offset(Point(translation).scale(sx, sy));\n            offseted || (offseted = true);\n          }\n        }\n      }\n    } // Do not touch node's transform attribute if there is no transformation applied.\n\n\n    if (nodeTransform !== undefined || positioned || offseted) {\n      // Round the coordinates to 1 decimal point.\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      node.setAttribute('transform', V.matrixToTransformString(nodeMatrix)); // TODO: store nodeMatrix metrics?\n    }\n  },\n  getNodeScale: function (node, scalableNode) {\n    // Check if the node is a descendant of the scalable group.\n    var sx, sy;\n\n    if (scalableNode && scalableNode.contains(node)) {\n      var scale = scalableNode.scale();\n      sx = 1 / scale.sx;\n      sy = 1 / scale.sy;\n    } else {\n      sx = 1;\n      sy = 1;\n    }\n\n    return {\n      sx: sx,\n      sy: sy\n    };\n  },\n  cleanNodesCache: function () {\n    this.metrics = {};\n  },\n  nodeCache: function (magnet) {\n    var metrics = this.metrics; // Don't use cache? It most likely a custom view with overridden update.\n\n    if (!metrics) return {};\n    var id = V.ensureId(magnet);\n    var value = metrics[id];\n    if (!value) value = metrics[id] = {};\n    return value;\n  },\n  getNodeData: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (!metrics.data) metrics.data = {};\n    return metrics.data;\n  },\n  getNodeBoundingRect: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n    return new Rect(metrics.boundingRect);\n  },\n  getNodeMatrix: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n\n    if (metrics.magnetMatrix === undefined) {\n      var target = this.rotatableNode || this.el;\n      metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n    }\n\n    return V.createSVGMatrix(metrics.magnetMatrix);\n  },\n  getNodeShape: function (magnet) {\n    var metrics = this.nodeCache(magnet);\n    if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n    return metrics.geometryShape.clone();\n  },\n  isNodeConnection: function (node) {\n    return this.model.isLink() && (!node || node === this.el);\n  },\n  findNodesAttributes: function (attrs, root, selectorCache, selectors) {\n    var i, n, nodeAttrs, nodeId;\n    var nodesAttrs = {};\n    var mergeIds = [];\n\n    for (var selector in attrs) {\n      if (!attrs.hasOwnProperty(selector)) continue;\n      nodeAttrs = attrs[selector];\n      if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n\n      var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n\n      for (i = 0, n = selected.length; i < n; i++) {\n        var node = selected[i];\n        nodeId = V.ensureId(node); // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n        // groupSelector referencing a single node is not \"unique\"\n\n        var unique = selectors && selectors[selector] === node;\n        var prevNodeAttrs = nodesAttrs[nodeId];\n\n        if (prevNodeAttrs) {\n          // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n          // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n          if (!prevNodeAttrs.array) {\n            mergeIds.push(nodeId);\n            prevNodeAttrs.array = true;\n            prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n            prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n          }\n\n          var attributes = prevNodeAttrs.attributes;\n          var selectedLength = prevNodeAttrs.selectedLength;\n\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(nodeAttrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector`\n            var sortIndex = sortedIndex(selectedLength, n);\n            attributes.splice(sortIndex, 0, nodeAttrs);\n            selectedLength.splice(sortIndex, 0, n);\n          }\n        } else {\n          nodesAttrs[nodeId] = {\n            attributes: nodeAttrs,\n            selectedLength: unique ? -1 : n,\n            node: node,\n            array: false\n          };\n        }\n      }\n    }\n\n    for (i = 0, n = mergeIds.length; i < n; i++) {\n      nodeId = mergeIds[i];\n      nodeAttrs = nodesAttrs[nodeId];\n      nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n    }\n\n    return nodesAttrs;\n  },\n  getEventTarget: function (evt, opt = {}) {\n    // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n    // It holds the element when a touchstart triggered.\n    const {\n      target,\n      type,\n      clientX = 0,\n      clientY = 0\n    } = evt;\n\n    if (opt.fromPoint || type === 'touchmove' || type === 'touchend') {\n      return document.elementFromPoint(clientX, clientY);\n    }\n\n    return target;\n  },\n  // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n  // unless `attrs` parameter was passed.\n  updateDOMSubtreeAttributes: function (rootNode, attrs, opt) {\n    opt || (opt = {});\n    opt.rootBBox || (opt.rootBBox = Rect());\n    opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n    // Cache table for query results and bounding box calculation.\n    // Note that `selectorCache` needs to be invalidated for all\n    // `updateAttributes` calls, as the selectors might pointing\n    // to nodes designated by an attribute or elements dynamically\n    // created.\n\n    var selectorCache = {};\n    var bboxCache = {};\n    var relativeItems = [];\n    var relativeRefItems = [];\n    var item, node, nodeAttrs, nodeData, processedAttrs;\n    var roAttrs = opt.roAttributes;\n    var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors); // `nodesAttrs` are different from all attributes, when\n    // rendering only  attributes sent to this method.\n\n    var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;\n\n    for (var nodeId in nodesAttrs) {\n      nodeData = nodesAttrs[nodeId];\n      nodeAttrs = nodeData.attributes;\n      node = nodeData.node;\n      processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n      if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n        // Set all the normal attributes right on the SVG/HTML element.\n        this.setNodeAttributes(node, processedAttrs.normal);\n      } else {\n        var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n        var refSelector = nodeAllAttrs && nodeAttrs.ref === undefined ? nodeAllAttrs.ref : nodeAttrs.ref;\n        var refNode;\n\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n\n          if (!refNode) {\n            throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n          }\n        } else {\n          refNode = null;\n        }\n\n        item = {\n          node: node,\n          refNode: refNode,\n          processedAttributes: processedAttrs,\n          allAttributes: nodeAllAttrs\n        };\n\n        if (refNode) {\n          // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n          var itemIndex = relativeRefItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n\n          if (itemIndex > -1) {\n            relativeRefItems.splice(itemIndex, 0, item);\n          } else {\n            relativeRefItems.push(item);\n          }\n        } else {\n          // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n          // The order of no-ref-items is not specified/important.\n          relativeItems.push(item);\n        }\n      }\n    }\n\n    relativeItems.push(...relativeRefItems);\n    var rotatableMatrix;\n\n    for (var i = 0, n = relativeItems.length; i < n; i++) {\n      item = relativeItems[i];\n      node = item.node;\n      refNode = item.refNode; // Find the reference element bounding box. If no reference was provided, we\n      // use the optional bounding box.\n\n      var vRotatable = V(opt.rotatableNode);\n      var refNodeId = refNode ? V.ensureId(refNode) : '';\n      var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n      var unrotatedRefBBox = bboxCache[refNodeId];\n\n      if (!unrotatedRefBBox) {\n        // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n        // or to the root `<g>` element if no rotatable group present if reference node present.\n        // Uses the bounding box provided.\n        var transformationTarget = isRefNodeRotatable ? vRotatable : rootNode;\n        unrotatedRefBBox = bboxCache[refNodeId] = refNode ? V(refNode).getBBox({\n          target: transformationTarget\n        }) : opt.rootBBox;\n      }\n\n      if (roAttrs) {\n        // if there was a special attribute affecting the position amongst passed-in attributes\n        // we have to merge it with the rest of the element's attributes as they are necessary\n        // to update the position relatively (i.e `ref-x` && 'ref-dx')\n        processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n        this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n\n      var refBBox = unrotatedRefBBox;\n\n      if (isRefNodeRotatable && !vRotatable.contains(node)) {\n        // if the referenced node is inside the rotatable group while the updated node is outside,\n        // we need to take the rotatable node transformation into account\n        if (!rotatableMatrix) rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform'));\n        refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n      }\n\n      this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n    }\n  },\n  mergeProcessedAttributes: function (processedAttrs, roProcessedAttrs) {\n    processedAttrs.set || (processedAttrs.set = {});\n    processedAttrs.position || (processedAttrs.position = {});\n    processedAttrs.offset || (processedAttrs.offset = {});\n    assign(processedAttrs.set, roProcessedAttrs.set);\n    assign(processedAttrs.position, roProcessedAttrs.position);\n    assign(processedAttrs.offset, roProcessedAttrs.offset); // Handle also the special transform property.\n\n    var transform = processedAttrs.normal && processedAttrs.normal.transform;\n\n    if (transform !== undefined && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n\n    processedAttrs.normal = roProcessedAttrs.normal;\n  },\n  onRemove: function () {\n    this.removeTools();\n    this.removeHighlighters();\n  },\n  _toolsView: null,\n  hasTools: function (name) {\n    var toolsView = this._toolsView;\n    if (!toolsView) return false;\n    if (!name) return true;\n    return toolsView.getName() === name;\n  },\n  addTools: function (toolsView) {\n    this.removeTools();\n\n    if (toolsView) {\n      this._toolsView = toolsView;\n      toolsView.configure({\n        relatedView: this\n      });\n      toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n    }\n\n    return this;\n  },\n  updateTools: function (opt) {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.update(opt);\n    return this;\n  },\n  removeTools: function () {\n    var toolsView = this._toolsView;\n\n    if (toolsView) {\n      toolsView.remove();\n      this._toolsView = null;\n    }\n\n    return this;\n  },\n  hideTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.hide();\n    return this;\n  },\n  showTools: function () {\n    var toolsView = this._toolsView;\n    if (toolsView) toolsView.show();\n    return this;\n  },\n  onToolEvent: function (event) {\n    switch (event) {\n      case 'remove':\n        this.removeTools();\n        break;\n\n      case 'hide':\n        this.hideTools();\n        break;\n\n      case 'show':\n        this.showTools();\n        break;\n    }\n  },\n  removeHighlighters: function () {\n    HighlighterView.remove(this);\n  },\n  updateHighlighters: function (dirty = false) {\n    HighlighterView.update(this, null, dirty);\n  },\n  transformHighlighters: function () {\n    HighlighterView.transform(this);\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n  // Interaction is handled by the paper and delegated to the view in interest.\n  // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n  // If necessary, real coordinates can be obtained from the `evt` event object.\n  // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\n  // i.e. `joint.dia.Element` and `joint.dia.Link`.\n  pointerdblclick: function (evt, x, y) {\n    this.notify('cell:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    this.notify('cell:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    this.notify('cell:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      graph\n    } = model;\n\n    if (graph) {\n      model.startBatch('pointer');\n      this.eventData(evt, {\n        graph\n      });\n    }\n\n    this.notify('cell:pointerdown', evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    this.notify('cell:pointermove', evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    const {\n      graph\n    } = this.eventData(evt);\n    this.notify('cell:pointerup', evt, x, y);\n\n    if (graph) {\n      // we don't want to trigger event on model as model doesn't\n      // need to be member of collection anymore (remove)\n      graph.stopBatch('pointer', {\n        cell: this.model\n      });\n    }\n  },\n  mouseover: function (evt) {\n    this.notify('cell:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    this.notify('cell:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    this.notify('cell:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    this.notify('cell:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    this.notify('cell:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    this.notify(eventName, evt, x, y);\n  },\n  onmagnet: function () {// noop\n  },\n  magnetpointerdblclick: function () {// noop\n  },\n  magnetcontextmenu: function () {// noop\n  },\n\n  checkMouseleave(evt) {\n    const {\n      paper\n    } = this;\n\n    if (paper.isAsync()) {\n      // Do the updates of the current view synchronously now\n      paper.dumpView(this);\n    }\n\n    const target = this.getEventTarget(evt, {\n      fromPoint: true\n    });\n    const view = paper.findView(target);\n    if (view === this) return; // Leaving the current view\n\n    this.mouseleave(evt);\n    if (!view) return; // Entering another view\n\n    view.mouseenter(evt);\n  },\n\n  setInteractivity: function (value) {\n    this.options.interactive = value;\n  }\n}, {\n  Highlighting: HighlightingTypes,\n  addPresentationAttributes: function (presentationAttributes) {\n    return merge({}, this.prototype.presentationAttributes, presentationAttributes, function (a, b) {\n      if (!a || !b) return;\n      if (typeof a === 'string') a = [a];\n      if (typeof b === 'string') b = [b];\n      if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n    });\n  }\n});","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/dia/CellView.mjs"],"names":["config","View","assign","guid","omit","parseDOMJSON","isFunction","isObject","isPlainObject","isBoolean","isEmpty","isString","toKebabCase","sortedIndex","merge","uniq","Point","Rect","V","$","HighlighterView","HighlightingTypes","DEFAULT","EMBEDDING","CONNECTING","MAGNET_AVAILABILITY","ELEMENT_AVAILABILITY","CellView","extend","tagName","svgElement","selector","metrics","className","classNames","type","model","get","toLowerCase","split","forEach","value","index","list","push","slice","join","_presentationAttributes","_flags","setFlags","flags","attributes","shift","i","n","label","presentationAttributes","attribute","hasOwnProperty","labels","Array","isArray","length","flag","initFlag","Error","hasFlag","getFlag","removeFlag","cell","id","constructor","options","call","initialize","prototype","apply","arguments","cleanNodesCache","$el","data","startListening","listenTo","onAttributesChange","opt","getChangeFlag","updateHandled","dirty","tool","async","requestUpdate","paper","requestViewUpdate","UPDATE_PRIORITY","markup","root","doc","selectors","groups","groupSelectors","group","rootSelector","fragment","can","feature","interactive","findBySelector","el","nodes","useCSSSelectors","find","toArray","notify","eventName","args","trigger","concat","getBBox","bbox","useModelGeometry","angle","getNodeBBox","localToPaperRect","magnet","rect","getNodeBoundingRect","magnetMatrix","getNodeMatrix","translateMatrix","getRootTranslateMatrix","rotateMatrix","getRootRotateMatrix","transformRect","multiply","getNodeUnrotatedBBox","position","mt","createSVGMatrix","translate","x","y","mr","cx","width","cy","height","rotate","_notifyHighlight","rootNode","node","partial","undefined","embedding","connecting","magnetAvailability","elementAvailability","highlight","unhighlight","findMagnet","magnetAttribute","getAttribute","isMagnetRoot","parentNode","findProxyNode","nodeSelector","proxyNode","getSelector","prevSelector","nthChild","getLinkEnd","port","findAttribute","end","hasPort","customizeLinkEnd","link","endType","connectionStrategy","strategy","getMagnetFromLinkEnd","isElement","findPortNode","getAttributeDefinition","attrName","setNodeAttributes","attrs","SVGElement","attr","processNodeAttributes","attrVal","def","normalAttrs","setAttrs","positionAttrs","offsetAttrs","relatives","qualify","set","offset","raw","normal","updateRelativeAttributes","refBBox","rawAttrs","nodeAttrs","setResult","clone","HTMLElement","nodeTransform","transform","nodeMatrix","transformStringToMatrix","nodePosition","e","f","sx","sy","translation","nodeScale","getNodeScale","scalableNode","positioned","scale","offseted","nodeBoundingRect","nodeBBox","round","setAttribute","matrixToTransformString","contains","nodeCache","ensureId","getNodeData","boundingRect","target","rotatableNode","getTransformToElement","getNodeShape","geometryShape","toGeometryShape","isNodeConnection","isLink","findNodesAttributes","selectorCache","nodeId","nodesAttrs","mergeIds","selected","unique","prevNodeAttrs","array","selectedLength","unshift","sortIndex","splice","reverse","getEventTarget","evt","clientX","clientY","fromPoint","document","elementFromPoint","updateDOMSubtreeAttributes","rootBBox","bboxCache","relativeItems","relativeRefItems","item","nodeData","processedAttrs","roAttrs","roAttributes","nodesAllAttrs","nodeAllAttrs","refSelector","ref","refNode","processedAttributes","allAttributes","itemIndex","findIndex","rotatableMatrix","vRotatable","refNodeId","isRefNodeRotatable","unrotatedRefBBox","transformationTarget","mergeProcessedAttributes","roProcessedAttrs","onRemove","removeTools","removeHighlighters","_toolsView","hasTools","name","toolsView","getName","addTools","configure","relatedView","onToolEvent","bind","updateTools","update","remove","hideTools","hide","showTools","show","event","updateHighlighters","transformHighlighters","pointerdblclick","pointerclick","contextmenu","pointerdown","graph","startBatch","eventData","pointermove","pointerup","stopBatch","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","onmagnet","magnetpointerdblclick","magnetcontextmenu","checkMouseleave","isAsync","dumpView","view","findView","setInteractivity","Highlighting","addPresentationAttributes","a","b"],"mappings":"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","sourcesContent":["import { config } from '../config/index.mjs';\nimport { View } from '../mvc/index.mjs';\nimport {\n    assign,\n    guid,\n    omit,\n    parseDOMJSON,\n    isFunction,\n    isObject,\n    isPlainObject,\n    isBoolean,\n    isEmpty,\n    isString,\n    toKebabCase,\n    sortedIndex,\n    merge,\n    uniq\n} from '../util/index.mjs';\nimport { Point, Rect } from '../g/index.mjs';\nimport V from '../V/index.mjs';\nimport $ from 'jquery';\nimport { HighlighterView } from './HighlighterView.mjs';\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nexport const CellView = View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = this.presentationAttributes;\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = this.initFlag;\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || guid(this);\n\n        View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        // Store reference to this to the <g> DOM element so that the view is accessible through the DOM tree.\n        this.$el.data('view', this);\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = parseDOMJSON(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('vertexMove')`, `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = isFunction(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return (isObject(interactive) && interactive[feature] !== false) ||\n            (isBoolean(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        root || (root = this.el);\n        selectors || (selectors = this.selectors);\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (config.useCSSSelectors) return $(root).find(selector).toArray();\n\n        return [];\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        var rotateMatrix = this.getRootRotateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix));\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return V.transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = V.createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = V.createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            [node = rootNode] = this.findBySelector(el);\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const [proxyNode] = this.findBySelector(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = '> ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = V(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        var model = this.model;\n        var id = model.id;\n        var port = this.findAttribute('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        var selector = magnet.getAttribute('joint-selector');\n\n        var end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (port != null) {\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var root = this.el;\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || root;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findBySelector(selector, root, this.selectors)[0];\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!isEmpty(attrs)) {\n            if (node instanceof SVGElement) {\n                V(node).attr(attrs);\n            } else {\n                $(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        // divide the attributes between normal and special\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            attrVal = attrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def && (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, attrs))) {\n                if (isString(def.set)) {\n                    normalAttrs || (normalAttrs = {});\n                    normalAttrs[def.set] = attrVal;\n                }\n                if (attrVal !== null) {\n                    relatives.push(attrName, def);\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[toKebabCase(attrName)] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if (isFunction(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if (isFunction(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: attrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var rawAttrs = attrs.raw || {};\n        var nodeAttrs = attrs.normal || {};\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = setAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n            if (isObject(setResult)) {\n                assign(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = V.transformStringToMatrix(nodeTransform);\n        var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = omit(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = positionAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, rawAttrs);\n            if (translation) {\n                nodePosition.offset(Point(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = V.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = offsetAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, rawAttrs);\n                    if (translation) {\n                        nodePosition.offset(Point(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', V.matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = V.ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = V(magnet).getBBox();\n        return new Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            var target = this.rotatableNode || this.el;\n            metrics.magnetMatrix = V(magnet).getTransformToElement(target);\n        }\n        return V.createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = V(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!isPlainObject(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = V.ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = sortedIndex(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n        // It holds the element when a touchstart triggered.\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (opt.fromPoint || type === 'touchmove' || type === 'touchend') {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = Rect());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, processedAttrs.normal);\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        var rotatableMatrix;\n        for (var i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            var vRotatable = V(opt.rotatableNode);\n            var refNodeId = refNode ? V.ensureId(refNode) : '';\n            var isRefNodeRotatable = !!vRotatable && !!refNode && vRotatable.contains(refNode);\n            var unrotatedRefBBox = bboxCache[refNodeId];\n            if (!unrotatedRefBBox) {\n                // Get the bounding box of the reference element relative to the `rotatable` `<g>` (without rotation)\n                // or to the root `<g>` element if no rotatable group present if reference node present.\n                // Uses the bounding box provided.\n                var transformationTarget = (isRefNodeRotatable) ? vRotatable : rootNode;\n                unrotatedRefBBox = bboxCache[refNodeId] = (refNode)\n                    ? V(refNode).getBBox({ target: transformationTarget })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            var refBBox = unrotatedRefBBox;\n            if (isRefNodeRotatable && !vRotatable.contains(node)) {\n                // if the referenced node is inside the rotatable group while the updated node is outside,\n                // we need to take the rotatable node transformation into account\n                if (!rotatableMatrix) rotatableMatrix = V.transformStringToMatrix(vRotatable.attr('transform'));\n                refBBox = V.transformRect(unrotatedRefBBox, rotatableMatrix);\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        assign(processedAttrs.set, roProcessedAttrs.set);\n        assign(processedAttrs.position, roProcessedAttrs.position);\n        assign(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overriden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper } = this;\n        if (paper.isAsync()) {\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    }\n}, {\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return merge({}, this.prototype.presentationAttributes, presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));\n        });\n    }\n});\n"]},"metadata":{},"sourceType":"module"}