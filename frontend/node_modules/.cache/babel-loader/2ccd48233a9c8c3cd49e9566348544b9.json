{"ast":null,"code":"// Geometry library.\n// -----------------\n// Declare shorthands to the most used math functions.\nconst math = Math;\nconst abs = math.abs;\nconst cos = math.cos;\nconst sin = math.sin;\nconst sqrt = math.sqrt;\nconst min = math.min;\nconst max = math.max;\nconst atan2 = math.atan2;\nconst round = math.round;\nconst floor = math.floor;\nconst PI = math.PI;\nconst pow = math.pow;\nexport const bezier = {\n  // Cubic Bezier curve path through points.\n  // @deprecated\n  // @param {array} points Array of points through which the smooth line will go.\n  // @return {array} SVG Path commands as an array\n  curveThroughPoints: function (points) {\n    console.warn('deprecated');\n    return new Path(Curve.throughPoints(points)).serialize();\n  },\n  // Get open-ended Bezier Spline Control Points.\n  // @deprecated\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  getCurveControlPoints: function (knots) {\n    console.warn('deprecated');\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i; // Special case: Bezier curve should be a straight line.\n\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = this.getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = this.getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  },\n  // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n  // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts t and returns 2 curves.\n  getCurveDivider: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function divideCurve(t) {\n      var divided = curve.divide(t);\n      return [{\n        p0: divided[0].start,\n        p1: divided[0].controlPoint1,\n        p2: divided[0].controlPoint2,\n        p3: divided[0].end\n      }, {\n        p0: divided[1].start,\n        p1: divided[1].controlPoint1,\n        p2: divided[1].controlPoint2,\n        p3: divided[1].end\n      }];\n    };\n  },\n  // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @deprecated\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n  getFirstControlPoints: function (rhs) {\n    console.warn('deprecated');\n    var n = rhs.length; // `x` is a solution vector.\n\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  },\n  // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n  // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n  // which corresponds to that point.\n  // @deprecated\n  // @param control points (start, control start, control end, end)\n  // @return a function that accepts a point and returns t.\n  getInversionSolver: function (p0, p1, p2, p3) {\n    console.warn('deprecated');\n    var curve = new Curve(p0, p1, p2, p3);\n    return function solveInversion(p) {\n      return curve.closestPointT(p);\n    };\n  }\n};\nexport const Curve = function (p1, p2, p3, p4) {\n  if (!(this instanceof Curve)) {\n    return new Curve(p1, p2, p3, p4);\n  }\n\n  if (p1 instanceof Curve) {\n    return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n  }\n\n  this.start = new Point(p1);\n  this.controlPoint1 = new Point(p2);\n  this.controlPoint2 = new Point(p3);\n  this.end = new Point(p4);\n}; // Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\n\nCurve.throughPoints = function () {\n  // Get open-ended Bezier Spline Control Points.\n  // @param knots Input Knot Bezier spline points (At least two points!).\n  // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n  // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n  function getCurveControlPoints(knots) {\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1;\n    var i; // Special case: Bezier curve should be a straight line.\n\n    if (n == 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (i = 1; i < n - 1; i++) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (i = 1; i < n - 1; ++i) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (i = 0; i < n; i++) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  } // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n  // @param rhs Right hand side vector.\n  // @return Solution vector.\n\n\n  function getFirstControlPoints(rhs) {\n    var n = rhs.length; // `x` is a solution vector.\n\n    var x = [];\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i++) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (i = 1; i < n; i++) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  }\n\n  return function (points) {\n    if (!points || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    var controlPoints = getCurveControlPoints(points);\n    var curves = [];\n    var n = controlPoints[0].length;\n\n    for (var i = 0; i < n; i++) {\n      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  };\n}();\n\nCurve.prototype = {\n  // Returns a bbox that tightly envelops the curve.\n  bbox: function () {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end;\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = controlPoint1.x;\n    var y1 = controlPoint1.y;\n    var x2 = controlPoint2.x;\n    var y2 = controlPoint2.y;\n    var x3 = end.x;\n    var y3 = end.y;\n    var points = new Array(); // local extremes\n\n    var tvalues = new Array(); // t values of local extremes\n\n    var bounds = [new Array(), new Array()];\n    var a, b, c, t;\n    var t1, t2;\n    var b2ac, sqrtb2ac;\n\n    for (var i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (abs(a) < 1e-12) {\n        // Numerical robustness\n        if (abs(b) < 1e-12) {\n          // Numerical robustness\n          continue;\n        }\n\n        t = -c / b;\n        if (0 < t && t < 1) tvalues.push(t);\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) tvalues.push(t2);\n    }\n\n    var j = tvalues.length;\n    var jlen = j;\n    var mt;\n    var x, y;\n\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    var left = min.apply(null, bounds[0]);\n    var top = min.apply(null, bounds[1]);\n    var right = max.apply(null, bounds[0]);\n    var bottom = max.apply(null, bounds[1]);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  clone: function () {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  },\n  // Returns the point on the curve closest to point `p`\n  closestPoint: function (p, opt) {\n    return this.pointAtT(this.closestPointT(p, opt));\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (!cpLength) return 0;\n    var length = this.length(localOpt);\n    if (length === 0) return 0;\n    return cpLength / length;\n  },\n  // Returns `t` of the point on the curve closest to point `p`\n  closestPointT: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // does not use localOpt\n    // identify the subdivision that contains the point:\n\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\n    var investigatedSubdivisionEndT;\n    var distFromStart; // distance of point from start of baseline\n\n    var distFromEnd; // distance of point from end of baseline\n\n    var chordLength; // distance between start and end of the subdivision\n\n    var minSumDist; // lowest observed sum of the two distances\n\n    var n = subdivisions.length;\n    var subdivisionSize = n ? 1 / n : 0;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      var startDist = currentSubdivision.start.distance(p);\n      var endDist = currentSubdivision.end.distance(p);\n      var sumDist = startDist + endDist; // check that the point is closest to current subdivision and not any other\n\n      if (!minSumDist || sumDist < minSumDist) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = i * subdivisionSize;\n        investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n        minSumDist = sumDist;\n      }\n    }\n\n    var precisionRatio = pow(10, -precision); // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;\n      var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n      var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance; // do we stop now?\n\n      if (hasRequiredPrecision || hasMinimalDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var startDist1 = divided[0].start.distance(p);\n      var endDist1 = divided[0].end.distance(p);\n      var sumDist1 = startDist1 + endDist1;\n      var startDist2 = divided[1].start.distance(p);\n      var endDist2 = divided[1].end.distance(p);\n      var sumDist2 = startDist2 + endDist2;\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  },\n  closestPointTangent: function (p, opt) {\n    return this.tangentAtT(this.closestPointT(p, opt));\n  },\n  // Returns `true` if the area surrounded by the curve contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open curves (always imagines a closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polyline = this.toPolyline(opt);\n    return polyline.containsPoint(p);\n  },\n  // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // For a function that uses `t`, use Curve.divideAtT().\n  divideAt: function (ratio, opt) {\n    if (ratio <= 0) return this.divideAtT(0);\n    if (ratio >= 1) return this.divideAtT(1);\n    var t = this.tAt(ratio, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.divideAtT(t);\n  },\n  // Divides the curve into two at point defined by `t` between 0 and 1.\n  // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n  // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n  divideAtT: function (t) {\n    var start = this.start;\n    var controlPoint1 = this.controlPoint1;\n    var controlPoint2 = this.controlPoint2;\n    var end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n\n    var dividerPoints = this.getSkeletonPoints(t);\n    var startControl1 = dividerPoints.startControlPoint1;\n    var startControl2 = dividerPoints.startControlPoint2;\n    var divider = dividerPoints.divider;\n    var dividerControl1 = dividerPoints.dividerControlPoint1;\n    var dividerControl2 = dividerPoints.dividerControlPoint2; // return array with two new curves\n\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  },\n  // Returns the distance between the curve's start and end points.\n  endpointDistance: function () {\n    return this.start.distance(this.end);\n  },\n  // Checks whether two curves are exactly the same.\n  equals: function (c) {\n    return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;\n  },\n  // Returns five helper points necessary for curve division.\n  getSkeletonPoints: function (t) {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n\n    var midpoint1 = new Line(start, control1).pointAt(t);\n    var midpoint2 = new Line(control1, control2).pointAt(t);\n    var midpoint3 = new Line(control2, end).pointAt(t);\n    var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    var divider = new Line(subControl1, subControl2).pointAt(t);\n    var output = {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divider,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n    return output;\n  },\n  // Returns a list of curves whose flattened length is better than `opt.precision`.\n  // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n  // (Observed difference is not real precision, but close enough as long as special cases are covered)\n  // (That is why skipping iteration 1 is important)\n  // As a rule of thumb, increasing `precision` by 1 requires two more division operations\n  // - Precision 0 (endpointDistance) - total of 2^0 - 1 = 0 operations (1 subdivision)\n  // - Precision 1 (<10% error) - total of 2^2 - 1 = 3 operations (4 subdivisions)\n  // - Precision 2 (<1% error) - total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n  // - Precision 3 (<0.1% error) - total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n  // - Precision 4 (<0.01% error) - total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n  // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n  getSubdivisions: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.subdivisions\n    // not using localOpt\n\n    var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n    if (precision === 0) return subdivisions;\n    var previousLength = this.endpointDistance();\n    var precisionRatio = pow(10, -precision); // recursively divide curve at `t = 0.5`\n    // until the difference between observed length at subsequent iterations is lower than precision\n\n    var iteration = 0;\n\n    while (true) {\n      iteration += 1; // divide all subdivisions\n\n      var newSubdivisions = [];\n      var numSubdivisions = subdivisions.length;\n\n      for (var i = 0; i < numSubdivisions; i++) {\n        var currentSubdivision = subdivisions[i];\n        var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n\n        newSubdivisions.push(divided[0], divided[1]);\n      } // measure new length\n\n\n      var length = 0;\n      var numNewSubdivisions = newSubdivisions.length;\n\n      for (var j = 0; j < numNewSubdivisions; j++) {\n        var currentNewSubdivision = newSubdivisions[j];\n        length += currentNewSubdivision.endpointDistance();\n      } // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n\n\n      var observedPrecisionRatio = length !== 0 ? (length - previousLength) / length : 0;\n\n      if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n        return newSubdivisions;\n      } // otherwise, set up for next iteration\n\n\n      subdivisions = newSubdivisions;\n      previousLength = length;\n    }\n  },\n  isDifferentiable: function () {\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n  length: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // not using localOpt\n\n    var length = 0;\n    var n = subdivisions.length;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      length += currentSubdivision.endpointDistance();\n    }\n\n    return length;\n  },\n  // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n  lengthAtT: function (t, opt) {\n    if (t <= 0) return 0;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.subdivisions\n    // not using localOpt\n\n    var subCurve = this.divide(t)[0];\n    var subCurveLength = subCurve.length({\n      precision: precision\n    });\n    return subCurveLength;\n  },\n  // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Mirrors Line.pointAt() function.\n  // For a function that tracks `t`, use Curve.pointAtT().\n  pointAt: function (ratio, opt) {\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    var t = this.tAt(ratio, opt);\n    return this.pointAtT(t);\n  },\n  // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  pointAtLength: function (length, opt) {\n    var t = this.tAtLength(length, opt);\n    return this.pointAtT(t);\n  },\n  // Returns the point at provided `t` between 0 and 1.\n  // `t` does not track distance along curve as it does in Line objects.\n  // Non-linear relationship, speeds up and slows down as curve warps!\n  // For linear length-based solution, use Curve.pointAt().\n  pointAtT: function (t) {\n    if (t <= 0) return this.start.clone();\n    if (t >= 1) return this.end.clone();\n    return this.getSkeletonPoints(t).divider;\n  },\n  // Default precision\n  PRECISION: 3,\n  round: function (precision) {\n    this.start.round(precision);\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    if (!this.isDifferentiable()) return null;\n    if (ratio < 0) ratio = 0;else if (ratio > 1) ratio = 1;\n    var t = this.tAt(ratio, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n  tangentAtLength: function (length, opt) {\n    if (!this.isDifferentiable()) return null;\n    var t = this.tAtLength(length, opt);\n    return this.tangentAtT(t);\n  },\n  // Returns a tangent line at requested `t`.\n  tangentAtT: function (t) {\n    if (!this.isDifferentiable()) return null;\n    if (t < 0) t = 0;else if (t > 1) t = 1;\n    var skeletonPoints = this.getSkeletonPoints(t);\n    var p1 = skeletonPoints.startControlPoint2;\n    var p2 = skeletonPoints.dividerControlPoint1;\n    var tangentStart = skeletonPoints.divider;\n    var tangentLine = new Line(p1, p2);\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  tAt: function (ratio, opt) {\n    if (ratio <= 0) return 0;\n    if (ratio >= 1) return 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    };\n    var curveLength = this.length(localOpt);\n    var length = curveLength * ratio;\n    return this.tAtLength(length, localOpt);\n  },\n  // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  // Uses `precision` to approximate length within `precision` (always underestimates)\n  // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n  // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n  // - Precision 0 (chooses one of the two endpoints) - 0 levels\n  // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n  // - Precision 2 (<1% error) - 3 levels\n  // - Precision 3 (<0.1% error) - 7 levels\n  // - Precision 4 (<0.01% error) - 15 levels\n  tAtLength: function (length, opt) {\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions;\n    var localOpt = {\n      precision: precision,\n      subdivisions: subdivisions\n    }; // identify the subdivision that contains the point at requested `length`:\n\n    var investigatedSubdivision;\n    var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n\n    var investigatedSubdivisionEndT; //var baseline; // straightened version of subdivision to investigate\n    //var baselinePoint; // point on the baseline that is the requested distance away from start\n\n    var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n\n    var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n\n    var l = 0; // length so far\n\n    var n = subdivisions.length;\n    var subdivisionSize = 1 / n;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var currentSubdivision = subdivisions[i];\n      var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n      if (length <= l + d) {\n        investigatedSubdivision = currentSubdivision;\n        investigatedSubdivisionStartT = index * subdivisionSize;\n        investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n        baselinePointDistFromStart = fromStart ? length - l : d + l - length;\n        baselinePointDistFromEnd = fromStart ? d + l - length : length - l;\n        break;\n      }\n\n      l += d;\n    }\n\n    if (!investigatedSubdivision) return fromStart ? 1 : 0; // length requested is out of range - return maximum t\n    // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n    var curveLength = this.length(localOpt);\n    var precisionRatio = pow(10, -precision); // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n\n    while (true) {\n      // check if we have reached required observed precision\n      var observedPrecisionRatio;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n      observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;\n      if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT; // otherwise, set up for next iteration\n\n      var newBaselinePointDistFromStart;\n      var newBaselinePointDistFromEnd;\n      var divided = investigatedSubdivision.divide(0.5);\n      subdivisionSize /= 2;\n      var baseline1Length = divided[0].endpointDistance();\n      var baseline2Length = divided[1].endpointDistance();\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        // point at requested length is inside divided[0]\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        // point at requested length is inside divided[1]\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  },\n  // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPoints: function (opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n\n    var subdivisions = opt.subdivisions === undefined ? this.getSubdivisions({\n      precision: precision\n    }) : opt.subdivisions; // not using localOpt\n\n    var points = [subdivisions[0].start.clone()];\n    var n = subdivisions.length;\n\n    for (var i = 0; i < n; i++) {\n      var currentSubdivision = subdivisions[i];\n      points.push(currentSubdivision.end.clone());\n    }\n\n    return points;\n  },\n  // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n  // Flattened length is no more than 10^(-precision) away from real curve length.\n  toPolyline: function (opt) {\n    return new Polyline(this.toPoints(opt));\n  },\n  toString: function () {\n    return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nCurve.prototype.divide = Curve.prototype.divideAtT;\nexport const Ellipse = function (c, a, b) {\n  if (!(this instanceof Ellipse)) {\n    return new Ellipse(c, a, b);\n  }\n\n  if (c instanceof Ellipse) {\n    return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n  }\n\n  c = new Point(c);\n  this.x = c.x;\n  this.y = c.y;\n  this.a = a;\n  this.b = b;\n};\n\nEllipse.fromRect = function (rect) {\n  rect = new Rect(rect);\n  return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n  bbox: function () {\n    return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n  },\n\n  /**\n   * @returns {g.Point}\n   */\n  center: function () {\n    return new Point(this.x, this.y);\n  },\n  clone: function () {\n    return new Ellipse(this);\n  },\n\n  /**\n   * @param {g.Point} p\n   * @returns {boolean}\n   */\n  containsPoint: function (p) {\n    return this.normalizedDistance(p) <= 1;\n  },\n  equals: function (ellipse) {\n    return !!ellipse && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  },\n  // inflate by dx and dy\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n\n    if (dy === undefined) {\n      dy = dx;\n    }\n\n    this.a += 2 * dx;\n    this.b += 2 * dy;\n    return this;\n  },\n  intersectionWithLine: function (line) {\n    var intersections = [];\n    var a1 = line.start;\n    var a2 = line.end;\n    var rx = this.a;\n    var ry = this.b;\n    var dir = line.vector();\n    var diff = a1.difference(new Point(this));\n    var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    var a = dir.dot(mDir);\n    var b = dir.dot(mDiff);\n    var c = diff.dot(mDiff) - 1.0;\n    var d = b * b - a * c;\n\n    if (d < 0) {\n      return null;\n    } else if (d > 0) {\n      var root = sqrt(d);\n      var ta = (-b - root) / a;\n      var tb = (-b + root) / a;\n\n      if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n        // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n        return null;\n      } else {\n        if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n        if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      var t = -b / a;\n\n      if (0 <= t && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n\n    return intersections;\n  },\n  // Find point on me where line from my center to\n  // point p intersects my boundary.\n  // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    if (angle) p.rotate(new Point(this.x, this.y), angle);\n    var dx = p.x - this.x;\n    var dy = p.y - this.y;\n    var result;\n\n    if (dx === 0) {\n      result = this.bbox().pointNearestToPoint(p);\n      if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n      return result;\n    }\n\n    var m = dy / dx;\n    var mSquared = m * m;\n    var aSquared = this.a * this.a;\n    var bSquared = this.b * this.b;\n    var x = sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    var y = m * x;\n    result = new Point(this.x + x, this.y + y);\n    if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n    return result;\n  },\n\n  /**\n   * @param {g.Point} point\n   * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n   */\n  normalizedDistance: function (point) {\n    var x0 = point.x;\n    var y0 = point.y;\n    var a = this.a;\n    var b = this.b;\n    var x = this.x;\n    var y = this.y;\n    return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.a = round(this.a * f) / f;\n    this.b = round(this.b * f) / f;\n    return this;\n  },\n\n  /** Compute angle between tangent and x axis\n   * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n   * @returns {number} angle between tangent and x axis\n   */\n  tangentTheta: function (p) {\n    var refPointDelta = 30;\n    var x0 = p.x;\n    var y0 = p.y;\n    var a = this.a;\n    var b = this.b;\n    var center = this.bbox().center();\n    var m = center.x;\n    var n = center.y;\n    var q1 = x0 > center.x + a / 2;\n    var q3 = x0 < center.x - a / 2;\n    var y, x;\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;\n    }\n\n    return new Point(x, y).theta(p);\n  },\n  toString: function () {\n    return new Point(this.x, this.y).toString() + ' ' + this.a + ' ' + this.b;\n  }\n};\nexport const Line = function (p1, p2) {\n  if (!(this instanceof Line)) {\n    return new Line(p1, p2);\n  }\n\n  if (p1 instanceof Line) {\n    return new Line(p1.start, p1.end);\n  }\n\n  this.start = new Point(p1);\n  this.end = new Point(p2);\n};\nLine.prototype = {\n  // @returns the angle of incline of the line.\n  angle: function () {\n    var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n    return this.start.angleBetween(this.end, horizontalPoint);\n  },\n  bbox: function () {\n    var left = min(this.start.x, this.end.x);\n    var top = min(this.start.y, this.end.y);\n    var right = max(this.start.x, this.end.x);\n    var bottom = max(this.start.y, this.end.y);\n    return new Rect(left, top, right - left, bottom - top);\n  },\n  // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n  // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n  bearing: function () {\n    var lat1 = toRad(this.start.y);\n    var lat2 = toRad(this.end.y);\n    var lon1 = this.start.x;\n    var lon2 = this.end.x;\n    var dLon = toRad(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = toDeg(atan2(y, x));\n    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    var index = brng - 22.5;\n    if (index < 0) index += 360;\n    index = parseInt(index / 45);\n    return bearings[index];\n  },\n  clone: function () {\n    return new Line(this.start, this.end);\n  },\n  // @return {point} the closest point on the line to point `p`\n  closestPoint: function (p) {\n    return this.pointAt(this.closestPointNormalizedLength(p));\n  },\n  closestPointLength: function (p) {\n    return this.closestPointNormalizedLength(p) * this.length();\n  },\n  // @return {number} the normalized length of the closest point on the line to point `p`\n  closestPointNormalizedLength: function (p) {\n    var product = this.vector().dot(new Line(this.start, p).vector());\n    var cpNormalizedLength = min(1, max(0, product / this.squaredLength())); // cpNormalizedLength returns `NaN` if this line has zero length\n    // we can work with that - if `NaN`, return 0\n\n    if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n    // (`NaN` is the only value that is not equal to itself)\n\n    return cpNormalizedLength;\n  },\n  closestPointTangent: function (p) {\n    return this.tangentAt(this.closestPointNormalizedLength(p));\n  },\n  // Returns `true` if the point lies on the line.\n  containsPoint: function (p) {\n    var start = this.start;\n    var end = this.end;\n    if (start.cross(p, end) !== 0) return false; // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n    var length = this.length();\n    if (new Line(start, p).length() > length) return false;\n    if (new Line(p, end).length() > length) return false; // else: `p` lies between start and end of the line\n\n    return true;\n  },\n  // Divides the line into two at requested `ratio` between 0 and 1.\n  divideAt: function (ratio) {\n    var dividerPoint = this.pointAt(ratio); // return array with two lines\n\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  // Divides the line into two at requested `length`.\n  divideAtLength: function (length) {\n    var dividerPoint = this.pointAtLength(length); // return array with two new lines\n\n    return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n  },\n  equals: function (l) {\n    return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n  },\n  // @return {point} Point where I'm intersecting a line.\n  // @return [point] Points where I'm intersecting a rectangle.\n  // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n  intersect: function (shape, opt) {\n    if (shape instanceof Line || shape instanceof Rect || shape instanceof Polyline || shape instanceof Ellipse || shape instanceof Path) {\n      var intersection = shape.intersectionWithLine(this, opt); // Backwards compatibility\n\n      if (intersection && shape instanceof Line) {\n        intersection = intersection[0];\n      }\n\n      return intersection;\n    }\n\n    return null;\n  },\n  intersectionWithLine: function (line) {\n    var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n    var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n    var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n    var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n    var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n\n    if (det === 0 || alpha * det < 0 || beta * det < 0) {\n      // No intersection found.\n      return null;\n    }\n\n    if (det > 0) {\n      if (alpha > det || beta > det) {\n        return null;\n      }\n    } else {\n      if (alpha < det || beta < det) {\n        return null;\n      }\n    }\n\n    return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];\n  },\n  isDifferentiable: function () {\n    return !this.start.equals(this.end);\n  },\n  // @return {double} length of the line\n  length: function () {\n    return sqrt(this.squaredLength());\n  },\n  // @return {point} my midpoint\n  midpoint: function () {\n    return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n  },\n  parallel: function (distance) {\n    const l = this.clone();\n    if (!this.isDifferentiable()) return l;\n    const {\n      start,\n      end\n    } = l;\n    const eRef = start.clone().rotate(end, 270);\n    const sRef = end.clone().rotate(start, 90);\n    start.move(sRef, distance);\n    end.move(eRef, distance);\n    return l;\n  },\n  // @return {point} my point at 't' <0,1>\n  pointAt: function (t) {\n    var start = this.start;\n    var end = this.end;\n    if (t <= 0) return start.clone();\n    if (t >= 1) return end.clone();\n    return start.lerp(end, t);\n  },\n  pointAtLength: function (length) {\n    var start = this.start;\n    var end = this.end;\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var lineLength = this.length();\n    if (length >= lineLength) return fromStart ? end.clone() : start.clone();\n    return this.pointAt((fromStart ? length : lineLength - length) / lineLength);\n  },\n  // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n  pointOffset: function (p) {\n    // Find the sign of the determinant of vectors (start,end), where p is the query point.\n    p = new Point(p);\n    var start = this.start;\n    var end = this.end;\n    var determinant = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);\n    return determinant / this.length();\n  },\n  rotate: function (origin, angle) {\n    this.start.rotate(origin, angle);\n    this.end.rotate(origin, angle);\n    return this;\n  },\n  round: function (precision) {\n    this.start.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  // @return {number} scale the line so that it has the requested length\n  setLength: function (length) {\n    var currentLength = this.length();\n    if (!currentLength) return this;\n    var scaleFactor = length / currentLength;\n    return this.scale(scaleFactor, scaleFactor, this.start);\n  },\n  // @return {integer} length without sqrt\n  // @note for applications where the exact length is not necessary (e.g. compare only)\n  squaredLength: function () {\n    var x0 = this.start.x;\n    var y0 = this.start.y;\n    var x1 = this.end.x;\n    var y1 = this.end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n  },\n  tangentAt: function (t) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  tangentAtLength: function (length) {\n    if (!this.isDifferentiable()) return null;\n    var start = this.start;\n    var end = this.end;\n    var tangentStart = this.pointAtLength(length);\n    var tangentLine = new Line(start, end);\n    tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n    return tangentLine;\n  },\n  toString: function () {\n    return this.start.toString() + ' ' + this.end.toString();\n  },\n  serialize: function () {\n    return this.start.serialize() + ' ' + this.end.serialize();\n  },\n  translate: function (tx, ty) {\n    this.start.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  },\n  // @return vector {point} of the line\n  vector: function () {\n    return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n  }\n}; // For backwards compatibility:\n\nLine.prototype.intersection = Line.prototype.intersect; // Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\nexport const Path = function (arg) {\n  if (!(this instanceof Path)) {\n    return new Path(arg);\n  }\n\n  if (typeof arg === 'string') {\n    // create from a path data string\n    return new Path.parse(arg);\n  }\n\n  this.segments = [];\n  var i;\n  var n;\n\n  if (!arg) {// don't do anything\n  } else if (Array.isArray(arg) && arg.length !== 0) {\n    // if arg is a non-empty array\n    // flatten one level deep\n    // so we can chain arbitrary Path.createSegment results\n    arg = arg.reduce(function (acc, val) {\n      return acc.concat(val);\n    }, []);\n    n = arg.length;\n\n    if (arg[0].isSegment) {\n      // create from an array of segments\n      for (i = 0; i < n; i++) {\n        var segment = arg[i];\n        this.appendSegment(segment);\n      }\n    } else {\n      // create from an array of Curves and/or Lines\n      var previousObj = null;\n\n      for (i = 0; i < n; i++) {\n        var obj = arg[i];\n\n        if (!(obj instanceof Line || obj instanceof Curve)) {\n          throw new Error('Cannot construct a path segment from the provided object.');\n        }\n\n        if (i === 0) this.appendSegment(Path.createSegment('M', obj.start)); // if objects do not link up, moveto segments are inserted to cover the gaps\n\n        if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n        if (obj instanceof Line) {\n          this.appendSegment(Path.createSegment('L', obj.end));\n        } else if (obj instanceof Curve) {\n          this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n        }\n\n        previousObj = obj;\n      }\n    }\n  } else if (arg.isSegment) {\n    // create from a single segment\n    this.appendSegment(arg);\n  } else if (arg instanceof Line) {\n    // create from a single Line\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('L', arg.end));\n  } else if (arg instanceof Curve) {\n    // create from a single Curve\n    this.appendSegment(Path.createSegment('M', arg.start));\n    this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n  } else if (arg instanceof Polyline) {\n    // create from a Polyline\n    if (!(arg.points && arg.points.length !== 0)) return; // if Polyline has no points, leave Path empty\n\n    n = arg.points.length;\n\n    for (i = 0; i < n; i++) {\n      var point = arg.points[i];\n      if (i === 0) this.appendSegment(Path.createSegment('M', point));else this.appendSegment(Path.createSegment('L', point));\n    }\n  } else {\n    // unknown object\n    throw new Error('Cannot construct a path from the provided object.');\n  }\n}; // More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\n\nPath.parse = function (pathData) {\n  if (!pathData) return new Path();\n  var path = new Path();\n  var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n  var commands = pathData.match(commandRe);\n  var numCommands = commands.length;\n\n  for (var i = 0; i < numCommands; i++) {\n    var command = commands[i];\n    var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n    var args = command.match(argRe);\n    var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n\n    path.appendSegment(segment);\n  }\n\n  return path;\n}; // Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\n\n\nPath.createSegment = function (type) {\n  if (!type) throw new Error('Type must be provided.');\n  var segmentConstructor = Path.segmentTypes[type];\n  if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 1; i < n; i++) {\n    // do not add first element (`type`) to args array\n    args.push(arguments[i]);\n  }\n\n  return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if argument is not a segment or an array of segments.\n  appendSegment: function (arg) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    var currentSegment;\n    var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null; // if we are appending to an empty path, previousSegment is null\n\n    var nextSegment = null;\n\n    if (!Array.isArray(arg)) {\n      // arg is a segment\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.push(currentSegment);\n    } else {\n      // arg is an array of segments\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  // Returns the bbox of the path.\n  // If path has no segments, returns null.\n  // If path has only invisible segments, returns bbox of the end point of last segment.\n  bbox: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var bbox;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n\n      if (segment.isVisible) {\n        var segmentBBox = segment.bbox();\n        bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n      }\n    }\n\n    if (bbox) return bbox; // if the path has only invisible elements, return end point of last segment\n\n    var lastSegment = segments[numSegments - 1];\n    return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  },\n  // Returns a new path that is a clone of this path.\n  clone: function () {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    var path = new Path();\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i].clone();\n      path.appendSegment(segment);\n    }\n\n    return path;\n  },\n  closestPoint: function (p, opt) {\n    var t = this.closestPointT(p, opt);\n    if (!t) return null;\n    return this.pointAtT(t);\n  },\n  closestPointLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var t = this.closestPointT(p, localOpt);\n    if (!t) return 0;\n    return this.lengthAtT(t, localOpt);\n  },\n  closestPointNormalizedLength: function (p, opt) {\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var cpLength = this.closestPointLength(p, localOpt);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length(localOpt);\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  // Private function.\n  closestPointT: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var closestPointT;\n    var minSquaredDistance = Infinity;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n\n      if (segment.isVisible) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointT) return closestPointT; // if no visible segment, return end of last segment\n\n    return {\n      segmentIndex: numSegments - 1,\n      value: 1\n    };\n  },\n  closestPointTangent: function (p, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var closestPointTangent;\n    var minSquaredDistance = Infinity;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n\n      if (segment.isDifferentiable()) {\n        var segmentClosestPointT = segment.closestPointT(p, {\n          precision: precision,\n          subdivisions: subdivisions\n        });\n        var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointTangent) return closestPointTangent; // if no valid segment, return null\n\n    return null;\n  },\n  // Returns `true` if the area surrounded by the path contains the point `p`.\n  // Implements the even-odd algorithm (self-intersections are \"outside\").\n  // Closes open paths (always imagines a final closing segment).\n  // Precision may be adjusted by passing an `opt` object.\n  containsPoint: function (p, opt) {\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return false; // shortcut (this path has no polylines)\n\n    var numPolylines = polylines.length; // how many component polylines does `p` lie within?\n\n    var numIntersections = 0;\n\n    for (var i = 0; i < numPolylines; i++) {\n      var polyline = polylines[i];\n\n      if (polyline.containsPoint(p)) {\n        // `p` lies within this polyline\n        numIntersections++;\n      }\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  },\n  // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.divideAtLength(length, localOpt);\n  },\n  // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n  divideAtLength: function (length, opt) {\n    var numSegments = this.segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var i;\n    var segment; // identify the segment to divide:\n\n    var l = 0; // length so far\n\n    var divided;\n    var dividedSegmentIndex;\n    var lastValidSegment; // visible AND differentiable\n\n    var lastValidSegmentIndex;\n    var t;\n\n    for (i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      segment = this.getSegment(index);\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        // segment is not just a point\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n\n        if (length <= l + d) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          break;\n        }\n      }\n\n      l += d;\n    }\n\n    if (!lastValidSegment) {\n      // no valid segment found\n      return null;\n    } // else: the path contains at least one valid segment\n\n\n    if (!divided) {\n      // the desired length is greater than the length of the path\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n    var pathCopy = this.clone();\n    pathCopy.replaceSegment(dividedSegmentIndex, divided);\n    var divisionStartIndex = dividedSegmentIndex;\n    var divisionMidIndex = dividedSegmentIndex + 1;\n    var divisionEndIndex = dividedSegmentIndex + 2; // do not insert the part if it looks like a point\n\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n    var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n    var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n    for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n      var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      segment = pathCopy.getSegment(i);\n\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        var convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    } // distribute pathCopy segments into two paths and return those:\n\n\n    var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  },\n  // Checks whether two paths are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var segments = this.segments;\n    var otherSegments = p.segments;\n    var numSegments = segments.length;\n    if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var otherSegment = otherSegments[i]; // as soon as an inequality is found in segments, return false\n\n      if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;\n    } // if no inequality found in segments, return true\n\n\n    return true;\n  },\n  // Accepts negative indices.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  getSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    return segments[index];\n  },\n  // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n  getSegmentSubdivisions: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // not using opt.segmentSubdivisions\n    // not using localOpt\n\n    var segmentSubdivisions = [];\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segment.getSubdivisions({\n        precision: precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n\n    return segmentSubdivisions;\n  },\n  // Returns an array of subpaths of this path.\n  // Invalid paths are validated first.\n  // Returns `[]` if path has no segments.\n  getSubpaths: function () {\n    const validatedPath = this.clone().validate();\n    const segments = validatedPath.segments;\n    const numSegments = segments.length;\n    const subpaths = [];\n\n    for (let i = 0; i < numSegments; i++) {\n      const segment = segments[i];\n\n      if (segment.isSubpathStart) {\n        // we encountered a subpath start segment\n        // create a new path for segment, and push it to list of subpaths\n        subpaths.push(new Path(segment));\n      } else {\n        // append current segment to the last subpath\n        subpaths[subpaths.length - 1].appendSegment(segment);\n      }\n    }\n\n    return subpaths;\n  },\n  // Insert `arg` at given `index`.\n  // `index = 0` means insert at the beginning.\n  // `index = segments.length` means insert at the end.\n  // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  insertSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length; // works even if path has no segments\n    // note that these are incremented comapared to getSegments()\n    // we can insert after last element (note that this changes the meaning of index -1)\n\n    if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n\n    if (index > numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var previousSegment = null;\n    var nextSegment = null;\n\n    if (numSegments !== 0) {\n      if (index >= 1) {\n        previousSegment = segments[index - 1];\n        nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n      } else {\n        // if index === 0\n        // previousSegment is null\n        nextSegment = segments[0];\n      }\n    }\n\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 0, currentSegment);\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\n        previousSegment = currentSegment;\n      }\n    }\n  },\n  intersectionWithLine: function (line, opt) {\n    var intersection = null;\n    var polylines = this.toPolylines(opt);\n    if (!polylines) return null;\n\n    for (var i = 0, n = polylines.length; i < n; i++) {\n      var polyline = polylines[i];\n      var polylineIntersection = line.intersect(polyline);\n\n      if (polylineIntersection) {\n        intersection || (intersection = []);\n\n        if (Array.isArray(polylineIntersection)) {\n          Array.prototype.push.apply(intersection, polylineIntersection);\n        } else {\n          intersection.push(polylineIntersection);\n        }\n      }\n    }\n\n    return intersection;\n  },\n  isDifferentiable: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i]; // as soon as a differentiable segment is found in segments, return true\n\n      if (segment.isDifferentiable()) return true;\n    } // if no differentiable segment is found in segments, return false\n\n\n    return false;\n  },\n  // Checks whether current path segments are valid.\n  // Note that d is allowed to be empty - should disable rendering of the path.\n  isValid: function () {\n    var segments = this.segments;\n    var isValid = segments.length === 0 || segments[0].type === 'M'; // either empty or first segment is a Moveto\n\n    return isValid;\n  },\n  // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n  // If path has no segments, returns 0.\n  length: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var length = 0;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      var subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions: subdivisions\n      });\n    }\n\n    return length;\n  },\n  // Private function.\n  lengthAtT: function (t, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return 0; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return 0; // regardless of t.value\n\n    var tValue = t.value;\n\n    if (segmentIndex >= numSegments) {\n      segmentIndex = numSegments - 1;\n      tValue = 1;\n    } else if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var subdivisions;\n    var length = 0;\n\n    for (var i = 0; i < segmentIndex; i++) {\n      var segment = segments[i];\n      subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precisison: precision,\n        subdivisions: subdivisions\n      });\n    }\n\n    segment = segments[segmentIndex];\n    subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precisison: precision,\n      subdivisions: subdivisions\n    });\n    return length;\n  },\n  // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  pointAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio <= 0) return this.start.clone();\n    if (ratio >= 1) return this.end.clone();\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.pointAtLength(length, localOpt);\n  },\n  // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  pointAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (length === 0) return this.start.clone();\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastVisibleSegment;\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= l + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n\n        lastVisibleSegment = segment;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return last visible segment endpoint\n\n\n    if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start; // if no visible segment, return last segment end point (no matter if fromStart or no)\n\n    var lastSegment = segments[numSegments - 1];\n    return lastSegment.end.clone();\n  },\n  // Private function.\n  pointAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].pointAtT(tValue);\n  },\n  // Default precision\n  PRECISION: 3,\n  // Helper method for adding segments.\n  prepareSegment: function (segment, previousSegment, nextSegment) {\n    // insert after previous segment and before previous segment's next segment\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n    if (previousSegment) previousSegment.nextSegment = segment;\n    if (nextSegment) nextSegment.previousSegment = segment;\n    var updateSubpathStart = segment;\n\n    if (segment.isSubpathStart) {\n      segment.subpathStartSegment = segment; // assign self as subpath start segment\n\n      updateSubpathStart = nextSegment; // start updating from next segment\n    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n    if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n    return segment;\n  },\n  // Remove the segment at `index`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  removeSegment: function (index) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var removedSegment = segments.splice(index, 1)[0];\n    var previousSegment = removedSegment.previousSegment;\n    var nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n    if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n\n    if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n    // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n\n    if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  // Replace the segment at `index` with `arg`.\n  // Accepts negative indices, from `-1` to `-segments.length`.\n  // Accepts one segment or an array of segments as argument.\n  // Throws an error if path has no segments.\n  // Throws an error if index is out of range.\n  // Throws an error if argument is not a segment or an array of segments.\n  replaceSegment: function (index, arg) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) throw new Error('Path has no segments.');\n    if (index < 0) index = numSegments + index; // convert negative indices to positive\n\n    if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n    var currentSegment;\n    var replacedSegment = segments[index];\n    var previousSegment = replacedSegment.previousSegment;\n    var nextSegment = replacedSegment.nextSegment;\n    var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n    if (!Array.isArray(arg)) {\n      if (!arg || !arg.isSegment) throw new Error('Segment required.');\n      currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n      segments.splice(index, 1, currentSegment); // directly replace\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n    } else {\n      // flatten one level deep\n      // so we can chain arbitrary Path.createSegment results\n      arg = arg.reduce(function (acc, val) {\n        return acc.concat(val);\n      }, []);\n      if (!arg[0].isSegment) throw new Error('Segments required.');\n      segments.splice(index, 1);\n      var n = arg.length;\n\n      for (var i = 0; i < n; i++) {\n        var currentArg = arg[i];\n        currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n        segments.splice(index + i, 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n\n        previousSegment = currentSegment;\n        if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n      }\n    } // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n\n\n    if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n  },\n  round: function (precision) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.round(precision);\n    }\n\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.scale(sx, sy, origin);\n    }\n\n    return this;\n  },\n  segmentAt: function (ratio, opt) {\n    var index = this.segmentIndexAt(ratio, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  // Accepts negative length.\n  segmentAtLength: function (length, opt) {\n    var index = this.segmentIndexAtLength(length, opt);\n    if (!index) return null;\n    return this.getSegment(index);\n  },\n  segmentIndexAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.segmentIndexAtLength(length, localOpt);\n  },\n  // Accepts negative length.\n  segmentIndexAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastVisibleSegmentIndex = null;\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= l + d) return index;\n        lastVisibleSegmentIndex = index;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return last visible segment index\n    // if no visible segment, return null\n\n\n    return lastVisibleSegmentIndex;\n  },\n  // Returns a string that can be used to reconstruct the path.\n  // Additional error checking compared to toString (must start with M segment).\n  serialize: function () {\n    if (!this.isValid()) throw new Error('Invalid path segments.');\n    return this.toString();\n  },\n  // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  tangentAt: function (ratio, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var localOpt = {\n      precision: precision,\n      segmentSubdivisions: segmentSubdivisions\n    };\n    var pathLength = this.length(localOpt);\n    var length = pathLength * ratio;\n    return this.tangentAtLength(length, localOpt);\n  },\n  // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n  // Accepts negative length.\n  tangentAtLength: function (length, opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions; // not using localOpt\n\n    var lastValidSegment; // visible AND differentiable (with a tangent)\n\n    var l = 0; // length so far\n\n    for (var i = 0; i < numSegments; i++) {\n      var index = fromStart ? i : numSegments - 1 - i;\n      var segment = segments[index];\n      var subdivisions = segmentSubdivisions[index];\n      var d = segment.length({\n        precision: precision,\n        subdivisions: subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        if (length <= l + d) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - l), {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n        }\n\n        lastValidSegment = segment;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n    if (lastValidSegment) {\n      var t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    } // if no valid segment, return null\n\n\n    return null;\n  },\n  // Private function.\n  tangentAtT: function (t) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    var segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].tangentAtT(0);\n    if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n    var tValue = t.value;\n    if (tValue < 0) tValue = 0;else if (tValue > 1) tValue = 1;\n    return segments[segmentIndex].tangentAtT(tValue);\n  },\n  toPoints: function (opt) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    opt = opt || {};\n    var precision = opt.precision === undefined ? this.PRECISION : opt.precision;\n    var segmentSubdivisions = opt.segmentSubdivisions === undefined ? this.getSegmentSubdivisions({\n      precision: precision\n    }) : opt.segmentSubdivisions;\n    var points = [];\n    var partialPoints = [];\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n\n      if (segment.isVisible) {\n        var currentSegmentSubdivisions = segmentSubdivisions[i];\n\n        if (currentSegmentSubdivisions.length > 0) {\n          var subdivisionPoints = currentSegmentSubdivisions.map(function (curve) {\n            return curve.start;\n          });\n          Array.prototype.push.apply(partialPoints, subdivisionPoints);\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n\n    return points;\n  },\n  toPolylines: function (opt) {\n    var polylines = [];\n    var points = this.toPoints(opt);\n    if (!points) return null;\n\n    for (var i = 0, n = points.length; i < n; i++) {\n      polylines.push(new Polyline(points[i]));\n    }\n\n    return polylines;\n  },\n  toString: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    var pathData = '';\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      pathData += segment.serialize() + ' ';\n    }\n\n    return pathData.trim();\n  },\n  translate: function (tx, ty) {\n    var segments = this.segments;\n    var numSegments = segments.length;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      segment.translate(tx, ty);\n    }\n\n    return this;\n  },\n  // Helper method for updating subpath start of segments, starting with the one provided.\n  updateSubpathStartSegment: function (segment) {\n    var previousSegment = segment.previousSegment; // may be null\n\n    while (segment && !segment.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n      else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n      previousSegment = segment;\n      segment = segment.nextSegment; // move on to the segment after etc.\n    }\n  },\n  // If the path is not valid, insert M 0 0 at the beginning.\n  // Path with no segments is considered valid, so nothing is inserted.\n  validate: function () {\n    if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n    return this;\n  }\n};\nObject.defineProperty(Path.prototype, 'start', {\n  // Getter for the first visible endpoint of the path.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n\n    for (var i = 0; i < numSegments; i++) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.start;\n    } // if no visible segment, return last segment end point\n\n\n    return segments[numSegments - 1].end;\n  }\n});\nObject.defineProperty(Path.prototype, 'end', {\n  // Getter for the last visible endpoint of the path.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var segments = this.segments;\n    var numSegments = segments.length;\n    if (numSegments === 0) return null;\n\n    for (var i = numSegments - 1; i >= 0; i--) {\n      var segment = segments[i];\n      if (segment.isVisible) return segment.end;\n    } // if no visible segment, return last segment end point\n\n\n    return segments[numSegments - 1].end;\n  }\n});\n/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\n\nexport const Point = function (x, y) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y);\n  }\n\n  if (typeof x === 'string') {\n    var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n    x = parseFloat(xy[0]);\n    y = parseFloat(xy[1]);\n  } else if (Object(x) === x) {\n    y = x.y;\n    x = x.x;\n  }\n\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n}; // Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\n\nPoint.fromPolar = function (distance, angle, origin) {\n  origin = new Point(origin);\n  var x = abs(distance * cos(angle));\n  var y = abs(distance * sin(angle));\n  var deg = normalizeAngle(toDeg(angle));\n\n  if (deg < 90) {\n    y = -y;\n  } else if (deg < 180) {\n    x = -x;\n    y = -y;\n  } else if (deg < 270) {\n    x = -x;\n  }\n\n  return new Point(origin.x + x, origin.y + y);\n}; // Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\n\n\nPoint.random = function (x1, x2, y1, y2) {\n  return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n  chooseClosest: function (points) {\n    var n = points.length;\n    if (n === 1) return new Point(points[0]);\n    var closest = null;\n    var minSqrDistance = Infinity;\n\n    for (var i = 0; i < n; i++) {\n      var p = new Point(points[i]);\n      var sqrDistance = this.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        closest = p;\n        minSqrDistance = sqrDistance;\n      }\n    }\n\n    return closest;\n  },\n  // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n  // otherwise return point itself.\n  // (see Squeak Smalltalk, Point>>adhereTo:)\n  adhereToRect: function (r) {\n    if (r.containsPoint(this)) {\n      return this;\n    }\n\n    this.x = min(max(this.x, r.x), r.x + r.width);\n    this.y = min(max(this.y, r.y), r.y + r.height);\n    return this;\n  },\n  // Compute the angle between vector from me to p1 and the vector from me to p2.\n  // ordering of points p1 and p2 is important!\n  // theta function's angle convention:\n  // returns angles between 0 and 180 when the angle is counterclockwise\n  // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n  // returns NaN if any of the points p1, p2 is coincident with this point\n  angleBetween: function (p1, p2) {\n    var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);\n\n    if (angleBetween < 0) {\n      angleBetween += 360; // correction to keep angleBetween between 0 and 360\n    }\n\n    return angleBetween;\n  },\n  // Return the bearing between me and the given point.\n  bearing: function (point) {\n    return new Line(this, point).bearing();\n  },\n  // Returns change in angle from my previous position (-dx, -dy) to my new position\n  // relative to ref point.\n  changeInAngle: function (dx, dy, ref) {\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n  },\n  clone: function () {\n    return new Point(this);\n  },\n  // Returns the cross product of this point relative to two other points\n  // this point is the common point\n  // point p1 lies on the first vector, point p2 lies on the second vector\n  // watch out for the ordering of points p1 and p2!\n  // positive result indicates a clockwise (\"right\") turn from first to second vector\n  // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n  // zero indicates that the first and second vector are collinear\n  // note that the above directions are reversed from the usual answer on the Internet\n  // that is because we are in a left-handed coord system (because the y-axis points downward)\n  cross: function (p1, p2) {\n    return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;\n  },\n  difference: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n\n    return new Point(this.x - (dx || 0), this.y - (dy || 0));\n  },\n  // Returns distance between me and point `p`.\n  distance: function (p) {\n    return new Line(this, p).length();\n  },\n  // Returns the dot product of this point with given other point\n  dot: function (p) {\n    return p ? this.x * p.x + this.y * p.y : NaN;\n  },\n  equals: function (p) {\n    return !!p && this.x === p.x && this.y === p.y;\n  },\n  // Linear interpolation\n  lerp: function (p, t) {\n    var x = this.x;\n    var y = this.y;\n    return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n  },\n  magnitude: function () {\n    return sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  },\n  // Returns a manhattan (taxi-cab) distance between me and point `p`.\n  manhattanDistance: function (p) {\n    return abs(p.x - this.x) + abs(p.y - this.y);\n  },\n  // Move point on line starting from ref ending at me by\n  // distance distance.\n  move: function (ref, distance) {\n    var theta = toRad(new Point(ref).theta(this));\n    var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n    return offset;\n  },\n  // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n  normalize: function (length) {\n    var scale = (length || 1) / this.magnitude();\n    return this.scale(scale, scale);\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    if (Object(dx) === dx) {\n      dy = dx.y;\n      dx = dx.x;\n    }\n\n    this.x += dx || 0;\n    this.y += dy || 0;\n    return this;\n  },\n  // Returns a point that is the reflection of me with\n  // the center of inversion in ref point.\n  reflection: function (ref) {\n    return new Point(ref).move(this, this.distance(ref));\n  },\n  // Rotate point by angle around origin.\n  // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n  rotate: function (origin, angle) {\n    if (angle === 0) return this;\n    origin = origin || new Point(0, 0);\n    angle = toRad(normalizeAngle(-angle));\n    var cosAngle = cos(angle);\n    var sinAngle = sin(angle);\n    var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;\n    var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    return this;\n  },\n  // Scale point with origin.\n  scale: function (sx, sy, origin) {\n    origin = origin && new Point(origin) || new Point(0, 0);\n    this.x = origin.x + sx * (this.x - origin.x);\n    this.y = origin.y + sy * (this.y - origin.y);\n    return this;\n  },\n  snapToGrid: function (gx, gy) {\n    this.x = snapToGrid(this.x, gx);\n    this.y = snapToGrid(this.y, gy || gx);\n    return this;\n  },\n  squaredDistance: function (p) {\n    return new Line(this, p).squaredLength();\n  },\n  // Compute the angle between me and `p` and the x axis.\n  // (cartesian-to-polar coordinates conversion)\n  // Return theta angle in degrees.\n  theta: function (p) {\n    p = new Point(p); // Invert the y-axis.\n\n    var y = -(p.y - this.y);\n    var x = p.x - this.x;\n    var rad = atan2(y, x); // defined for all 0 corner cases\n    // Correction for III. and IV. quadrant.\n\n    if (rad < 0) {\n      rad = 2 * PI + rad;\n    }\n\n    return 180 * rad / PI;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  },\n  // Converts rectangular to polar coordinates.\n  // An origin can be specified, otherwise it's 0@0.\n  toPolar: function (o) {\n    o = o && new Point(o) || new Point(0, 0);\n    var x = this.x;\n    var y = this.y;\n    this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n\n    this.y = toRad(o.theta(new Point(x, y)));\n    return this;\n  },\n  toString: function () {\n    return this.x + '@' + this.y;\n  },\n  serialize: function () {\n    return this.x + ',' + this.y;\n  },\n  update: function (x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n    return this;\n  },\n  // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n  // Returns NaN if p is at 0,0.\n  vectorAngle: function (p) {\n    var zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n};\nPoint.prototype.translate = Point.prototype.offset;\nexport const Polyline = function (points) {\n  if (!(this instanceof Polyline)) {\n    return new Polyline(points);\n  }\n\n  if (typeof points === 'string') {\n    return new Polyline.parse(points);\n  }\n\n  this.points = Array.isArray(points) ? points.map(Point) : [];\n};\n\nPolyline.parse = function (svgString) {\n  svgString = svgString.trim();\n  if (svgString === '') return new Polyline();\n  var points = [];\n  var coords = svgString.split(/\\s*,\\s*|\\s+/);\n  var n = coords.length;\n\n  for (var i = 0; i < n; i += 2) {\n    points.push({\n      x: +coords[i],\n      y: +coords[i + 1]\n    });\n  }\n\n  return new Polyline(points);\n};\n\nPolyline.prototype = {\n  bbox: function () {\n    var x1 = Infinity;\n    var x2 = -Infinity;\n    var y1 = Infinity;\n    var y2 = -Infinity;\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var x = point.x;\n      var y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n\n    return new Rect(x1, y1, x2 - x1, y2 - y1);\n  },\n  clone: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return new Polyline(); // if points array is empty\n\n    var newPoints = [];\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i].clone();\n      newPoints.push(point);\n    }\n\n    return new Polyline(newPoints);\n  },\n  closestPoint: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  },\n  closestPointLength: function (p) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n\n    if (numPoints === 1) return 0; // if there is only one point\n\n    var cpLength;\n    var minSqrDistance = Infinity;\n    var length = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var line = new Line(points[i], points[i + 1]);\n      var lineLength = line.length();\n      var cpNormalizedLength = line.closestPointNormalizedLength(p);\n      var cp = line.pointAt(cpNormalizedLength);\n      var sqrDistance = cp.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n\n      length += lineLength;\n    }\n\n    return cpLength;\n  },\n  closestPointNormalizedLength: function (p) {\n    var cpLength = this.closestPointLength(p);\n    if (cpLength === 0) return 0; // shortcut\n\n    var length = this.length();\n    if (length === 0) return 0; // prevents division by zero\n\n    return cpLength / length;\n  },\n  closestPointTangent: function (p) {\n    var cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  },\n  // Returns `true` if the area surrounded by the polyline contains the point `p`.\n  // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n  // (Uses horizontal rays to the right of `p` to look for intersections.)\n  // Closes open polylines (always imagines a final closing segment).\n  containsPoint: function (p) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n    var x = p.x;\n    var y = p.y; // initialize a final closing segment by creating one from last-first points on polyline\n\n    var startIndex = numPoints - 1; // start of current polyline segment\n\n    var endIndex = 0; // end of current polyline segment\n\n    var numIntersections = 0;\n\n    for (; endIndex < numPoints; endIndex++) {\n      var start = points[startIndex];\n      var end = points[endIndex];\n      if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n\n      var segment = new Line(start, end); // current polyline segment\n\n      if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n      // do we have an intersection?\n\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          var rayEnd = new Point(x + xDifference, y); // right\n\n          var ray = new Line(p, rayEnd);\n\n          if (segment.intersect(ray)) {\n            // an intersection was detected to the right of `p`\n            numIntersections++;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n      } // move to check the next polyline segment\n\n\n      startIndex = endIndex;\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  },\n  // Returns a convex-hull polyline from this polyline.\n  // Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n  // Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n  // Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n  convexHull: function () {\n    var i;\n    var n;\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return new Polyline(); // if points array is empty\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n\n    var startPoint;\n\n    for (i = 0; i < numPoints; i++) {\n      if (startPoint === undefined) {\n        // if this is the first point we see, set it as start point\n        startPoint = points[i];\n      } else if (points[i].y < startPoint.y) {\n        // start point should have lowest y from all points\n        startPoint = points[i];\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        // if two points have the lowest y, choose the one that has highest x\n        // there are no points to the right of startPoint - no ambiguity about theta 0\n        // if there are several coincident start point candidates, first one is reported\n        startPoint = points[i];\n      }\n    } // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n    // step 2a: create the point records = [point, originalIndex, angle]\n\n\n    var sortedPointRecords = [];\n\n    for (i = 0; i < numPoints; i++) {\n      var angle = startPoint.theta(points[i]);\n\n      if (angle === 0) {\n        angle = 360; // give highest angle to start point\n        // the start point will end up at end of sorted list\n        // the start point will end up at beginning of hull points list\n      }\n\n      var entry = [points[i], i, angle];\n      sortedPointRecords.push(entry);\n    } // step 2b: sort the list in place\n\n\n    sortedPointRecords.sort(function (record1, record2) {\n      // returning a negative number here sorts record1 before record2\n      // if first angle is smaller than second, first angle should come before second\n      var sortOutput = record1[2] - record2[2]; // negative if first angle smaller\n\n      if (sortOutput === 0) {\n        // if the two angles are equal, sort by originalIndex\n        sortOutput = record2[1] - record1[1]; // negative if first index larger\n        // coincident points will be sorted in reverse-numerical order\n        // so the coincident points with lower original index will be considered first\n      }\n\n      return sortOutput;\n    }); // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n\n    if (sortedPointRecords.length > 2) {\n      var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n      sortedPointRecords.unshift(startPointRecord);\n    } // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n\n\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n\n    while (sortedPointRecords.length !== 0) {\n      currentPointRecord = sortedPointRecords.pop();\n      currentPoint = currentPointRecord[0]; // check if point has already been discarded\n      // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n\n      if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n        // this point had an incorrect turn at some previous iteration of this loop\n        // this disqualifies it from possibly being on the hull\n        continue;\n      }\n\n      var correctTurnFound = false;\n\n      while (!correctTurnFound) {\n        if (hullPointRecords.length < 2) {\n          // not enough points for comparison, just add current point\n          hullPointRecords.push(currentPointRecord);\n          correctTurnFound = true;\n        } else {\n          lastHullPointRecord = hullPointRecords.pop();\n          lastHullPoint = lastHullPointRecord[0];\n          secondLastHullPointRecord = hullPointRecords.pop();\n          secondLastHullPoint = secondLastHullPointRecord[0];\n          var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n          if (crossProduct < 0) {\n            // found a right turn\n            hullPointRecords.push(secondLastHullPointRecord);\n            hullPointRecords.push(lastHullPointRecord);\n            hullPointRecords.push(currentPointRecord);\n            correctTurnFound = true;\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n            var THRESHOLD = 1e-10; // we have to take rounding errors into account\n\n            var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n            if (abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              //insidePoints.unshift(lastHullPoint);\n              insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              //insidePoints.unshift(lastHullPoint);\n              insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullPointRecords.push(secondLastHullPointRecord); // put last hull point back into the sorted point records list\n\n              sortedPointRecords.push(lastHullPointRecord); // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            //insidePoints.unshift(lastHullPoint);\n            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n            hullPointRecords.push(secondLastHullPointRecord); // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    } // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // step 3b: remove duplicated startPointRecord from the end of the array\n\n\n    if (hullPointRecords.length > 2) {\n      hullPointRecords.pop();\n    } // step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n    var lowestHullIndex; // the lowest originalIndex on the hull\n\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n    n = hullPointRecords.length;\n\n    for (i = 0; i < n; i++) {\n      var currentHullIndex = hullPointRecords[i][1];\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex;\n        indexOfLowestHullIndexRecord = i;\n      }\n    }\n\n    var hullPointRecordsReordered = [];\n\n    if (indexOfLowestHullIndexRecord > 0) {\n      var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n      var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n      hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n\n    for (i = 0; i < n; i++) {\n      hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return new Polyline(hullPoints);\n  },\n  // Checks whether two polylines are exactly the same.\n  // If `p` is undefined or null, returns false.\n  equals: function (p) {\n    if (!p) return false;\n    var points = this.points;\n    var otherPoints = p.points;\n    var numPoints = points.length;\n    if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      var otherPoint = p.points[i]; // as soon as an inequality is found in points, return false\n\n      if (!point.equals(otherPoint)) return false;\n    } // if no inequality found in points, return true\n\n\n    return true;\n  },\n  intersectionWithLine: function (l) {\n    var line = new Line(l);\n    var intersections = [];\n    var points = this.points;\n\n    for (var i = 0, n = points.length - 1; i < n; i++) {\n      var a = points[i];\n      var b = points[i + 1];\n      var l2 = new Line(a, b);\n      var int = line.intersectionWithLine(l2);\n      if (int) intersections.push(int[0]);\n    }\n\n    return intersections.length > 0 ? intersections : null;\n  },\n  isDifferentiable: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return false;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var a = points[i];\n      var b = points[i + 1];\n      var line = new Line(a, b); // as soon as a differentiable line is found between two points, return true\n\n      if (line.isDifferentiable()) return true;\n    } // if no differentiable line is found between pairs of points, return false\n\n\n    return false;\n  },\n  length: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return 0; // if points array is empty\n\n    var length = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      length += points[i].distance(points[i + 1]);\n    }\n\n    return length;\n  },\n  pointAt: function (ratio) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    if (ratio <= 0) return points[0].clone();\n    if (ratio >= 1) return points[numPoints - 1].clone();\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.pointAtLength(length);\n  },\n  pointAtLength: function (length) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var l = 0;\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n\n      if (length <= l + d) {\n        return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the polyline, return last endpoint\n\n\n    var lastPoint = fromStart ? points[numPoints - 1] : points[0];\n    return lastPoint.clone();\n  },\n  round: function (precision) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].round(precision);\n    }\n\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].scale(sx, sy, origin);\n    }\n\n    return this;\n  },\n  simplify: function (opt = {}) {\n    const points = this.points;\n    if (points.length < 3) return this; // we need at least 3 points\n    // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n    const threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n    // start at the beginning of the polyline and go forward\n\n    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n      const closestPointDistance = closestPoint.distance(middlePoint);\n\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1; //    = (point after first point becomes first point)\n      }\n    } // `points` array was modified in-place\n\n\n    return this;\n  },\n  tangentAt: function (ratio) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return null; // if there is only one point\n\n    if (ratio < 0) ratio = 0;\n    if (ratio > 1) ratio = 1;\n    var polylineLength = this.length();\n    var length = polylineLength * ratio;\n    return this.tangentAtLength(length);\n  },\n  tangentAtLength: function (length) {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    if (numPoints === 1) return null; // if there is only one point\n\n    var fromStart = true;\n\n    if (length < 0) {\n      fromStart = false; // negative lengths mean start calculation from end point\n\n      length = -length; // absolute value\n    }\n\n    var lastValidLine; // differentiable (with a tangent)\n\n    var l = 0; // length so far\n\n    var n = numPoints - 1;\n\n    for (var i = 0; i < n; i++) {\n      var index = fromStart ? i : n - 1 - i;\n      var a = points[index];\n      var b = points[index + 1];\n      var line = new Line(a, b);\n      var d = a.distance(b);\n\n      if (line.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= l + d) {\n          return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n        }\n\n        lastValidLine = line;\n      }\n\n      l += d;\n    } // if length requested is higher than the length of the polyline, return last valid endpoint\n\n\n    if (lastValidLine) {\n      var ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    } // if no valid line, return null\n\n\n    return null;\n  },\n  toString: function () {\n    return this.points + '';\n  },\n  translate: function (tx, ty) {\n    var points = this.points;\n    var numPoints = points.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      points[i].translate(tx, ty);\n    }\n\n    return this;\n  },\n  // Return svgString that can be used to recreate this line.\n  serialize: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return ''; // if points array is empty\n\n    var output = '';\n\n    for (var i = 0; i < numPoints; i++) {\n      var point = points[i];\n      output += point.x + ',' + point.y + ' ';\n    }\n\n    return output.trim();\n  }\n};\nObject.defineProperty(Polyline.prototype, 'start', {\n  // Getter for the first point of the polyline.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[0];\n  }\n});\nObject.defineProperty(Polyline.prototype, 'end', {\n  // Getter for the last point of the polyline.\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    var points = this.points;\n    var numPoints = points.length;\n    if (numPoints === 0) return null; // if points array is empty\n\n    return this.points[numPoints - 1];\n  }\n});\nexport const Rect = function (x, y, w, h) {\n  if (!(this instanceof Rect)) {\n    return new Rect(x, y, w, h);\n  }\n\n  if (Object(x) === x) {\n    y = x.y;\n    w = x.width;\n    h = x.height;\n    x = x.x;\n  }\n\n  this.x = x === undefined ? 0 : x;\n  this.y = y === undefined ? 0 : y;\n  this.width = w === undefined ? 0 : w;\n  this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function (e) {\n  e = new Ellipse(e);\n  return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.prototype = {\n  // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n  // @return r {rectangle} representing a bounding box\n  bbox: function (angle) {\n    if (!angle) return this.clone();\n    var theta = toRad(angle);\n    var st = abs(sin(theta));\n    var ct = abs(cos(theta));\n    var w = this.width * ct + this.height * st;\n    var h = this.width * st + this.height * ct;\n    return new Rect(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n  },\n  bottomLeft: function () {\n    return new Point(this.x, this.y + this.height);\n  },\n  bottomLine: function () {\n    return new Line(this.bottomLeft(), this.bottomRight());\n  },\n  bottomMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  },\n  center: function () {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  },\n  clone: function () {\n    return new Rect(this);\n  },\n  // @return {bool} true if point p is inside me.\n  containsPoint: function (p) {\n    p = new Point(p);\n    return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n  },\n  // @return {bool} true if rectangle `r` is inside me.\n  containsRect: function (r) {\n    var r0 = new Rect(this).normalize();\n    var r1 = new Rect(r).normalize();\n    var w0 = r0.width;\n    var h0 = r0.height;\n    var w1 = r1.width;\n    var h1 = r1.height;\n\n    if (!w0 || !h0 || !w1 || !h1) {\n      // At least one of the dimensions is 0\n      return false;\n    }\n\n    var x0 = r0.x;\n    var y0 = r0.y;\n    var x1 = r1.x;\n    var y1 = r1.y;\n    w1 += x1;\n    w0 += x0;\n    h1 += y1;\n    h0 += y0;\n    return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n  },\n  corner: function () {\n    return new Point(this.x + this.width, this.y + this.height);\n  },\n  // @return {boolean} true if rectangles are equal.\n  equals: function (r) {\n    var mr = new Rect(this).normalize();\n    var nr = new Rect(r).normalize();\n    return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n  },\n  // inflate by dx and dy, recompute origin [x, y]\n  // @param dx {delta_x} representing additional size to x\n  // @param dy {delta_y} representing additional size to y -\n  // dy param is not required -> in that case y is sized by dx\n  inflate: function (dx, dy) {\n    if (dx === undefined) {\n      dx = 0;\n    }\n\n    if (dy === undefined) {\n      dy = dx;\n    }\n\n    this.x -= dx;\n    this.y -= dy;\n    this.width += 2 * dx;\n    this.height += 2 * dy;\n    return this;\n  },\n  // @return {rect} if rectangles intersect, {null} if not.\n  intersect: function (r) {\n    var myOrigin = this.origin();\n    var myCorner = this.corner();\n    var rOrigin = r.origin();\n    var rCorner = r.corner(); // No intersection found\n\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;\n    var x = max(myOrigin.x, rOrigin.x);\n    var y = max(myOrigin.y, rOrigin.y);\n    return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n  },\n  intersectionWithLine: function (line) {\n    var r = this;\n    var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n    var points = [];\n    var dedupeArr = [];\n    var pt, i;\n    var n = rectLines.length;\n\n    for (i = 0; i < n; i++) {\n      pt = line.intersect(rectLines[i]);\n\n      if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n        points.push(pt);\n        dedupeArr.push(pt.toString());\n      }\n    }\n\n    return points.length > 0 ? points : null;\n  },\n  // Find point on my boundary where line starting\n  // from my center ending in point p intersects me.\n  // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n  intersectionWithLineFromCenterToPoint: function (p, angle) {\n    p = new Point(p);\n    var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n    var result;\n    if (angle) p.rotate(center, angle); // (clockwise, starting from the top side)\n\n    var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];\n    var connector = new Line(center, p);\n\n    for (var i = sides.length - 1; i >= 0; --i) {\n      var intersection = sides[i].intersection(connector);\n\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n\n    if (result && angle) result.rotate(center, -angle);\n    return result;\n  },\n  leftLine: function () {\n    return new Line(this.topLeft(), this.bottomLeft());\n  },\n  leftMiddle: function () {\n    return new Point(this.x, this.y + this.height / 2);\n  },\n  maxRectScaleToFit: function (rect, origin) {\n    rect = new Rect(rect);\n    origin || (origin = rect.center());\n    var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n    var ox = origin.x;\n    var oy = origin.y; // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n    // so when the scale is applied the point is still inside the rectangle.\n\n    sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity; // Top Left\n\n    var p1 = rect.topLeft();\n\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    } // Bottom Right\n\n\n    var p2 = rect.bottomRight();\n\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    } // Top Right\n\n\n    var p3 = rect.topRight();\n\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    } // Bottom Left\n\n\n    var p4 = rect.bottomLeft();\n\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n\n    return {\n      sx: min(sx1, sx2, sx3, sx4),\n      sy: min(sy1, sy2, sy3, sy4)\n    };\n  },\n  maxRectUniformScaleToFit: function (rect, origin) {\n    var scale = this.maxRectScaleToFit(rect, origin);\n    return min(scale.sx, scale.sy);\n  },\n  // Move and expand me.\n  // @param r {rectangle} representing deltas\n  moveAndExpand: function (r) {\n    this.x += r.x || 0;\n    this.y += r.y || 0;\n    this.width += r.width || 0;\n    this.height += r.height || 0;\n    return this;\n  },\n  // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n  // If width < 0 the function swaps the left and right corners,\n  // and it swaps the top and bottom corners if height < 0\n  // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n  normalize: function () {\n    var newx = this.x;\n    var newy = this.y;\n    var newwidth = this.width;\n    var newheight = this.height;\n\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  },\n  // Offset me by the specified amount.\n  offset: function (dx, dy) {\n    // pretend that this is a point and call offset()\n    // rewrites x and y according to dx and dy\n    return Point.prototype.offset.call(this, dx, dy);\n  },\n  origin: function () {\n    return new Point(this.x, this.y);\n  },\n  // @return {point} a point on my boundary nearest to the given point.\n  // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n  pointNearestToPoint: function (point) {\n    point = new Point(point);\n\n    if (this.containsPoint(point)) {\n      var side = this.sideNearestToPoint(point);\n\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, point.y);\n\n        case 'left':\n          return new Point(this.x, point.y);\n\n        case 'bottom':\n          return new Point(point.x, this.y + this.height);\n\n        case 'top':\n          return new Point(point.x, this.y);\n      }\n    }\n\n    return point.adhereToRect(this);\n  },\n  rightLine: function () {\n    return new Line(this.topRight(), this.bottomRight());\n  },\n  rightMiddle: function () {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  },\n  round: function (precision) {\n    let f = 1; // case 0\n\n    if (precision) {\n      switch (precision) {\n        case 1:\n          f = 10;\n          break;\n\n        case 2:\n          f = 100;\n          break;\n\n        case 3:\n          f = 1000;\n          break;\n\n        default:\n          f = pow(10, precision);\n          break;\n      }\n    }\n\n    this.x = round(this.x * f) / f;\n    this.y = round(this.y * f) / f;\n    this.width = round(this.width * f) / f;\n    this.height = round(this.height * f) / f;\n    return this;\n  },\n  // Scale rectangle with origin.\n  scale: function (sx, sy, origin) {\n    origin = this.origin().scale(sx, sy, origin);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  },\n  // @return {string} (left|right|top|bottom) side which is nearest to point\n  // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n  sideNearestToPoint: function (point) {\n    point = new Point(point);\n    var distToLeft = point.x - this.x;\n    var distToRight = this.x + this.width - point.x;\n    var distToTop = point.y - this.y;\n    var distToBottom = this.y + this.height - point.y;\n    var closest = distToLeft;\n    var side = 'left';\n\n    if (distToRight < closest) {\n      closest = distToRight;\n      side = 'right';\n    }\n\n    if (distToTop < closest) {\n      closest = distToTop;\n      side = 'top';\n    }\n\n    if (distToBottom < closest) {\n      // closest = distToBottom;\n      side = 'bottom';\n    }\n\n    return side;\n  },\n  snapToGrid: function (gx, gy) {\n    var origin = this.origin().snapToGrid(gx, gy);\n    var corner = this.corner().snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  },\n  toJSON: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  },\n  topLine: function () {\n    return new Line(this.topLeft(), this.topRight());\n  },\n  topMiddle: function () {\n    return new Point(this.x + this.width / 2, this.y);\n  },\n  topRight: function () {\n    return new Point(this.x + this.width, this.y);\n  },\n  toString: function () {\n    return this.origin().toString() + ' ' + this.corner().toString();\n  },\n  // @return {rect} representing the union of both rectangles.\n  union: function (rect) {\n    const u = new Rect(rect);\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    const {\n      x: rx,\n      y: ry,\n      width: rw,\n      height: rh\n    } = u;\n    const ux = u.x = min(x, rx);\n    const uy = u.y = min(y, ry);\n    u.width = max(x + width, rx + rw) - ux;\n    u.height = max(y + height, ry + rh) - uy;\n    return u;\n  }\n};\nRect.prototype.bottomRight = Rect.prototype.corner;\nRect.prototype.topLeft = Rect.prototype.origin;\nRect.prototype.translate = Rect.prototype.offset;\nexport const scale = {\n  // Return the `value` from the `domain` interval scaled to the `range` interval.\n  linear: function (domain, range, value) {\n    var domainSpan = domain[1] - domain[0];\n    var rangeSpan = range[1] - range[0];\n    return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;\n  }\n};\nexport const normalizeAngle = function (angle) {\n  return angle % 360 + (angle < 0 ? 360 : 0);\n};\nexport const snapToGrid = function (value, gridSize) {\n  return gridSize * round(value / gridSize);\n};\nexport const toDeg = function (rad) {\n  return 180 * rad / PI % 360;\n};\nexport const toRad = function (deg, over360) {\n  over360 = over360 || false;\n  deg = over360 ? deg : deg % 360;\n  return deg * PI / 180;\n}; // Return a random integer from the interval [min,max], inclusive.\n\nexport const random = function (min, max) {\n  if (max === undefined) {\n    // use first argument as max, min is 0\n    max = min === undefined ? 1 : min;\n    min = 0;\n  } else if (max < min) {\n    // switch max and min\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return floor(math.random() * (max - min + 1) + min);\n}; // For backwards compatibility:\n\nexport const ellipse = Ellipse;\nexport const line = Line;\nexport const point = Point;\nexport const rect = Rect; // Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\n\nfunction applyToNew(constructor, argsArray) {\n  // The `new` keyword can only be applied to functions that take a limited number of arguments.\n  // - We can fake that with .bind().\n  // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n  // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n  // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n  // We need to pass in a variable number of arguments to the bind() call.\n  // - We can use .apply().\n  // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n  // - `thisArg` can still be anything because `new` overwrites it.\n  // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n  // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n  // The function expects `argsArray[0]` to be `thisArg`.\n  // - This means that whatever is sent as the first element will be ignored.\n  // - The constructor will only see arguments starting from argsArray[1].\n  // - So, a new dummy element is inserted at the start of the array.\n  argsArray.unshift(null);\n  return new (Function.prototype.bind.apply(constructor, argsArray))();\n} // Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\n\n\nfunction extend(obj) {\n  // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n  // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n  // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n  // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n  // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n  // - This method provides a way to do exactly that.\n  // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n  // - Therefore, to continue with the example above:\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n  //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n  //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n  //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n  // - Multiple inheritance is also possible, if multiple arguments are provided.\n  // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n  //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n  //   - The ancestors are applied in order of appearance.\n  //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n  //   - Any number of ancestors may be provided.\n  // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n  // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n  //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n  //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n  // - Therefore, both of the following are valid:\n  //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n  //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n  var i;\n  var n;\n  var args = [];\n  n = arguments.length;\n\n  for (i = 1; i < n; i++) {\n    // skip over obj\n    args.push(arguments[i]);\n  }\n\n  if (!obj) throw new Error('Missing a parent object.');\n  var child = Object.create(obj);\n  n = args.length;\n\n  for (i = 0; i < n; i++) {\n    var src = args[i];\n    var inheritedProperty;\n    var key;\n\n    for (key in src) {\n      if (src.hasOwnProperty(key)) {\n        delete child[key]; // delete property inherited from parent\n\n        inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n\n        Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n      }\n    }\n  }\n\n  return child;\n} // Path segment interface:\n\n\nvar segmentPrototype = {\n  // virtual\n  bbox: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  clone: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPoint: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  closestPointNormalizedLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n  closestPointT: function (p) {\n    if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n    throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n  },\n  // virtual\n  closestPointTangent: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  divideAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n  divideAtT: function (t) {\n    if (this.divideAt) return this.divideAt(t);\n    throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n  },\n  // virtual\n  equals: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  getSubdivisions: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  isDifferentiable: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  isSegment: true,\n  isSubpathStart: false,\n  // true for Moveto segments\n  isVisible: true,\n  // false for Moveto segments\n  // virtual\n  length: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n  lengthAtT: function (t) {\n    if (t <= 0) return 0;\n    var length = this.length();\n    if (t >= 1) return length;\n    return length * t;\n  },\n  nextSegment: null,\n  // needed for subpath start segment updating\n  // virtual\n  pointAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  pointAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n  pointAtT: function (t) {\n    if (this.pointAt) return this.pointAt(t);\n    throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n  },\n  previousSegment: null,\n  // needed to get segment start property\n  // virtual\n  round: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  subpathStartSegment: null,\n  // needed to get Closepath segment end property\n  // virtual\n  scale: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  serialize: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAt: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  tangentAtLength: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n  tangentAtT: function (t) {\n    if (this.tangentAt) return this.tangentAt(t);\n    throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n  },\n  // virtual\n  toString: function () {\n    throw new Error('Declaration missing for virtual function.');\n  },\n  // virtual\n  translate: function () {\n    throw new Error('Declaration missing for virtual function.');\n  }\n}; // usually directly assigned\n// getter for Closepath\n\nObject.defineProperty(segmentPrototype, 'end', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n}); // always a getter\n// always throws error for Moveto\n\nObject.defineProperty(segmentPrototype, 'start', {\n  // get a reference to the end point of previous segment\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n    return this.previousSegment.end;\n  }\n}); // virtual\n\nObject.defineProperty(segmentPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Bad segment declaration. No type specified.');\n  }\n}); // Path segment implementations:\n\nvar Lineto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Lineto)) {\n    // switching context of `this` to Lineto when called without `new`\n    return applyToNew(Lineto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-line segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\n        outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a poly-line segment\n      var segmentPoint;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 1) {\n        segmentPoint = args[i];\n        outputArray.push(new Lineto(segmentPoint));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar linetoPrototype = {\n  clone: function () {\n    return new Lineto(this.end);\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [new Lineto(divided[0]), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(linetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'L'\n});\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Curveto)) {\n    // switching context of `this` to Curveto when called without `new`\n    return applyToNew(Curveto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.controlPoint1 = args[0].controlPoint1.clone();\n      this.controlPoint2 = args[0].controlPoint2.clone();\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 6) {\n      this.controlPoint1 = new Point(+args[0], +args[1]);\n      this.controlPoint2 = new Point(+args[2], +args[3]);\n      this.end = new Point(+args[4], +args[5]);\n      return this;\n    } else if (n < 6) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 6) {\n        // coords come in groups of six\n        segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n\n        outputArray.push(applyToNew(Curveto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 3) {\n      this.controlPoint1 = new Point(args[0]);\n      this.controlPoint2 = new Point(args[1]);\n      this.end = new Point(args[2]);\n      return this;\n    } else if (n < 3) {\n      throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n    } else {\n      // this is a poly-bezier segment\n      var segmentPoints;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 3) {\n        // points come in groups of three\n        segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n\n        outputArray.push(applyToNew(Curveto, segmentPoints));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar curvetoPrototype = {\n  clone: function () {\n    return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n  },\n  divideAt: function (ratio, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAt(ratio, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtLength: function (length, opt) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtLength(length, opt);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  divideAtT: function (t) {\n    var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    var divided = curve.divideAtT(t);\n    return [new Curveto(divided[0]), new Curveto(divided[1])];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment) return false;\n    var start = this.start;\n    var control1 = this.controlPoint1;\n    var control2 = this.controlPoint2;\n    var end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  },\n  round: function (precision) {\n    this.controlPoint1.round(precision);\n    this.controlPoint2.round(precision);\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var c1 = this.controlPoint1;\n    var c2 = this.controlPoint2;\n    var end = this.end;\n    return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.controlPoint1.translate(tx, ty);\n    this.controlPoint2.translate(tx, ty);\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(curvetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'C'\n});\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Moveto)) {\n    // switching context of `this` to Moveto when called without `new`\n    return applyToNew(Moveto, args);\n  }\n\n  if (n === 0) {\n    throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n  }\n\n  var outputArray;\n\n  if (args[0] instanceof Line) {\n    // lines provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n    }\n  } else if (args[0] instanceof Curve) {\n    // curves provided\n    if (n === 1) {\n      this.end = args[0].end.clone();\n      return this;\n    } else {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n    }\n  } else if (typeof args[0] === 'string' || typeof args[0] === 'number') {\n    // coordinates provided\n    if (n === 2) {\n      this.end = new Point(+args[0], +args[1]);\n      return this;\n    } else if (n < 2) {\n      throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentCoords;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 2) {\n        // coords come in groups of two\n        segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n\n        if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));else outputArray.push(applyToNew(Lineto, segmentCoords));\n      }\n\n      return outputArray;\n    }\n  } else {\n    // points provided (needs to be last to also cover plain objects with x and y)\n    if (n === 1) {\n      this.end = new Point(args[0]);\n      return this;\n    } else {\n      // this is a moveto-with-subsequent-poly-line segment\n      var segmentPoint;\n      outputArray = [];\n\n      for (i = 0; i < n; i += 1) {\n        // points come one by one\n        segmentPoint = args[i];\n        if (i === 0) outputArray.push(new Moveto(segmentPoint));else outputArray.push(new Lineto(segmentPoint));\n      }\n\n      return outputArray;\n    }\n  }\n};\n\nvar movetoPrototype = {\n  bbox: function () {\n    return null;\n  },\n  clone: function () {\n    return new Moveto(this.end);\n  },\n  closestPoint: function () {\n    return this.end.clone();\n  },\n  closestPointNormalizedLength: function () {\n    return 0;\n  },\n  closestPointLength: function () {\n    return 0;\n  },\n  closestPointT: function () {\n    return 1;\n  },\n  closestPointTangent: function () {\n    return null;\n  },\n  divideAt: function () {\n    return [this.clone(), this.clone()];\n  },\n  divideAtLength: function () {\n    return [this.clone(), this.clone()];\n  },\n  equals: function (m) {\n    return this.end.equals(m.end);\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    return false;\n  },\n  isSubpathStart: true,\n  isVisible: false,\n  length: function () {\n    return 0;\n  },\n  lengthAtT: function () {\n    return 0;\n  },\n  pointAt: function () {\n    return this.end.clone();\n  },\n  pointAtLength: function () {\n    return this.end.clone();\n  },\n  pointAtT: function () {\n    return this.end.clone();\n  },\n  round: function (precision) {\n    this.end.round(precision);\n    return this;\n  },\n  scale: function (sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  },\n  serialize: function () {\n    var end = this.end;\n    return this.type + ' ' + end.x + ' ' + end.y;\n  },\n  tangentAt: function () {\n    return null;\n  },\n  tangentAtLength: function () {\n    return null;\n  },\n  tangentAtT: function () {\n    return null;\n  },\n  toString: function () {\n    return this.type + ' ' + this.end;\n  },\n  translate: function (tx, ty) {\n    this.end.translate(tx, ty);\n    return this;\n  }\n};\nObject.defineProperty(movetoPrototype, 'start', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n});\nObject.defineProperty(movetoPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'M'\n});\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function () {\n  var args = [];\n  var n = arguments.length;\n\n  for (var i = 0; i < n; i++) {\n    args.push(arguments[i]);\n  }\n\n  if (!(this instanceof Closepath)) {\n    // switching context of `this` to Closepath when called without `new`\n    return applyToNew(Closepath, args);\n  }\n\n  if (n > 0) {\n    throw new Error('Closepath constructor expects no arguments.');\n  }\n\n  return this;\n};\n\nvar closepathPrototype = {\n  clone: function () {\n    return new Closepath();\n  },\n  divideAt: function (ratio) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAt(ratio);\n    return [// if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  divideAtLength: function (length) {\n    var line = new Line(this.start, this.end);\n    var divided = line.divideAtLength(length);\n    return [// if we didn't actually cut into the segment, first divided part can stay as Z\n    divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(), new Lineto(divided[1])];\n  },\n  getSubdivisions: function () {\n    return [];\n  },\n  isDifferentiable: function () {\n    if (!this.previousSegment || !this.subpathStartSegment) return false;\n    return !this.start.equals(this.end);\n  },\n  round: function () {\n    return this;\n  },\n  scale: function () {\n    return this;\n  },\n  serialize: function () {\n    return this.type;\n  },\n  toString: function () {\n    return this.type + ' ' + this.start + ' ' + this.end;\n  },\n  translate: function () {\n    return this;\n  }\n};\nObject.defineProperty(closepathPrototype, 'end', {\n  // get a reference to the end point of subpath start segment\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n    return this.subpathStartSegment.end;\n  }\n});\nObject.defineProperty(closepathPrototype, 'type', {\n  configurable: true,\n  enumerable: true,\n  value: 'Z'\n});\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\nvar segmentTypes = Path.segmentTypes = {\n  L: Lineto,\n  C: Curveto,\n  M: Moveto,\n  Z: Closepath,\n  z: Closepath\n};\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function (data) {\n  if (typeof data !== 'string') return false;\n  return this.regexSupportedData.test(data);\n};","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/g/index.mjs"],"names":["math","Math","abs","cos","sin","sqrt","min","max","atan2","round","floor","PI","pow","bezier","curveThroughPoints","points","console","warn","Path","Curve","throughPoints","serialize","getCurveControlPoints","knots","firstControlPoints","secondControlPoints","n","length","i","Point","x","y","rhs","getFirstControlPoints","push","getCurveDivider","p0","p1","p2","p3","curve","divideCurve","t","divided","divide","start","controlPoint1","controlPoint2","end","tmp","b","getInversionSolver","solveInversion","p","closestPointT","p4","Array","isArray","Error","controlPoints","curves","prototype","bbox","x0","y0","x1","y1","x2","y2","x3","y3","tvalues","bounds","a","c","t1","t2","b2ac","sqrtb2ac","j","jlen","mt","X","Y","left","apply","top","right","bottom","Rect","clone","closestPoint","opt","pointAtT","closestPointLength","precision","undefined","PRECISION","subdivisions","getSubdivisions","localOpt","lengthAtT","closestPointNormalizedLength","cpLength","investigatedSubdivision","investigatedSubdivisionStartT","investigatedSubdivisionEndT","distFromStart","distFromEnd","chordLength","minSumDist","subdivisionSize","currentSubdivision","startDist","distance","endDist","sumDist","precisionRatio","startPrecisionRatio","endPrecisionRatio","hasRequiredPrecision","hasMinimalStartDistance","hasMinimalEndDistance","hasMinimalDistance","startDist1","endDist1","sumDist1","startDist2","endDist2","sumDist2","closestPointTangent","tangentAtT","containsPoint","polyline","toPolyline","divideAt","ratio","divideAtT","tAt","divideAtLength","tAtLength","dividerPoints","getSkeletonPoints","startControl1","startControlPoint1","startControl2","startControlPoint2","divider","dividerControl1","dividerControlPoint1","dividerControl2","dividerControlPoint2","endpointDistance","equals","control1","control2","midpoint1","Line","pointAt","midpoint2","midpoint3","subControl1","subControl2","output","previousLength","iteration","newSubdivisions","numSubdivisions","numNewSubdivisions","currentNewSubdivision","observedPrecisionRatio","isDifferentiable","subCurve","subCurveLength","pointAtLength","scale","sx","sy","origin","tangentAt","tangentAtLength","skeletonPoints","tangentStart","tangentLine","translate","curveLength","fromStart","baselinePointDistFromStart","baselinePointDistFromEnd","l","index","d","newBaselinePointDistFromStart","newBaselinePointDistFromEnd","baseline1Length","baseline2Length","toPoints","Polyline","toString","tx","ty","Ellipse","fromRect","rect","center","width","height","normalizedDistance","ellipse","inflate","dx","dy","intersectionWithLine","line","intersections","a1","a2","rx","ry","dir","vector","diff","difference","mDir","mDiff","dot","root","ta","tb","lerp","intersectionWithLineFromCenterToPoint","angle","rotate","result","pointNearestToPoint","m","mSquared","aSquared","bSquared","point","f","tangentTheta","refPointDelta","q1","q3","theta","horizontalPoint","angleBetween","bearing","lat1","toRad","lat2","lon1","lon2","dLon","brng","toDeg","bearings","parseInt","product","cpNormalizedLength","squaredLength","cross","dividerPoint","intersect","shape","intersection","pt1Dir","pt2Dir","det","deltaPt","alpha","beta","midpoint","parallel","eRef","sRef","move","lineLength","pointOffset","determinant","setLength","currentLength","scaleFactor","arg","parse","segments","reduce","acc","val","concat","isSegment","segment","appendSegment","previousObj","obj","createSegment","pathData","path","commandRe","commands","match","numCommands","command","argRe","args","type","segmentConstructor","segmentTypes","arguments","applyToNew","numSegments","currentSegment","previousSegment","nextSegment","prepareSegment","currentArg","isVisible","segmentBBox","union","lastSegment","segmentSubdivisions","getSegmentSubdivisions","minSquaredDistance","Infinity","segmentClosestPointT","segmentClosestPoint","squaredDistance","segmentIndex","value","polylines","toPolylines","numPolylines","numIntersections","pathLength","dividedSegmentIndex","lastValidSegment","lastValidSegmentIndex","getSegment","pathCopy","replaceSegment","divisionStartIndex","divisionMidIndex","divisionEndIndex","removeSegment","movetoEnd","insertSegment","secondPathSegmentIndexConversion","originalSegment","subpathStartSegment","convertedSegment","firstPath","slice","secondPath","otherSegments","otherSegment","getSubpaths","validatedPath","validate","subpaths","isSubpathStart","splice","polylineIntersection","isValid","tValue","precisison","lastVisibleSegment","updateSubpathStart","updateSubpathStartSegment","removedSegment","replacedSegment","segmentAt","segmentIndexAt","segmentAtLength","segmentIndexAtLength","lastVisibleSegmentIndex","partialPoints","currentSegmentSubdivisions","subdivisionPoints","map","trim","Object","defineProperty","configurable","enumerable","get","xy","split","indexOf","parseFloat","fromPolar","deg","normalizeAngle","random","chooseClosest","closest","minSqrDistance","sqrDistance","adhereToRect","r","NaN","changeInAngle","ref","offset","magnitude","manhattanDistance","normalize","reflection","cosAngle","sinAngle","snapToGrid","gx","gy","rad","toJSON","toPolar","o","update","vectorAngle","zero","svgString","coords","numPoints","newPoints","cp","startIndex","endIndex","xDifference","rayEnd","ray","convexHull","startPoint","sortedPointRecords","entry","sort","record1","record2","sortOutput","startPointRecord","unshift","insidePoints","hullPointRecords","currentPointRecord","currentPoint","lastHullPointRecord","lastHullPoint","secondLastHullPointRecord","secondLastHullPoint","pop","hasOwnProperty","correctTurnFound","crossProduct","THRESHOLD","lowestHullIndex","indexOfLowestHullIndexRecord","currentHullIndex","hullPointRecordsReordered","newFirstChunk","newSecondChunk","hullPoints","otherPoints","otherPoint","l2","int","polylineLength","lastPoint","simplify","threshold","currentIndex","firstIndex","middleIndex","lastIndex","firstPoint","middlePoint","chord","closestPointDistance","lastValidLine","w","h","fromEllipse","e","st","ct","bottomLeft","bottomLine","bottomRight","bottomMiddle","containsRect","r0","r1","w0","h0","w1","h1","corner","mr","nr","myOrigin","myCorner","rOrigin","rCorner","rectLines","topLine","rightLine","leftLine","dedupeArr","pt","sides","connector","topLeft","leftMiddle","maxRectScaleToFit","sx1","sx2","sx3","sx4","sy1","sy2","sy3","sy4","ox","oy","topRight","maxRectUniformScaleToFit","moveAndExpand","newx","newy","newwidth","newheight","call","side","sideNearestToPoint","rightMiddle","distToLeft","distToRight","distToTop","distToBottom","topMiddle","u","rw","rh","ux","uy","linear","domain","range","domainSpan","rangeSpan","gridSize","over360","temp","constructor","argsArray","Function","bind","extend","child","create","src","inheritedProperty","key","getOwnPropertyDescriptor","segmentPrototype","writable","Lineto","outputArray","segmentCoords","segmentPoint","linetoPrototype","Curveto","segmentPoints","curvetoPrototype","c1","c2","Moveto","movetoPrototype","Closepath","closepathPrototype","L","C","M","Z","z","regexSupportedData","RegExp","keys","join","isDataSupported","data","test"],"mappings":"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","sourcesContent":["// Geometry library.\n// -----------------\n\n// Declare shorthands to the most used math functions.\nconst math = Math;\nconst abs = math.abs;\nconst cos = math.cos;\nconst sin = math.sin;\nconst sqrt = math.sqrt;\nconst min = math.min;\nconst max = math.max;\nconst atan2 = math.atan2;\nconst round = math.round;\nconst floor = math.floor;\nconst PI = math.PI;\nconst pow = math.pow;\n\nexport const bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new Path(Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ﬁnd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n\nexport const Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.controlPoint1 = new Point(p2);\n    this.controlPoint2 = new Point(p3);\n    this.end = new Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new Line(start, control1)).pointAt(t);\n        var midpoint2 = (new Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // (That is why skipping iteration 1 is important)\n    // As a rule of thumb, increasing `precision` by 1 requires two more division operations\n    // - Precision 0 (endpointDistance) - total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n        if (precision === 0) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide curve at `t = 0.5`\n        // until the difference between observed length at subsequent iterations is lower than precision\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached required observed precision\n            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n            // not a problem for further iterations because cubic curves cannot have more than two local extrema\n            // (i.e. cubic curves cannot intersect the baseline more than once)\n            // therefore two subsequent iterations cannot produce sampling with equal length\n            var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n            if (iteration > 1 && observedPrecisionRatio < precisionRatio) {\n                return newSubdivisions;\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n\nexport const Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    bbox: function() {\n\n        return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new Point(this));\n        var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n\n        if (angle) p.rotate(new Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\nexport const Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new Point(p1);\n    this.end = new Point(p2);\n};\n\nLine.prototype = {\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n\n        var lat1 = toRad(this.start.y);\n        var lat2 = toRad(this.end.y);\n        var lon1 = this.start.x;\n        var lon2 = this.end.x;\n        var dLon = toRad(lon2 - lon1);\n        var y = sin(dLon) * cos(lat2);\n        var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n        var brng = toDeg(atan2(y, x));\n\n        var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n        var index = brng - 22.5;\n        if (index < 0)\n            index += 360;\n        index = parseInt(index / 45);\n\n        return bearings[index];\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape instanceof Line ||\n            shape instanceof Rect ||\n            shape instanceof Polyline ||\n            shape instanceof Ellipse ||\n            shape instanceof Path\n        ) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n\n        return sqrt(this.squaredLength());\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n\n        var x0 = this.start.x;\n        var y0 = this.start.y;\n        var x1 = this.end.x;\n        var y1 = this.end.y;\n        return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\nexport const Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof Line) || (obj instanceof Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented comapared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\nexport const Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = normalizeAngle(toDeg(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point(random(x1, x2), random(y1, y2));\n};\n\nPoint.prototype = {\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n\n        return (new Line(this, point)).bearing();\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n\n        return (new Line(this, p)).length();\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = toRad((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = toRad(normalizeAngle(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = snapToGrid(this.x, gx);\n        this.y = snapToGrid(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n\n        return (new Line(this, p)).squaredLength();\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = toRad(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\nexport const Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    svgString = svgString.trim();\n    if (svgString === '') return new Polyline();\n\n    var points = [];\n\n    var coords = svgString.split(/\\s*,\\s*|\\s+/);\n    var n = coords.length;\n    for (var i = 0; i < n; i += 2) {\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n\n    return new Polyline(points);\n};\n\nPolyline.prototype = {\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return new Polyline(); // if points array is empty\n\n        var newPoints = [];\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i].clone();\n            newPoints.push(point);\n        }\n\n        return new Polyline(newPoints);\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n\n            var segment = new Line(start, end); // current polyline segment\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    var rayEnd = new Point((x + xDifference), y); // right\n                    var ray = new Line(p, rayEnd);\n\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Returns a convex-hull polyline from this polyline.\n    // Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n    // Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n    // Minimal polyline is found (only vertices of the hull are reported, no collinear points).\n    convexHull: function() {\n\n        var i;\n        var n;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return new Polyline(); // if points array is empty\n\n        // step 1: find the starting point - point with the lowest y (if equality, highest x)\n        var startPoint;\n        for (i = 0; i < numPoints; i++) {\n            if (startPoint === undefined) {\n                // if this is the first point we see, set it as start point\n                startPoint = points[i];\n\n            } else if (points[i].y < startPoint.y) {\n                // start point should have lowest y from all points\n                startPoint = points[i];\n\n            } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n                // if two points have the lowest y, choose the one that has highest x\n                // there are no points to the right of startPoint - no ambiguity about theta 0\n                // if there are several coincident start point candidates, first one is reported\n                startPoint = points[i];\n            }\n        }\n\n        // step 2: sort the list of points\n        // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n        // step 2a: create the point records = [point, originalIndex, angle]\n        var sortedPointRecords = [];\n        for (i = 0; i < numPoints; i++) {\n\n            var angle = startPoint.theta(points[i]);\n            if (angle === 0) {\n                angle = 360; // give highest angle to start point\n                // the start point will end up at end of sorted list\n                // the start point will end up at beginning of hull points list\n            }\n\n            var entry = [points[i], i, angle];\n            sortedPointRecords.push(entry);\n        }\n\n        // step 2b: sort the list in place\n        sortedPointRecords.sort(function(record1, record2) {\n            // returning a negative number here sorts record1 before record2\n            // if first angle is smaller than second, first angle should come before second\n\n            var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n            if (sortOutput === 0) {\n                // if the two angles are equal, sort by originalIndex\n                sortOutput = record2[1] - record1[1]; // negative if first index larger\n                // coincident points will be sorted in reverse-numerical order\n                // so the coincident points with lower original index will be considered first\n            }\n\n            return sortOutput;\n        });\n\n        // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n        if (sortedPointRecords.length > 2) {\n            var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n            sortedPointRecords.unshift(startPointRecord);\n        }\n\n        // step 3a: go through sorted points in order and find those with right turns\n        // we want to get our results in clockwise order\n        var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n        var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n        var currentPointRecord;\n        var currentPoint;\n        var lastHullPointRecord;\n        var lastHullPoint;\n        var secondLastHullPointRecord;\n        var secondLastHullPoint;\n        while (sortedPointRecords.length !== 0) {\n\n            currentPointRecord = sortedPointRecords.pop();\n            currentPoint = currentPointRecord[0];\n\n            // check if point has already been discarded\n            // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n            if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n                // this point had an incorrect turn at some previous iteration of this loop\n                // this disqualifies it from possibly being on the hull\n                continue;\n            }\n\n            var correctTurnFound = false;\n            while (!correctTurnFound) {\n\n                if (hullPointRecords.length < 2) {\n                    // not enough points for comparison, just add current point\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else {\n                    lastHullPointRecord = hullPointRecords.pop();\n                    lastHullPoint = lastHullPointRecord[0];\n                    secondLastHullPointRecord = hullPointRecords.pop();\n                    secondLastHullPoint = secondLastHullPointRecord[0];\n\n                    var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                    if (crossProduct < 0) {\n                        // found a right turn\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        hullPointRecords.push(lastHullPointRecord);\n                        hullPointRecords.push(currentPointRecord);\n                        correctTurnFound = true;\n\n                    } else if (crossProduct === 0) {\n                        // the three points are collinear\n                        // three options:\n                        // there may be a 180 or 0 degree angle at lastHullPoint\n                        // or two of the three points are coincident\n                        var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                        var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                        if (abs(angleBetween - 180) < THRESHOLD) { // rouding around 180 to 180\n                            // if the cross product is 0 because the angle is 180 degrees\n                            // discard last hull point (add to insidePoints)\n                            //insidePoints.unshift(lastHullPoint);\n                            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullPointRecords.push(secondLastHullPointRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n\n                        } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                            // if the cross product is 0 because two points are the same\n                            // discard last hull point (add to insidePoints)\n                            //insidePoints.unshift(lastHullPoint);\n                            insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullPointRecords.push(secondLastHullPointRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n\n                        } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                            // if the cross product is 0 because the angle is 0 degrees\n                            // remove last hull point from hull BUT do not discard it\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullPointRecords.push(secondLastHullPointRecord);\n                            // put last hull point back into the sorted point records list\n                            sortedPointRecords.push(lastHullPointRecord);\n                            // we are switching the order of the 0deg and 180deg points\n                            // correct turn not found\n                        }\n\n                    } else {\n                        // found a left turn\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter of loop)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n                    }\n                }\n            }\n        }\n        // at this point, hullPointRecords contains the output points in clockwise order\n        // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n        // step 3b: remove duplicated startPointRecord from the end of the array\n        if (hullPointRecords.length > 2) {\n            hullPointRecords.pop();\n        }\n\n        // step 4: find the lowest originalIndex record and put it at the beginning of hull\n        var lowestHullIndex; // the lowest originalIndex on the hull\n        var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n        n = hullPointRecords.length;\n        for (i = 0; i < n; i++) {\n\n            var currentHullIndex = hullPointRecords[i][1];\n\n            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n                lowestHullIndex = currentHullIndex;\n                indexOfLowestHullIndexRecord = i;\n            }\n        }\n\n        var hullPointRecordsReordered = [];\n        if (indexOfLowestHullIndexRecord > 0) {\n            var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n            var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n        } else {\n            hullPointRecordsReordered = hullPointRecords;\n        }\n\n        var hullPoints = [];\n        n = hullPointRecordsReordered.length;\n        for (i = 0; i < n; i++) {\n            hullPoints.push(hullPointRecordsReordered[i][0]);\n        }\n\n        return new Polyline(hullPoints);\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new Line(l);\n        var intersections = [];\n        var points = this.points;\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            var a = points[i];\n            var b = points[i + 1];\n            var l2 = new Line(a, b);\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var a = points[i];\n            var b = points[i + 1];\n            var line = new Line(a, b);\n\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n        const threshold = opt.threshold || 0; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n\nexport const Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.prototype = {\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n\n        if (!angle) return this.clone();\n\n        var theta = toRad(angle);\n        var st = abs(sin(theta));\n        var ct = abs(cos(theta));\n        var w = this.width * ct + this.height * st;\n        var h = this.width * st + this.height * ct;\n        return new Rect(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n    },\n\n    bottomLeft: function() {\n\n        return new Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    containsPoint: function(p) {\n\n        p = new Point(p);\n        return p.x >= this.x && p.x <= this.x + this.width && p.y >= this.y && p.y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new Point(p);\n        var center = new Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, point.y);\n                case 'left':\n                    return new Point(this.x, point.y);\n                case 'bottom':\n                    return new Point(point.x, this.y + this.height);\n                case 'top':\n                    return new Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        const u = new Rect(rect);\n        const { x, y, width, height } = this;\n        const { x: rx, y: ry, width: rw, height: rh } = u;\n        const ux = u.x = min(x, rx);\n        const uy = u.y = min(y, ry);\n        u.width = max(x + width, rx + rw) - ux;\n        u.height = max(y + height, ry + rh) - uy;\n        return u;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\nexport const scale = {\n\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n    }\n};\n\nexport const normalizeAngle = function(angle) {\n\n    return (angle % 360) + (angle < 0 ? 360 : 0);\n};\n\nexport const snapToGrid = function(value, gridSize) {\n\n    return gridSize * round(value / gridSize);\n};\n\nexport const toDeg = function(rad) {\n\n    return (180 * rad / PI) % 360;\n};\n\nexport const toRad = function(deg, over360) {\n\n    over360 = over360 || false;\n    deg = over360 ? deg : (deg % 360);\n    return deg * PI / 180;\n};\n\n// Return a random integer from the interval [min,max], inclusive.\nexport const random = function(min, max) {\n\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = (min === undefined) ? 1 : min;\n        min = 0;\n\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n\n    return floor((math.random() * (max - min + 1)) + min);\n};\n\n// For backwards compatibility:\nexport const ellipse = Ellipse;\nexport const line = Line;\nexport const point = Point;\nexport const rect = Rect;\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nfunction extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = extend(segmentPrototype, Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new Point(+args[0], +args[1]);\n            this.controlPoint2 = new Point(+args[2], +args[3]);\n            this.end = new Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new Point(args[0]);\n            this.controlPoint2 = new Point(args[1]);\n            this.end = new Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = extend(segmentPrototype, Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = extend(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = extend(segmentPrototype, Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n\n"]},"metadata":{},"sourceType":"module"}