{"ast":null,"code":"import Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\nconst GraphCells = Backbone.Collection.extend({\n  initialize: function (models, opt) {\n    // Set the optional namespace where all model classes are defined.\n    if (opt.cellNamespace) {\n      this.cellNamespace = opt.cellNamespace;\n    } else {\n      /* global joint: true */\n      this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n      /* global joint: false */\n    }\n\n    this.graph = opt.graph;\n  },\n  model: function (attrs, opt) {\n    var collection = opt.collection;\n    var namespace = collection.cellNamespace; // Find the model class in the namespace or use the default one.\n\n    var ModelClass = attrs.type === 'link' ? Link : util.getByPath(namespace, attrs.type, '.') || Element;\n    var cell = new ModelClass(attrs, opt); // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n    // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n\n    if (!opt.dry) {\n      cell.graph = collection.graph;\n    }\n\n    return cell;\n  },\n  // `comparator` makes it easy to sort cells based on their `z` index.\n  comparator: function (model) {\n    return model.get('z') || 0;\n  }\n});\nexport const Graph = Backbone.Model.extend({\n  initialize: function (attrs, opt) {\n    opt = opt || {}; // Passing `cellModel` function in the options object to graph allows for\n    // setting models based on attribute objects. This is especially handy\n    // when processing JSON graphs that are in a different than JointJS format.\n\n    var cells = new GraphCells([], {\n      model: opt.cellModel,\n      cellNamespace: opt.cellNamespace,\n      graph: this\n    });\n    Backbone.Model.prototype.set.call(this, 'cells', cells); // Make all the events fired in the `cells` collection available.\n    // to the outside world.\n\n    cells.on('all', this.trigger, this); // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n    // they're already in the collection. Therefore, we're triggering sort manually here.\n\n    this.on('change:z', this._sortOnChangeZ, this); // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n    // for fast graph queries. All changes that affect the structure of the graph\n    // must be reflected in the `al` object. This object provides fast answers to\n    // questions such as \"what are the neighbours of this node\" or \"what\n    // are the sibling links of this link\".\n    // Outgoing edges per node. Note that we use a hash-table for the list\n    // of outgoing edges for a faster lookup.\n    // [nodeId] -> Object [edgeId] -> true\n\n    this._out = {}; // Ingoing edges per node.\n    // [nodeId] -> Object [edgeId] -> true\n\n    this._in = {}; // `_nodes` is useful for quick lookup of all the elements in the graph, without\n    // having to go through the whole cells array.\n    // [node ID] -> true\n\n    this._nodes = {}; // `_edges` is useful for quick lookup of all the links in the graph, without\n    // having to go through the whole cells array.\n    // [edgeId] -> true\n\n    this._edges = {};\n    this._batches = {};\n    cells.on('add', this._restructureOnAdd, this);\n    cells.on('remove', this._restructureOnRemove, this);\n    cells.on('reset', this._restructureOnReset, this);\n    cells.on('change:source', this._restructureOnChangeSource, this);\n    cells.on('change:target', this._restructureOnChangeTarget, this);\n    cells.on('remove', this._removeCell, this);\n  },\n  _sortOnChangeZ: function () {\n    this.get('cells').sort();\n  },\n  _restructureOnAdd: function (cell) {\n    if (cell.isLink()) {\n      this._edges[cell.id] = true;\n      var {\n        source,\n        target\n      } = cell.attributes;\n\n      if (source.id) {\n        (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n      }\n\n      if (target.id) {\n        (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n      }\n    } else {\n      this._nodes[cell.id] = true;\n    }\n  },\n  _restructureOnRemove: function (cell) {\n    if (cell.isLink()) {\n      delete this._edges[cell.id];\n      var {\n        source,\n        target\n      } = cell.attributes;\n\n      if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n        delete this._out[source.id][cell.id];\n      }\n\n      if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n        delete this._in[target.id][cell.id];\n      }\n    } else {\n      delete this._nodes[cell.id];\n    }\n  },\n  _restructureOnReset: function (cells) {\n    // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n    cells = cells.models;\n    this._out = {};\n    this._in = {};\n    this._nodes = {};\n    this._edges = {};\n    cells.forEach(this._restructureOnAdd, this);\n  },\n  _restructureOnChangeSource: function (link) {\n    var prevSource = link.previous('source');\n\n    if (prevSource.id && this._out[prevSource.id]) {\n      delete this._out[prevSource.id][link.id];\n    }\n\n    var source = link.attributes.source;\n\n    if (source.id) {\n      (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n    }\n  },\n  _restructureOnChangeTarget: function (link) {\n    var prevTarget = link.previous('target');\n\n    if (prevTarget.id && this._in[prevTarget.id]) {\n      delete this._in[prevTarget.id][link.id];\n    }\n\n    var target = link.get('target');\n\n    if (target.id) {\n      (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n    }\n  },\n  // Return all outbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getOutboundEdges: function (node) {\n    return this._out && this._out[node] || {};\n  },\n  // Return all inbound edges for the node. Return value is an object\n  // of the form: [edgeId] -> true\n  getInboundEdges: function (node) {\n    return this._in && this._in[node] || {};\n  },\n  toJSON: function () {\n    // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n    // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n    var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n    json.cells = this.get('cells').toJSON();\n    return json;\n  },\n  fromJSON: function (json, opt) {\n    if (!json.cells) {\n      throw new Error('Graph JSON must contain cells array.');\n    }\n\n    return this.set(json, opt);\n  },\n  set: function (key, val, opt) {\n    var attrs; // Handle both `key`, value and {key: value} style arguments.\n\n    if (typeof key === 'object') {\n      attrs = key;\n      opt = val;\n    } else {\n      (attrs = {})[key] = val;\n    } // Make sure that `cells` attribute is handled separately via resetCells().\n\n\n    if (attrs.hasOwnProperty('cells')) {\n      this.resetCells(attrs.cells, opt);\n      attrs = util.omit(attrs, 'cells');\n    } // The rest of the attributes are applied via original set method.\n\n\n    return Backbone.Model.prototype.set.call(this, attrs, opt);\n  },\n  clear: function (opt) {\n    opt = util.assign({}, opt, {\n      clear: true\n    });\n    var collection = this.get('cells');\n    if (collection.length === 0) return this;\n    this.startBatch('clear', opt); // The elements come after the links.\n\n    var cells = collection.sortBy(function (cell) {\n      return cell.isLink() ? 1 : 2;\n    });\n\n    do {\n      // Remove all the cells one by one.\n      // Note that all the links are removed first, so it's\n      // safe to remove the elements without removing the connected\n      // links first.\n      cells.shift().remove(opt);\n    } while (cells.length > 0);\n\n    this.stopBatch('clear');\n    return this;\n  },\n  _prepareCell: function (cell, opt) {\n    var attrs;\n\n    if (cell instanceof Backbone.Model) {\n      attrs = cell.attributes;\n\n      if (!cell.graph && (!opt || !opt.dry)) {\n        // An element can not be member of more than one graph.\n        // A cell stops being the member of the graph after it's explicitly removed.\n        cell.graph = this;\n      }\n    } else {\n      // In case we're dealing with a plain JS object, we have to set the reference\n      // to the `graph` right after the actual model is created. This happens in the `model()` function\n      // of `joint.dia.GraphCells`.\n      attrs = cell;\n    }\n\n    if (!util.isString(attrs.type)) {\n      throw new TypeError('dia.Graph: cell type must be a string.');\n    }\n\n    return cell;\n  },\n  minZIndex: function () {\n    var firstCell = this.get('cells').first();\n    return firstCell ? firstCell.get('z') || 0 : 0;\n  },\n  maxZIndex: function () {\n    var lastCell = this.get('cells').last();\n    return lastCell ? lastCell.get('z') || 0 : 0;\n  },\n  addCell: function (cell, opt) {\n    if (Array.isArray(cell)) {\n      return this.addCells(cell, opt);\n    }\n\n    if (cell instanceof Backbone.Model) {\n      if (!cell.has('z')) {\n        cell.set('z', this.maxZIndex() + 1);\n      }\n    } else if (cell.z === undefined) {\n      cell.z = this.maxZIndex() + 1;\n    }\n\n    this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n    return this;\n  },\n  addCells: function (cells, opt) {\n    if (cells.length === 0) return this;\n    cells = util.flattenDeep(cells);\n    opt.maxPosition = opt.position = cells.length - 1;\n    this.startBatch('add', opt);\n    cells.forEach(function (cell) {\n      this.addCell(cell, opt);\n      opt.position--;\n    }, this);\n    this.stopBatch('add', opt);\n    return this;\n  },\n  // When adding a lot of cells, it is much more efficient to\n  // reset the entire cells collection in one go.\n  // Useful for bulk operations and optimizations.\n  resetCells: function (cells, opt) {\n    var preparedCells = util.toArray(cells).map(function (cell) {\n      return this._prepareCell(cell, opt);\n    }, this);\n    this.get('cells').reset(preparedCells, opt);\n    return this;\n  },\n  removeCells: function (cells, opt) {\n    if (cells.length) {\n      this.startBatch('remove');\n      util.invoke(cells, 'remove', opt);\n      this.stopBatch('remove');\n    }\n\n    return this;\n  },\n  _removeCell: function (cell, collection, options) {\n    options = options || {};\n\n    if (!options.clear) {\n      // Applications might provide a `disconnectLinks` option set to `true` in order to\n      // disconnect links when a cell is removed rather then removing them. The default\n      // is to remove all the associated links.\n      if (options.disconnectLinks) {\n        this.disconnectLinks(cell, options);\n      } else {\n        this.removeLinks(cell, options);\n      }\n    } // Silently remove the cell from the cells collection. Silently, because\n    // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n    // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n    // would be triggered on the graph model.\n\n\n    this.get('cells').remove(cell, {\n      silent: true\n    });\n\n    if (cell.graph === this) {\n      // Remove the element graph reference only if the cell is the member of this graph.\n      cell.graph = null;\n    }\n  },\n  // Get a cell by `id`.\n  getCell: function (id) {\n    return this.get('cells').get(id);\n  },\n  getCells: function () {\n    return this.get('cells').toArray();\n  },\n  getElements: function () {\n    return Object.keys(this._nodes).map(this.getCell, this);\n  },\n  getLinks: function () {\n    return Object.keys(this._edges).map(this.getCell, this);\n  },\n  getFirstCell: function () {\n    return this.get('cells').first();\n  },\n  getLastCell: function () {\n    return this.get('cells').last();\n  },\n  // Get all inbound and outbound links connected to the cell `model`.\n  getConnectedLinks: function (model, opt) {\n    opt = opt || {};\n    var indirect = opt.indirect;\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    } // the final array of connected link models\n\n\n    var links = []; // a hash table of connected edges of the form: [edgeId] -> true\n    // used for quick lookups to check if we already added a link\n\n    var edges = {};\n\n    if (outbound) {\n      addOutbounds(this, model);\n    }\n\n    if (inbound) {\n      addInbounds(this, model);\n    }\n\n    function addOutbounds(graph, model) {\n      util.forIn(graph.getOutboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n\n      if (indirect && model.isLink()) {\n        var outCell = model.getTargetCell();\n\n        if (outCell && outCell.isLink()) {\n          if (!edges[outCell.id]) {\n            links.push(outCell);\n            addOutbounds(graph, outCell);\n          }\n        }\n      }\n    }\n\n    function addInbounds(graph, model) {\n      util.forIn(graph.getInboundEdges(model.id), function (_, edge) {\n        // skip links that were already added\n        // (those must be self-loop links)\n        // (because they are inbound and outbound edges of the same two elements)\n        if (edges[edge]) return;\n        var link = graph.getCell(edge);\n        links.push(link);\n        edges[edge] = true;\n\n        if (indirect) {\n          if (inbound) addInbounds(graph, link);\n          if (outbound) addOutbounds(graph, link);\n        }\n      }.bind(graph));\n\n      if (indirect && model.isLink()) {\n        var inCell = model.getSourceCell();\n\n        if (inCell && inCell.isLink()) {\n          if (!edges[inCell.id]) {\n            links.push(inCell);\n            addInbounds(graph, inCell);\n          }\n        }\n      }\n    } // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n\n\n    if (opt.deep) {\n      var embeddedCells = model.getEmbeddedCells({\n        deep: true\n      }); // in the first round, we collect all the embedded elements\n\n      var embeddedElements = {};\n      embeddedCells.forEach(function (cell) {\n        if (cell.isElement()) {\n          embeddedElements[cell.id] = true;\n        }\n      });\n      embeddedCells.forEach(function (cell) {\n        if (cell.isLink()) return;\n\n        if (outbound) {\n          util.forIn(this.getOutboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id; // if `includeEnclosed` option is falsy, skip enclosed links\n\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n\n        if (inbound) {\n          util.forIn(this.getInboundEdges(cell.id), function (exists, edge) {\n            if (!edges[edge]) {\n              var edgeCell = this.getCell(edge);\n              var {\n                source,\n                target\n              } = edgeCell.attributes;\n              var sourceId = source.id;\n              var targetId = target.id; // if `includeEnclosed` option is falsy, skip enclosed links\n\n              if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {\n                return;\n              }\n\n              links.push(this.getCell(edge));\n              edges[edge] = true;\n            }\n          }.bind(this));\n        }\n      }, this);\n    }\n\n    return links;\n  },\n  getNeighbors: function (model, opt) {\n    opt || (opt = {});\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    var neighbors = this.getConnectedLinks(model, opt).reduce(function (res, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      var loop = link.hasLoop(opt); // Discard if it is a point, or if the neighbor was already added.\n\n      if (inbound && util.has(source, 'id') && !res[source.id]) {\n        var sourceElement = this.getCell(source.id);\n\n        if (sourceElement.isElement()) {\n          if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {\n            res[source.id] = sourceElement;\n          }\n        }\n      } // Discard if it is a point, or if the neighbor was already added.\n\n\n      if (outbound && util.has(target, 'id') && !res[target.id]) {\n        var targetElement = this.getCell(target.id);\n\n        if (targetElement.isElement()) {\n          if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {\n            res[target.id] = targetElement;\n          }\n        }\n      }\n\n      return res;\n    }.bind(this), {});\n\n    if (model.isLink()) {\n      if (inbound) {\n        var sourceCell = model.getSourceCell();\n\n        if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n          neighbors[sourceCell.id] = sourceCell;\n        }\n      }\n\n      if (outbound) {\n        var targetCell = model.getTargetCell();\n\n        if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n          neighbors[targetCell.id] = targetCell;\n        }\n      }\n    }\n\n    return util.toArray(neighbors);\n  },\n  getCommonAncestor: function ()\n  /* cells */\n  {\n    var cellsAncestors = Array.from(arguments).map(function (cell) {\n      var ancestors = [];\n      var parentId = cell.get('parent');\n\n      while (parentId) {\n        ancestors.push(parentId);\n        parentId = this.getCell(parentId).get('parent');\n      }\n\n      return ancestors;\n    }, this);\n    cellsAncestors = cellsAncestors.sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var commonAncestor = util.toArray(cellsAncestors.shift()).find(function (ancestor) {\n      return cellsAncestors.every(function (cellAncestors) {\n        return cellAncestors.includes(ancestor);\n      });\n    });\n    return this.getCell(commonAncestor);\n  },\n  // Find the whole branch starting at `element`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getSuccessors: function (element, opt) {\n    opt = opt || {};\n    var res = []; // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      outbound: true\n    }));\n    return res;\n  },\n  cloneCells: cloneCells,\n  // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n  // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n  // Return a map of the form: [original cell ID] -> [clone].\n  cloneSubgraph: function (cells, opt) {\n    var subgraph = this.getSubgraph(cells, opt);\n    return this.cloneCells(subgraph);\n  },\n  // Return `cells` and all the connected links that connect cells in the `cells` array.\n  // If `opt.deep` is `true`, return all the cells including all their embedded cells\n  // and all the links that connect any of the returned cells.\n  // For example, for a single shallow element, the result is that very same element.\n  // For two elements connected with a link: `A --- L ---> B`, the result for\n  // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n  getSubgraph: function (cells, opt) {\n    opt = opt || {};\n    var subgraph = []; // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n\n    var cellMap = {};\n    var elements = [];\n    var links = [];\n    util.toArray(cells).forEach(function (cell) {\n      if (!cellMap[cell.id]) {\n        subgraph.push(cell);\n        cellMap[cell.id] = cell;\n\n        if (cell.isLink()) {\n          links.push(cell);\n        } else {\n          elements.push(cell);\n        }\n      }\n\n      if (opt.deep) {\n        var embeds = cell.getEmbeddedCells({\n          deep: true\n        });\n        embeds.forEach(function (embed) {\n          if (!cellMap[embed.id]) {\n            subgraph.push(embed);\n            cellMap[embed.id] = embed;\n\n            if (embed.isLink()) {\n              links.push(embed);\n            } else {\n              elements.push(embed);\n            }\n          }\n        });\n      }\n    });\n    links.forEach(function (link) {\n      // For links, return their source & target (if they are elements - not points).\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      if (source.id && !cellMap[source.id]) {\n        var sourceElement = this.getCell(source.id);\n        subgraph.push(sourceElement);\n        cellMap[sourceElement.id] = sourceElement;\n        elements.push(sourceElement);\n      }\n\n      if (target.id && !cellMap[target.id]) {\n        var targetElement = this.getCell(target.id);\n        subgraph.push(this.getCell(target.id));\n        cellMap[targetElement.id] = targetElement;\n        elements.push(targetElement);\n      }\n    }, this);\n    elements.forEach(function (element) {\n      // For elements, include their connected links if their source/target is in the subgraph;\n      var links = this.getConnectedLinks(element, opt);\n      links.forEach(function (link) {\n        var {\n          source,\n          target\n        } = link.attributes;\n\n        if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n          subgraph.push(link);\n          cellMap[link.id] = link;\n        }\n      });\n    }, this);\n    return subgraph;\n  },\n  // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n  getPredecessors: function (element, opt) {\n    opt = opt || {};\n    var res = []; // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n\n    this.search(element, function (el) {\n      if (el !== element) {\n        res.push(el);\n      }\n    }, util.assign({}, opt, {\n      inbound: true\n    }));\n    return res;\n  },\n  // Perform search on the graph.\n  // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n  // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // `iteratee` is a function of the form `function(element) {}`.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  search: function (element, iteratee, opt) {\n    opt = opt || {};\n\n    if (opt.breadthFirst) {\n      this.bfs(element, iteratee, opt);\n    } else {\n      this.dfs(element, iteratee, opt);\n    }\n  },\n  // Breadth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // where `element` is the currently visited element and `distance` is the distance of that element\n  // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n  // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n  // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n  // If `iteratee` explicitly returns `false`, the searching stops.\n  bfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n\n    while (queue.length > 0) {\n      var next = queue.shift();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.push(neighbor);\n      }\n    }\n  },\n  // Depth-first search.\n  // If `opt.deep` is `true`, take into account embedded elements too.\n  // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n  // `iteratee` is a function of the form `function(element, distance) {}`.\n  // If `iteratee` explicitly returns `false`, the search stops.\n  dfs: function (element, iteratee, opt = {}) {\n    const visited = {};\n    const distance = {};\n    const queue = [];\n    queue.push(element);\n    distance[element.id] = 0;\n\n    while (queue.length > 0) {\n      const next = queue.pop();\n      if (visited[next.id]) continue;\n      visited[next.id] = true;\n      if (iteratee.call(this, next, distance[next.id]) === false) continue;\n      const neighbors = this.getNeighbors(next, opt);\n      const lastIndex = queue.length;\n\n      for (let i = 0, n = neighbors.length; i < n; i++) {\n        const neighbor = neighbors[i];\n        distance[neighbor.id] = distance[next.id] + 1;\n        queue.splice(lastIndex, 0, neighbor);\n      }\n    }\n  },\n  // Get all the roots of the graph. Time complexity: O(|V|).\n  getSources: function () {\n    var sources = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._in[node] || util.isEmpty(this._in[node])) {\n        sources.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sources;\n  },\n  // Get all the leafs of the graph. Time complexity: O(|V|).\n  getSinks: function () {\n    var sinks = [];\n    util.forIn(this._nodes, function (exists, node) {\n      if (!this._out[node] || util.isEmpty(this._out[node])) {\n        sinks.push(this.getCell(node));\n      }\n    }.bind(this));\n    return sinks;\n  },\n  // Return `true` if `element` is a root. Time complexity: O(1).\n  isSource: function (element) {\n    return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n  },\n  // Return `true` if `element` is a leaf. Time complexity: O(1).\n  isSink: function (element) {\n    return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n  },\n  // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n  isSuccessor: function (elementA, elementB) {\n    var isSuccessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isSuccessor = true;\n        return false;\n      }\n    }, {\n      outbound: true\n    });\n    return isSuccessor;\n  },\n  // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n  isPredecessor: function (elementA, elementB) {\n    var isPredecessor = false;\n    this.search(elementA, function (element) {\n      if (element === elementB && element !== elementA) {\n        isPredecessor = true;\n        return false;\n      }\n    }, {\n      inbound: true\n    });\n    return isPredecessor;\n  },\n  // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n  // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n  // for more details.\n  // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n  // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n  isNeighbor: function (elementA, elementB, opt) {\n    opt = opt || {};\n    var inbound = opt.inbound;\n    var outbound = opt.outbound;\n\n    if (inbound === undefined && outbound === undefined) {\n      inbound = outbound = true;\n    }\n\n    var isNeighbor = false;\n    this.getConnectedLinks(elementA, opt).forEach(function (link) {\n      var {\n        source,\n        target\n      } = link.attributes; // Discard if it is a point.\n\n      if (inbound && util.has(source, 'id') && source.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      } // Discard if it is a point, or if the neighbor was already added.\n\n\n      if (outbound && util.has(target, 'id') && target.id === elementB.id) {\n        isNeighbor = true;\n        return false;\n      }\n    });\n    return isNeighbor;\n  },\n  // Disconnect links connected to the cell `model`.\n  disconnectLinks: function (model, opt) {\n    this.getConnectedLinks(model).forEach(function (link) {\n      link.set(link.attributes.source.id === model.id ? 'source' : 'target', {\n        x: 0,\n        y: 0\n      }, opt);\n    });\n  },\n  // Remove links connected to the cell `model` completely.\n  removeLinks: function (model, opt) {\n    util.invoke(this.getConnectedLinks(model), 'remove', opt);\n  },\n  // Find all elements at given point\n  findModelsFromPoint: function (p) {\n    return this.getElements().filter(function (el) {\n      return el.getBBox().containsPoint(p);\n    });\n  },\n  // Find all elements in given area\n  findModelsInArea: function (rect, opt) {\n    rect = g.rect(rect);\n    opt = util.defaults(opt || {}, {\n      strict: false\n    });\n    var method = opt.strict ? 'containsRect' : 'intersect';\n    return this.getElements().filter(function (el) {\n      return rect[method](el.getBBox());\n    });\n  },\n  // Find all elements under the given element.\n  findModelsUnderElement: function (element, opt) {\n    opt = util.defaults(opt || {}, {\n      searchBy: 'bbox'\n    });\n    var bbox = element.getBBox();\n    var elements = opt.searchBy === 'bbox' ? this.findModelsInArea(bbox) : this.findModelsFromPoint(bbox[opt.searchBy]()); // don't account element itself or any of its descendants\n\n    return elements.filter(function (el) {\n      return element.id !== el.id && !el.isEmbeddedIn(element);\n    });\n  },\n  // Return bounding box of all elements.\n  getBBox: function () {\n    return this.getCellsBBox(this.getCells());\n  },\n  // Return the bounding box of all cells in array provided.\n  getCellsBBox: function (cells, opt) {\n    opt || (opt = {});\n    return util.toArray(cells).reduce(function (memo, cell) {\n      var rect = cell.getBBox(opt);\n      if (!rect) return memo;\n      var angle = cell.angle();\n      if (angle) rect = rect.bbox(angle);\n\n      if (memo) {\n        return memo.union(rect);\n      }\n\n      return rect;\n    }, null);\n  },\n  translate: function (dx, dy, opt) {\n    // Don't translate cells that are embedded in any other cell.\n    var cells = this.getCells().filter(function (cell) {\n      return !cell.isEmbedded();\n    });\n    util.invoke(cells, 'translate', dx, dy, opt);\n    return this;\n  },\n  resize: function (width, height, opt) {\n    return this.resizeCells(width, height, this.getCells(), opt);\n  },\n  resizeCells: function (width, height, cells, opt) {\n    // `getBBox` method returns `null` if no elements provided.\n    // i.e. cells can be an array of links\n    var bbox = this.getCellsBBox(cells);\n\n    if (bbox) {\n      var sx = Math.max(width / bbox.width, 0);\n      var sy = Math.max(height / bbox.height, 0);\n      util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n    }\n\n    return this;\n  },\n  startBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) + 1;\n    return this.trigger('batch:start', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  stopBatch: function (name, data) {\n    data = data || {};\n    this._batches[name] = (this._batches[name] || 0) - 1;\n    return this.trigger('batch:stop', util.assign({}, data, {\n      batchName: name\n    }));\n  },\n  hasActiveBatch: function (name) {\n    const batches = this._batches;\n    let names;\n\n    if (arguments.length === 0) {\n      names = Object.keys(batches);\n    } else if (Array.isArray(name)) {\n      names = name;\n    } else {\n      names = [name];\n    }\n\n    return names.some(batch => batches[batch] > 0);\n  }\n}, {\n  validations: {\n    multiLinks: function (graph, link) {\n      // Do not allow multiple links to have the same source and target.\n      var {\n        source,\n        target\n      } = link.attributes;\n\n      if (source.id && target.id) {\n        var sourceModel = link.getSourceCell();\n\n        if (sourceModel) {\n          var connectedLinks = graph.getConnectedLinks(sourceModel, {\n            outbound: true\n          });\n          var sameLinks = connectedLinks.filter(function (_link) {\n            var {\n              source: _source,\n              target: _target\n            } = _link.attributes;\n            return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);\n          });\n\n          if (sameLinks.length > 1) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n    linkPinning: function (_graph, link) {\n      var {\n        source,\n        target\n      } = link.attributes;\n      return source.id && target.id;\n    }\n  }\n});\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/dia/Graph.mjs"],"names":["Backbone","util","g","Link","Element","wrappers","wrapWith","cloneCells","GraphCells","Collection","extend","initialize","models","opt","cellNamespace","joint","has","shapes","graph","model","attrs","collection","namespace","ModelClass","type","getByPath","cell","dry","comparator","get","Graph","Model","cells","cellModel","prototype","set","call","on","trigger","_sortOnChangeZ","_out","_in","_nodes","_edges","_batches","_restructureOnAdd","_restructureOnRemove","_restructureOnReset","_restructureOnChangeSource","_restructureOnChangeTarget","_removeCell","sort","isLink","id","source","target","attributes","forEach","link","prevSource","previous","prevTarget","getOutboundEdges","node","getInboundEdges","toJSON","json","apply","arguments","fromJSON","Error","key","val","hasOwnProperty","resetCells","omit","clear","assign","length","startBatch","sortBy","shift","remove","stopBatch","_prepareCell","isString","TypeError","minZIndex","firstCell","first","maxZIndex","lastCell","last","addCell","Array","isArray","addCells","z","undefined","add","flattenDeep","maxPosition","position","preparedCells","toArray","map","reset","removeCells","invoke","options","disconnectLinks","removeLinks","silent","getCell","getCells","getElements","Object","keys","getLinks","getFirstCell","getLastCell","getConnectedLinks","indirect","inbound","outbound","links","edges","addOutbounds","addInbounds","forIn","_","edge","push","bind","outCell","getTargetCell","inCell","getSourceCell","deep","embeddedCells","getEmbeddedCells","embeddedElements","isElement","exists","edgeCell","sourceId","targetId","includeEnclosed","getNeighbors","neighbors","reduce","res","loop","hasLoop","sourceElement","isEmbeddedIn","targetElement","sourceCell","targetCell","getCommonAncestor","cellsAncestors","from","ancestors","parentId","a","b","commonAncestor","find","ancestor","every","cellAncestors","includes","getSuccessors","element","search","el","cloneSubgraph","subgraph","getSubgraph","cellMap","elements","embeds","embed","getPredecessors","iteratee","breadthFirst","bfs","dfs","visited","distance","queue","next","i","n","neighbor","pop","lastIndex","splice","getSources","sources","isEmpty","getSinks","sinks","isSource","isSink","isSuccessor","elementA","elementB","isPredecessor","isNeighbor","x","y","findModelsFromPoint","p","filter","getBBox","containsPoint","findModelsInArea","rect","defaults","strict","method","findModelsUnderElement","searchBy","bbox","getCellsBBox","memo","angle","union","translate","dx","dy","isEmbedded","resize","width","height","resizeCells","sx","Math","max","sy","origin","name","data","batchName","hasActiveBatch","batches","names","some","batch","validations","multiLinks","sourceModel","connectedLinks","sameLinks","_link","_source","_target","port","linkPinning","_graph"],"mappings":"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","sourcesContent":["import Backbone from 'backbone';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nimport { Link } from './Link.mjs';\nimport { Element } from './Element.mjs';\nimport { wrappers, wrapWith } from '../util/wrappers.mjs';\nimport { cloneCells } from '../util/index.mjs';\n\nconst GraphCells = Backbone.Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* global joint: true */\n            this.cellNamespace = typeof joint !== 'undefined' && util.has(joint, 'shapes') ? joint.shapes : null;\n            /* global joint: false */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        var collection = opt.collection;\n        var namespace = collection.cellNamespace;\n\n        // Find the model class in the namespace or use the default one.\n        var ModelClass = (attrs.type === 'link')\n            ? Link\n            : util.getByPath(namespace, attrs.type, '.') || Element;\n\n        var cell = new ModelClass(attrs, opt);\n        // Add a reference to the graph. It is necessary to do this here because this is the earliest place\n        // where a new model is created from a plain JS object. For other objects, see `joint.dia.Graph>>_prepareCell()`.\n        if (!opt.dry) {\n            cell.graph = collection.graph;\n        }\n\n        return cell;\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nexport const Graph = Backbone.Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        Backbone.Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // Backbone automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells Backbone collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function() {\n\n        // Backbone does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = Backbone.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON();\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = util.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return Backbone.Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = util.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell, opt) {\n\n        var attrs;\n        if (cell instanceof Backbone.Model) {\n            attrs = cell.attributes;\n            if (!cell.graph && (!opt || !opt.dry)) {\n                // An element can not be member of more than one graph.\n                // A cell stops being the member of the graph after it's explicitly removed.\n                cell.graph = this;\n            }\n        } else {\n            // In case we're dealing with a plain JS object, we have to set the reference\n            // to the `graph` right after the actual model is created. This happens in the `model()` function\n            // of `joint.dia.GraphCells`.\n            attrs = cell;\n        }\n\n        if (!util.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof Backbone.Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = util.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = util.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            util.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n\n        if (cell.graph === this) {\n            // Remove the element graph reference only if the cell is the member of this graph.\n            cell.graph = null;\n        }\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return Object.keys(this._nodes).map(this.getCell, this);\n    },\n\n    getLinks: function() {\n\n        return Object.keys(this._edges).map(this.getCell, this);\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            util.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            util.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    util.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    util.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && util.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return util.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = util.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        util.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, util.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || util.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        util.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || util.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || util.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || util.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && util.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && util.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        util.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all elements at given point\n    findModelsFromPoint: function(p) {\n\n        return this.getElements().filter(function(el) {\n            return el.getBBox().containsPoint(p);\n        });\n    },\n\n    // Find all elements in given area\n    findModelsInArea: function(rect, opt) {\n\n        rect = g.rect(rect);\n        opt = util.defaults(opt || {}, { strict: false });\n\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return this.getElements().filter(function(el) {\n            return rect[method](el.getBBox());\n        });\n    },\n\n    // Find all elements under the given element.\n    findModelsUnderElement: function(element, opt) {\n\n        opt = util.defaults(opt || {}, { searchBy: 'bbox' });\n\n        var bbox = element.getBBox();\n        var elements = (opt.searchBy === 'bbox')\n            ? this.findModelsInArea(bbox)\n            : this.findModelsFromPoint(bbox[opt.searchBy]());\n\n        // don't account element itself or any of its descendants\n        return elements.filter(function(el) {\n            return element.id !== el.id && !el.isEmbeddedIn(element);\n        });\n    },\n\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt) {\n        opt || (opt = {});\n        return util.toArray(cells).reduce(function(memo, cell) {\n            var rect = cell.getBBox(opt);\n            if (!rect) return memo;\n            var angle = cell.angle();\n            if (angle) rect = rect.bbox(angle);\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        util.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            util.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', util.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', util.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\nwrapWith(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], wrappers.cells);\n"]},"metadata":{},"sourceType":"module"}