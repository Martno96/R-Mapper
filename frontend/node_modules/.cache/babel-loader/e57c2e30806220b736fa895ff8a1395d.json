{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\nvar config = {\n  // size of the step to find a route (the grid of the manhattan pathfinder)\n  step: 10,\n  // the number of route finding loops that cause the router to abort\n  // returns fallback route instead\n  maximumLoops: 2000,\n  // the number of decimal places to round floating point coordinates\n  precision: 1,\n  // maximum change of direction\n  maxAllowedDirectionChange: 90,\n  // should the router use perpendicular linkView option?\n  // does not connect anchor of element but rather a point close-by that is orthogonal\n  // this looks much better\n  perpendicular: true,\n  // should the source and/or target not be considered as obstacles?\n  excludeEnds: [],\n  // 'source', 'target'\n  // should certain types of elements not be considered as obstacles?\n  excludeTypes: ['basic.Text'],\n  // possible starting directions from an element\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  // possible ending directions to an element\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  // specify the directions used above and what they mean\n  directionMap: {\n    top: {\n      x: 0,\n      y: -1\n    },\n    right: {\n      x: 1,\n      y: 0\n    },\n    bottom: {\n      x: 0,\n      y: 1\n    },\n    left: {\n      x: -1,\n      y: 0\n    }\n  },\n  // cost of an orthogonal step\n  cost: function () {\n    return this.step;\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }];\n  },\n  // a penalty received for direction change\n  penalties: function () {\n    return {\n      0: 0,\n      45: this.step / 2,\n      90: this.step / 2\n    };\n  },\n  // padding applied on the element bounding boxes\n  paddingBox: function () {\n    var step = this.step;\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step\n    };\n  },\n  // a router to use when the manhattan router fails\n  // (one of the partial routes returns null)\n  fallbackRouter: function (vertices, opt, linkView) {\n    if (!util.isFunction(orthogonal)) {\n      throw new Error('Manhattan requires the orthogonal router as default fallback.');\n    }\n\n    return orthogonal(vertices, util.assign({}, config, opt), linkView);\n  },\n\n  /* Deprecated */\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    return null; // null result will trigger the fallbackRouter\n    // left for reference:\n\n    /*// Find an orthogonal route ignoring obstacles.\n     var point = ((opt.previousDirAngle || 0) % 180 === 0)\n            ? new g.Point(from.x, to.y)\n            : new g.Point(to.x, from.y);\n     return [point];*/\n  },\n  // if a function is provided, it's used to route the link while dragging an end\n  // i.e. function(from, to, opt) { return []; }\n  draggingRoute: null\n}; // HELPER CLASSES //\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\n\nfunction ObstacleMap(opt) {\n  this.map = {};\n  this.options = opt; // tells how to divide the paper when creating the elements map\n\n  this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function (graph, link) {\n  var opt = this.options; // source or target element could be excluded from set of obstacles\n\n  var excludedEnds = util.toArray(opt.excludeEnds).reduce(function (res, item) {\n    var end = link.get(item);\n\n    if (end) {\n      var cell = graph.getCell(end.id);\n\n      if (cell) {\n        res.push(cell);\n      }\n    }\n\n    return res;\n  }, []); // Exclude any embedded elements from the source and the target element.\n\n  var excludedAncestors = [];\n  var source = graph.getCell(link.get('source').id);\n\n  if (source) {\n    excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  }\n\n  var target = graph.getCell(link.get('target').id);\n\n  if (target) {\n    excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function (cell) {\n      return cell.id;\n    }));\n  } // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n  // in any obstacle?) (a simplified grid search).\n  // The paper is divided into smaller cells, where each holds information about which\n  // elements belong to it. When we query whether a point lies inside an obstacle we\n  // don't need to go through all obstacles, we check only those in a particular cell.\n\n\n  var mapGridSize = this.mapGridSize;\n  graph.getElements().reduce(function (map, element) {\n    var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n    var isExcludedEnd = excludedEnds.find(function (excluded) {\n      return excluded.id === element.id;\n    });\n    var isExcludedAncestor = excludedAncestors.includes(element.id);\n    var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n\n    if (!isExcluded) {\n      var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n      var origin = bbox.origin().snapToGrid(mapGridSize);\n      var corner = bbox.corner().snapToGrid(mapGridSize);\n\n      for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n        for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n          var gridKey = x + '@' + y;\n          map[gridKey] = map[gridKey] || [];\n          map[gridKey].push(bbox);\n        }\n      }\n    }\n\n    return map;\n  }, this.map);\n  return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function (point) {\n  var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n  return util.toArray(this.map[mapKey]).every(function (obstacle) {\n    return !obstacle.containsPoint(point);\n  });\n}; // Sorted Set\n// Set of items sorted by given value.\n\n\nfunction SortedSet() {\n  this.items = [];\n  this.hash = {};\n  this.values = {};\n  this.OPEN = 1;\n  this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function (item, value) {\n  if (this.hash[item]) {\n    // item removal\n    this.items.splice(this.items.indexOf(item), 1);\n  } else {\n    this.hash[item] = this.OPEN;\n  }\n\n  this.values[item] = value;\n  var index = util.sortedIndex(this.items, item, function (i) {\n    return this.values[i];\n  }.bind(this));\n  this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function (item) {\n  this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function (item) {\n  return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function (item) {\n  return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function () {\n  return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function () {\n  var item = this.items.shift();\n  this.remove(item);\n  return item;\n}; // HELPERS //\n// return source bbox\n\n\nfunction getSourceBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.sourceBBox.clone();\n} // return target bbox\n\n\nfunction getTargetBBox(linkView, opt) {\n  // expand by padding box\n  if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n  return linkView.targetBBox.clone();\n} // return source anchor\n\n\nfunction getSourceAnchor(linkView, opt) {\n  if (linkView.sourceAnchor) return linkView.sourceAnchor; // fallback: center of bbox\n\n  var sourceBBox = getSourceBBox(linkView, opt);\n  return sourceBBox.center();\n} // return target anchor\n\n\nfunction getTargetAnchor(linkView, opt) {\n  if (linkView.targetAnchor) return linkView.targetAnchor; // fallback: center of bbox\n\n  var targetBBox = getTargetBBox(linkView, opt);\n  return targetBBox.center(); // default\n} // returns a direction index from start point to end point\n// corrects for grid deformation between start and end\n\n\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n  var quadrant = 360 / numDirections;\n  var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n  var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n} // helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\n\n\nfunction fixAngleEnd(start, end, grid, opt) {\n  var step = opt.step;\n  var diffX = end.x - start.x;\n  var diffY = end.y - start.y;\n  var gridStepsX = diffX / grid.x;\n  var gridStepsY = diffY / grid.y;\n  var distanceX = gridStepsX * step;\n  var distanceY = gridStepsY * step;\n  return new g.Point(start.x + distanceX, start.y + distanceY);\n} // return the change in direction between two direction angles\n\n\nfunction getDirectionChange(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n} // fix direction offsets according to current grid\n\n\nfunction getGridOffsets(directions, grid, opt) {\n  var step = opt.step;\n  util.toArray(opt.directions).forEach(function (direction) {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n} // get grid size in x and y dimensions, adapted to source and target positions\n\n\nfunction getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n} // helper function for getGrid()\n\n\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) return step;\n  var absDiff = Math.abs(diff);\n  var numSteps = Math.round(absDiff / step); // return absDiff if less than one step apart\n\n  if (!numSteps) return absDiff; // otherwise, return corrected step\n\n  var roundedDiff = numSteps * step;\n  var remainder = absDiff - roundedDiff;\n  var stepCorrection = remainder / numSteps;\n  return step + stepCorrection;\n} // return a clone of point snapped to grid\n\n\nfunction snapToGrid(point, grid) {\n  var source = grid.source;\n  var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n  var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new g.Point(snappedX, snappedY);\n} // round the point to opt.precision\n\n\nfunction round(point, precision) {\n  return point.round(precision);\n} // snap to grid and then round the point\n\n\nfunction align(point, grid, precision) {\n  return round(snapToGrid(point.clone(), grid), precision);\n} // return a string representing the point\n// string is rounded in both dimensions\n\n\nfunction getKey(point) {\n  return point.clone().toString();\n} // return a normalized vector from given point\n// used to determine the direction of a difference of two points\n\n\nfunction normalizePoint(point) {\n  return new g.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n} // PATHFINDING //\n// reconstructs a route by concatenating points with their parents\n\n\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n  var route = [];\n  var prevDiff = normalizePoint(to.difference(tailPoint)); // tailPoint is assumed to be aligned already\n\n  var currentKey = getKey(tailPoint);\n  var parent = parents[currentKey];\n  var point;\n\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    var diff = normalizePoint(point.difference(parent));\n\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    } // parent is assumed to be aligned already\n\n\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  } // leadPoint is assumed to be aligned already\n\n\n  var leadPoint = points[currentKey];\n  var fromDiff = normalizePoint(leadPoint.difference(from));\n\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n\n  return route;\n} // heuristic method to determine the distance between two points\n\n\nfunction estimateCost(from, endPoints) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = from.manhattanDistance(endPoints[i]);\n    if (cost < min) min = cost;\n  }\n\n  return min;\n} // find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\n\n\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n  var precision = opt.precision;\n  var directionMap = opt.directionMap;\n  var anchorCenterVector = anchor.difference(bbox.center());\n  var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n  var dirList = util.toArray(directionList);\n  var rectPoints = keys.reduce(function (res, key) {\n    if (dirList.includes(key)) {\n      var direction = directionMap[key]; // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n      // even if anchor lies outside of bbox\n\n      var endpoint = new g.Point(anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height));\n      var intersectionLine = new g.Line(anchor, endpoint); // get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n\n      var intersections = intersectionLine.intersect(bbox) || [];\n      var numIntersections = intersections.length;\n      var farthestIntersectionDistance;\n      var farthestIntersection = null;\n\n      for (var i = 0; i < numIntersections; i++) {\n        var currentIntersection = intersections[i];\n        var distance = anchor.squaredDistance(currentIntersection);\n\n        if (farthestIntersectionDistance === undefined || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = currentIntersection;\n        }\n      } // if an intersection was found in this direction, it is our rectPoint\n\n\n      if (farthestIntersection) {\n        var point = align(farthestIntersection, grid, precision); // if the rectPoint lies inside the bbox, offset it by one more step\n\n        if (bbox.containsPoint(point)) {\n          point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        } // then add the point to the result array\n        // aligned\n\n\n        res.push(point);\n      }\n    }\n\n    return res;\n  }, []); // if anchor lies outside of bbox, add it to the array of points\n\n  if (!bbox.containsPoint(anchor)) {\n    // aligned\n    rectPoints.push(align(anchor, grid, precision));\n  }\n\n  return rectPoints;\n} // finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\n\n\nfunction findRoute(from, to, map, opt) {\n  var precision = opt.precision; // Get grid for this route.\n\n  var sourceAnchor, targetAnchor;\n\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n  } else {\n    sourceAnchor = round(from.clone(), precision);\n  }\n\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n  } else {\n    targetAnchor = round(to.clone(), precision);\n  }\n\n  var grid = getGrid(opt.step, sourceAnchor, targetAnchor); // Get pathfinding points.\n\n  var start, end; // aligned with grid by definition\n\n  var startPoints, endPoints; // assumed to be aligned with grid already\n  // set of points we start pathfinding from\n\n  if (from instanceof g.Rect) {\n    // `from` is sourceBBox\n    start = sourceAnchor;\n    startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n  } else {\n    start = sourceAnchor;\n    startPoints = [start];\n  } // set of points we want the pathfinding to finish at\n\n\n  if (to instanceof g.Rect) {\n    // `to` is targetBBox\n    end = targetAnchor;\n    endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n  } else {\n    end = targetAnchor;\n    endPoints = [end];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(map.isPointAccessible, map);\n  endPoints = endPoints.filter(map.isPointAccessible, map); // Check that there is an accessible route point on both sides.\n  // Otherwise, use fallbackRoute().\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    // The set of tentative points to be evaluated, initially containing the start points.\n    // Rounded to nearest integer for simplicity.\n    var openSet = new SortedSet(); // Keeps reference to actual points for given elements of the open set.\n\n    var points = {}; // Keeps reference to a point that is immediate predecessor of given element.\n\n    var parents = {}; // Cost from start to a point along best known path.\n\n    var costs = {};\n\n    for (var i = 0, n = startPoints.length; i < n; i++) {\n      // startPoint is assumed to be aligned already\n      var startPoint = startPoints[i];\n      var key = getKey(startPoint);\n      openSet.add(key, estimateCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n\n    var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n\n    var isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    var direction, directionChange;\n    var directions = opt.directions;\n    getGridOffsets(directions, grid, opt);\n    var numDirections = directions.length;\n    var endPointsKeys = util.toArray(endPoints).reduce(function (res, endPoint) {\n      // endPoint is assumed to be aligned already\n      var key = getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    var loopsRemaining = opt.maximumLoops;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // remove current from the open list\n      var currentKey = openSet.pop();\n      var currentPoint = points[currentKey];\n      var currentParent = parents[currentKey];\n      var currentCost = costs[currentKey];\n      var isRouteBeginning = currentParent === undefined; // undefined for route starts\n\n      var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n      var previousDirectionAngle;\n      if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n      else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n        else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n          else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n      // check if we reached any endpoint\n\n      var samePoints = util.isEqual(startPoints, endPoints);\n      var skipEndCheck = isRouteBeginning && samePoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        opt.previousDirectionAngle = previousDirectionAngle;\n        return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n      } // go over all possible directions and find neighbors\n\n\n      for (i = 0; i < numDirections; i++) {\n        direction = directions[i];\n        var directionAngle = direction.angle;\n        directionChange = getDirectionChange(previousDirectionAngle, directionAngle); // if the direction changed rapidly, don't use this point\n        // any direction is allowed for starting points\n\n        if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n        var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n        var neighborKey = getKey(neighborPoint); // Closed points from the openSet were already evaluated.\n\n        if (openSet.isClose(neighborKey) || !map.isPointAccessible(neighborPoint)) continue; // We can only enter end points at an acceptable angle.\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          // neighbor is an end point\n          var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n          if (!isNeighborEnd) {\n            var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n            var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n            if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n          }\n        } // The current direction is ok.\n\n\n        var neighborCost = direction.cost;\n        var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n\n        var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          // neighbor point has not been processed yet\n          // or the cost of the path from start is lower than previously calculated\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining--;\n    }\n  } // no route found (`to` point either wasn't accessible or finding route took\n  // way too much calculation)\n\n\n  return opt.fallbackRoute.call(this, start, end, opt);\n} // resolve some of the options\n\n\nfunction resolveOptions(opt) {\n  opt.directions = util.result(opt, 'directions');\n  opt.penalties = util.result(opt, 'penalties');\n  opt.paddingBox = util.result(opt, 'paddingBox');\n  opt.padding = util.result(opt, 'padding');\n\n  if (opt.padding) {\n    // if both provided, opt.padding wins over opt.paddingBox\n    var sides = util.normalizeSides(opt.padding);\n    opt.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom\n    };\n  }\n\n  util.toArray(opt.directions).forEach(function (direction) {\n    var point1 = new g.Point(0, 0);\n    var point2 = new g.Point(direction.offsetX, direction.offsetY);\n    direction.angle = g.normalizeAngle(point1.theta(point2));\n  });\n} // initialization of the route finding\n\n\nfunction router(vertices, opt, linkView) {\n  resolveOptions(opt); // enable/disable linkView perpendicular option\n\n  linkView.options.perpendicular = !!opt.perpendicular;\n  var sourceBBox = getSourceBBox(linkView, opt);\n  var targetBBox = getTargetBBox(linkView, opt);\n  var sourceAnchor = getSourceAnchor(linkView, opt); //var targetAnchor = getTargetAnchor(linkView, opt);\n  // pathfinding\n\n  var map = new ObstacleMap(opt).build(linkView.paper.model, linkView.model);\n  var oldVertices = util.toArray(vertices).map(g.Point);\n  var newVertices = [];\n  var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n  // find a route by concatenating all partial routes (routes need to pass through vertices)\n  // source -> vertex[1] -> ... -> vertex[n] -> target\n\n  var to, from;\n\n  for (var i = 0, len = oldVertices.length; i <= len; i++) {\n    var partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i];\n\n    if (!to) {\n      // this is the last iteration\n      // we ran through all vertices in oldVertices\n      // 'to' is not a vertex.\n      to = targetBBox; // If the target is a point (i.e. it's not an element), we\n      // should use dragging route instead of main routing method if it has been provided.\n\n      var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n      if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n        // Make sure we are passing points only (not rects).\n        var dragFrom = from === sourceBBox ? sourceAnchor : from;\n        var dragTo = to.origin();\n        partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n      }\n    } // if partial route has not been calculated yet use the main routing method to find one\n\n\n    partialRoute = partialRoute || findRoute.call(linkView, from, to, map, opt);\n\n    if (partialRoute === null) {\n      // the partial route cannot be found\n      return opt.fallbackRouter(vertices, opt, linkView);\n    }\n\n    var leadPoint = partialRoute[0]; // remove the first point if the previous partial route had the same point as last\n\n    if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift(); // save tailPoint for next iteration\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    Array.prototype.push.apply(newVertices, partialRoute);\n  }\n\n  return newVertices;\n} // public function\n\n\nexport const manhattan = function (vertices, opt, linkView) {\n  return router(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/routers/manhattan.mjs"],"names":["g","util","orthogonal","config","step","maximumLoops","precision","maxAllowedDirectionChange","perpendicular","excludeEnds","excludeTypes","startDirections","endDirections","directionMap","top","x","y","right","bottom","left","cost","directions","offsetX","offsetY","penalties","paddingBox","width","height","fallbackRouter","vertices","opt","linkView","isFunction","Error","assign","fallbackRoute","from","to","draggingRoute","ObstacleMap","map","options","mapGridSize","prototype","build","graph","link","excludedEnds","toArray","reduce","res","item","end","get","cell","getCell","id","push","excludedAncestors","source","union","getAncestors","target","getElements","element","isExcludedType","includes","isExcludedEnd","find","excluded","isExcludedAncestor","isExcluded","bbox","getBBox","moveAndExpand","origin","snapToGrid","corner","gridKey","isPointAccessible","point","mapKey","clone","toString","every","obstacle","containsPoint","SortedSet","items","hash","values","OPEN","CLOSE","add","value","splice","indexOf","index","sortedIndex","i","bind","remove","isOpen","isClose","isEmpty","length","pop","shift","getSourceBBox","sourceBBox","getTargetBBox","targetBBox","getSourceAnchor","sourceAnchor","center","getTargetAnchor","targetAnchor","getDirectionAngle","start","numDirections","grid","quadrant","angleTheta","theta","fixAngleEnd","normalizedAngle","normalizeAngle","Math","floor","diffX","diffY","gridStepsX","gridStepsY","distanceX","distanceY","Point","getDirectionChange","angle1","angle2","directionChange","abs","getGridOffsets","forEach","direction","gridOffsetX","gridOffsetY","getGrid","getGridDimension","diff","absDiff","numSteps","round","roundedDiff","remainder","stepCorrection","snappedX","snappedY","align","getKey","normalizePoint","reconstructRoute","parents","points","tailPoint","route","prevDiff","difference","currentKey","parent","equals","unshift","leadPoint","fromDiff","estimateCost","endPoints","min","Infinity","len","manhattanDistance","getRectPoints","anchor","directionList","anchorCenterVector","keys","isObject","Object","dirList","rectPoints","key","endpoint","intersectionLine","Line","intersections","intersect","numIntersections","farthestIntersectionDistance","farthestIntersection","currentIntersection","distance","squaredDistance","undefined","offset","findRoute","Rect","startPoints","filter","openSet","costs","n","startPoint","previousRouteDirectionAngle","previousDirectionAngle","isPathBeginning","endPointsKeys","endPoint","loopsRemaining","currentPoint","currentParent","currentCost","isRouteBeginning","isStart","samePoints","isEqual","skipEndCheck","directionAngle","angle","neighborPoint","neighborKey","isNeighborEnd","endDirectionAngle","endDirectionChange","neighborCost","neighborPenalty","costFromStart","call","resolveOptions","result","padding","sides","normalizeSides","point1","point2","router","paper","model","oldVertices","newVertices","partialRoute","isEndingAtPoint","dragFrom","dragTo","Array","apply","manhattan"],"mappings":"AAAA,OAAO,KAAKA,CAAZ,MAAmB,gBAAnB;AACA,OAAO,KAAKC,IAAZ,MAAsB,mBAAtB;AACA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,IAAIC,MAAM,GAAG;AAET;AACAC,EAAAA,IAAI,EAAE,EAHG;AAKT;AACA;AACAC,EAAAA,YAAY,EAAE,IAPL;AAST;AACAC,EAAAA,SAAS,EAAE,CAVF;AAYT;AACAC,EAAAA,yBAAyB,EAAE,EAblB;AAeT;AACA;AACA;AACAC,EAAAA,aAAa,EAAE,IAlBN;AAoBT;AACAC,EAAAA,WAAW,EAAE,EArBJ;AAqBQ;AAEjB;AACAC,EAAAA,YAAY,EAAE,CAAC,YAAD,CAxBL;AA0BT;AACAC,EAAAA,eAAe,EAAE,CAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2B,MAA3B,CA3BR;AA6BT;AACAC,EAAAA,aAAa,EAAE,CAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2B,MAA3B,CA9BN;AAgCT;AACAC,EAAAA,YAAY,EAAE;AACVC,IAAAA,GAAG,EAAE;AAAEC,MAAAA,CAAC,EAAE,CAAL;AAAQC,MAAAA,CAAC,EAAE,CAAC;AAAZ,KADK;AAEVC,IAAAA,KAAK,EAAE;AAAEF,MAAAA,CAAC,EAAE,CAAL;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAFG;AAGVE,IAAAA,MAAM,EAAE;AAAEH,MAAAA,CAAC,EAAE,CAAL;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAHE;AAIVG,IAAAA,IAAI,EAAE;AAAEJ,MAAAA,CAAC,EAAE,CAAC,CAAN;AAASC,MAAAA,CAAC,EAAE;AAAZ;AAJI,GAjCL;AAwCT;AACAI,EAAAA,IAAI,EAAE,YAAW;AAEb,WAAO,KAAKhB,IAAZ;AACH,GA5CQ;AA8CT;AACA;AACAiB,EAAAA,UAAU,EAAE,YAAW;AAEnB,QAAIjB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIgB,IAAI,GAAG,KAAKA,IAAL,EAAX;AAEA,WAAO,CACH;AAAEE,MAAAA,OAAO,EAAElB,IAAX;AAAiBmB,MAAAA,OAAO,EAAE,CAA1B;AAA6BH,MAAAA,IAAI,EAAEA;AAAnC,KADG,EAEH;AAAEE,MAAAA,OAAO,EAAE,CAAClB,IAAZ;AAAkBmB,MAAAA,OAAO,EAAE,CAA3B;AAA8BH,MAAAA,IAAI,EAAEA;AAApC,KAFG,EAGH;AAAEE,MAAAA,OAAO,EAAE,CAAX;AAAcC,MAAAA,OAAO,EAAEnB,IAAvB;AAA6BgB,MAAAA,IAAI,EAAEA;AAAnC,KAHG,EAIH;AAAEE,MAAAA,OAAO,EAAE,CAAX;AAAcC,MAAAA,OAAO,EAAE,CAACnB,IAAxB;AAA8BgB,MAAAA,IAAI,EAAEA;AAApC,KAJG,CAAP;AAMH,GA3DQ;AA6DT;AACAI,EAAAA,SAAS,EAAE,YAAW;AAElB,WAAO;AACH,SAAG,CADA;AAEH,UAAI,KAAKpB,IAAL,GAAY,CAFb;AAGH,UAAI,KAAKA,IAAL,GAAY;AAHb,KAAP;AAKH,GArEQ;AAuET;AACAqB,EAAAA,UAAU,EAAE,YAAW;AAEnB,QAAIrB,IAAI,GAAG,KAAKA,IAAhB;AAEA,WAAO;AACHW,MAAAA,CAAC,EAAE,CAACX,IADD;AAEHY,MAAAA,CAAC,EAAE,CAACZ,IAFD;AAGHsB,MAAAA,KAAK,EAAE,IAAItB,IAHR;AAIHuB,MAAAA,MAAM,EAAE,IAAIvB;AAJT,KAAP;AAMH,GAlFQ;AAoFT;AACA;AACAwB,EAAAA,cAAc,EAAE,UAASC,QAAT,EAAmBC,GAAnB,EAAwBC,QAAxB,EAAkC;AAE9C,QAAI,CAAC9B,IAAI,CAAC+B,UAAL,CAAgB9B,UAAhB,CAAL,EAAkC;AAC9B,YAAM,IAAI+B,KAAJ,CAAU,+DAAV,CAAN;AACH;;AAED,WAAO/B,UAAU,CAAC2B,QAAD,EAAW5B,IAAI,CAACiC,MAAL,CAAY,EAAZ,EAAgB/B,MAAhB,EAAwB2B,GAAxB,CAAX,EAAyCC,QAAzC,CAAjB;AACH,GA7FQ;;AA+FT;AACA;AACA;AACAI,EAAAA,aAAa,EAAE,UAASC,IAAT,EAAeC,EAAf,EAAmBP,GAAnB,EAAwB;AAEnC,WAAO,IAAP,CAFmC,CAEtB;AAEb;;AACA;AACR;AACA;AACA;AACA;AAGK,GA9GQ;AAgHT;AACA;AACAQ,EAAAA,aAAa,EAAE;AAlHN,CAAb,C,CAqHA;AAEA;AACA;;AACA,SAASC,WAAT,CAAqBT,GAArB,EAA0B;AAEtB,OAAKU,GAAL,GAAW,EAAX;AACA,OAAKC,OAAL,GAAeX,GAAf,CAHsB,CAItB;;AACA,OAAKY,WAAL,GAAmB,GAAnB;AACH;;AAEDH,WAAW,CAACI,SAAZ,CAAsBC,KAAtB,GAA8B,UAASC,KAAT,EAAgBC,IAAhB,EAAsB;AAEhD,MAAIhB,GAAG,GAAG,KAAKW,OAAf,CAFgD,CAIhD;;AACA,MAAIM,YAAY,GAAG9C,IAAI,CAAC+C,OAAL,CAAalB,GAAG,CAACrB,WAAjB,EAA8BwC,MAA9B,CAAqC,UAASC,GAAT,EAAcC,IAAd,EAAoB;AAExE,QAAIC,GAAG,GAAGN,IAAI,CAACO,GAAL,CAASF,IAAT,CAAV;;AACA,QAAIC,GAAJ,EAAS;AACL,UAAIE,IAAI,GAAGT,KAAK,CAACU,OAAN,CAAcH,GAAG,CAACI,EAAlB,CAAX;;AACA,UAAIF,IAAJ,EAAU;AACNJ,QAAAA,GAAG,CAACO,IAAJ,CAASH,IAAT;AACH;AACJ;;AAED,WAAOJ,GAAP;AACH,GAXkB,EAWhB,EAXgB,CAAnB,CALgD,CAkBhD;;AACA,MAAIQ,iBAAiB,GAAG,EAAxB;AAEA,MAAIC,MAAM,GAAGd,KAAK,CAACU,OAAN,CAAcT,IAAI,CAACO,GAAL,CAAS,QAAT,EAAmBG,EAAjC,CAAb;;AACA,MAAIG,MAAJ,EAAY;AACRD,IAAAA,iBAAiB,GAAGzD,IAAI,CAAC2D,KAAL,CAAWF,iBAAX,EAA8BC,MAAM,CAACE,YAAP,GAAsBrB,GAAtB,CAA0B,UAASc,IAAT,EAAe;AACvF,aAAOA,IAAI,CAACE,EAAZ;AACH,KAFiD,CAA9B,CAApB;AAGH;;AAED,MAAIM,MAAM,GAAGjB,KAAK,CAACU,OAAN,CAAcT,IAAI,CAACO,GAAL,CAAS,QAAT,EAAmBG,EAAjC,CAAb;;AACA,MAAIM,MAAJ,EAAY;AACRJ,IAAAA,iBAAiB,GAAGzD,IAAI,CAAC2D,KAAL,CAAWF,iBAAX,EAA8BI,MAAM,CAACD,YAAP,GAAsBrB,GAAtB,CAA0B,UAASc,IAAT,EAAe;AACvF,aAAOA,IAAI,CAACE,EAAZ;AACH,KAFiD,CAA9B,CAApB;AAGH,GAjC+C,CAmChD;AACA;AACA;AACA;AACA;;;AACA,MAAId,WAAW,GAAG,KAAKA,WAAvB;AAEAG,EAAAA,KAAK,CAACkB,WAAN,GAAoBd,MAApB,CAA2B,UAAST,GAAT,EAAcwB,OAAd,EAAuB;AAE9C,QAAIC,cAAc,GAAGhE,IAAI,CAAC+C,OAAL,CAAalB,GAAG,CAACpB,YAAjB,EAA+BwD,QAA/B,CAAwCF,OAAO,CAACX,GAAR,CAAY,MAAZ,CAAxC,CAArB;AACA,QAAIc,aAAa,GAAGpB,YAAY,CAACqB,IAAb,CAAkB,UAASC,QAAT,EAAmB;AACrD,aAAOA,QAAQ,CAACb,EAAT,KAAgBQ,OAAO,CAACR,EAA/B;AACH,KAFmB,CAApB;AAGA,QAAIc,kBAAkB,GAAGZ,iBAAiB,CAACQ,QAAlB,CAA2BF,OAAO,CAACR,EAAnC,CAAzB;AAEA,QAAIe,UAAU,GAAGN,cAAc,IAAIE,aAAlB,IAAmCG,kBAApD;;AACA,QAAI,CAACC,UAAL,EAAiB;AACb,UAAIC,IAAI,GAAGR,OAAO,CAACS,OAAR,GAAkBC,aAAlB,CAAgC5C,GAAG,CAACL,UAApC,CAAX;AAEA,UAAIkD,MAAM,GAAGH,IAAI,CAACG,MAAL,GAAcC,UAAd,CAAyBlC,WAAzB,CAAb;AACA,UAAImC,MAAM,GAAGL,IAAI,CAACK,MAAL,GAAcD,UAAd,CAAyBlC,WAAzB,CAAb;;AAEA,WAAK,IAAI3B,CAAC,GAAG4D,MAAM,CAAC5D,CAApB,EAAuBA,CAAC,IAAI8D,MAAM,CAAC9D,CAAnC,EAAsCA,CAAC,IAAI2B,WAA3C,EAAwD;AACpD,aAAK,IAAI1B,CAAC,GAAG2D,MAAM,CAAC3D,CAApB,EAAuBA,CAAC,IAAI6D,MAAM,CAAC7D,CAAnC,EAAsCA,CAAC,IAAI0B,WAA3C,EAAwD;AACpD,cAAIoC,OAAO,GAAG/D,CAAC,GAAG,GAAJ,GAAUC,CAAxB;AACAwB,UAAAA,GAAG,CAACsC,OAAD,CAAH,GAAetC,GAAG,CAACsC,OAAD,CAAH,IAAgB,EAA/B;AACAtC,UAAAA,GAAG,CAACsC,OAAD,CAAH,CAAarB,IAAb,CAAkBe,IAAlB;AACH;AACJ;AACJ;;AAED,WAAOhC,GAAP;AACH,GAzBD,EAyBG,KAAKA,GAzBR;AA2BA,SAAO,IAAP;AACH,CAtED;;AAwEAD,WAAW,CAACI,SAAZ,CAAsBoC,iBAAtB,GAA0C,UAASC,KAAT,EAAgB;AAEtD,MAAIC,MAAM,GAAGD,KAAK,CAACE,KAAN,GAAcN,UAAd,CAAyB,KAAKlC,WAA9B,EAA2CyC,QAA3C,EAAb;AAEA,SAAOlF,IAAI,CAAC+C,OAAL,CAAa,KAAKR,GAAL,CAASyC,MAAT,CAAb,EAA+BG,KAA/B,CAAqC,UAASC,QAAT,EAAmB;AAC3D,WAAO,CAACA,QAAQ,CAACC,aAAT,CAAuBN,KAAvB,CAAR;AACH,GAFM,CAAP;AAGH,CAPD,C,CASA;AACA;;;AACA,SAASO,SAAT,GAAqB;AACjB,OAAKC,KAAL,GAAa,EAAb;AACA,OAAKC,IAAL,GAAY,EAAZ;AACA,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,IAAL,GAAY,CAAZ;AACA,OAAKC,KAAL,GAAa,CAAb;AACH;;AAEDL,SAAS,CAAC5C,SAAV,CAAoBkD,GAApB,GAA0B,UAAS1C,IAAT,EAAe2C,KAAf,EAAsB;AAE5C,MAAI,KAAKL,IAAL,CAAUtC,IAAV,CAAJ,EAAqB;AACjB;AACA,SAAKqC,KAAL,CAAWO,MAAX,CAAkB,KAAKP,KAAL,CAAWQ,OAAX,CAAmB7C,IAAnB,CAAlB,EAA4C,CAA5C;AACH,GAHD,MAGO;AACH,SAAKsC,IAAL,CAAUtC,IAAV,IAAkB,KAAKwC,IAAvB;AACH;;AAED,OAAKD,MAAL,CAAYvC,IAAZ,IAAoB2C,KAApB;AAEA,MAAIG,KAAK,GAAGhG,IAAI,CAACiG,WAAL,CAAiB,KAAKV,KAAtB,EAA6BrC,IAA7B,EAAmC,UAASgD,CAAT,EAAY;AACvD,WAAO,KAAKT,MAAL,CAAYS,CAAZ,CAAP;AACH,GAF8C,CAE7CC,IAF6C,CAExC,IAFwC,CAAnC,CAAZ;AAIA,OAAKZ,KAAL,CAAWO,MAAX,CAAkBE,KAAlB,EAAyB,CAAzB,EAA4B9C,IAA5B;AACH,CAhBD;;AAkBAoC,SAAS,CAAC5C,SAAV,CAAoB0D,MAApB,GAA6B,UAASlD,IAAT,EAAe;AAExC,OAAKsC,IAAL,CAAUtC,IAAV,IAAkB,KAAKyC,KAAvB;AACH,CAHD;;AAKAL,SAAS,CAAC5C,SAAV,CAAoB2D,MAApB,GAA6B,UAASnD,IAAT,EAAe;AAExC,SAAO,KAAKsC,IAAL,CAAUtC,IAAV,MAAoB,KAAKwC,IAAhC;AACH,CAHD;;AAKAJ,SAAS,CAAC5C,SAAV,CAAoB4D,OAApB,GAA8B,UAASpD,IAAT,EAAe;AAEzC,SAAO,KAAKsC,IAAL,CAAUtC,IAAV,MAAoB,KAAKyC,KAAhC;AACH,CAHD;;AAKAL,SAAS,CAAC5C,SAAV,CAAoB6D,OAApB,GAA8B,YAAW;AAErC,SAAO,KAAKhB,KAAL,CAAWiB,MAAX,KAAsB,CAA7B;AACH,CAHD;;AAKAlB,SAAS,CAAC5C,SAAV,CAAoB+D,GAApB,GAA0B,YAAW;AAEjC,MAAIvD,IAAI,GAAG,KAAKqC,KAAL,CAAWmB,KAAX,EAAX;AACA,OAAKN,MAAL,CAAYlD,IAAZ;AACA,SAAOA,IAAP;AACH,CALD,C,CAOA;AAEA;;;AACA,SAASyD,aAAT,CAAuB7E,QAAvB,EAAiCD,GAAjC,EAAsC;AAElC;AACA,MAAIA,GAAG,IAAIA,GAAG,CAACL,UAAf,EAA2B,OAAOM,QAAQ,CAAC8E,UAAT,CAAoB3B,KAApB,GAA4BR,aAA5B,CAA0C5C,GAAG,CAACL,UAA9C,CAAP;AAE3B,SAAOM,QAAQ,CAAC8E,UAAT,CAAoB3B,KAApB,EAAP;AACH,C,CAED;;;AACA,SAAS4B,aAAT,CAAuB/E,QAAvB,EAAiCD,GAAjC,EAAsC;AAElC;AACA,MAAIA,GAAG,IAAIA,GAAG,CAACL,UAAf,EAA2B,OAAOM,QAAQ,CAACgF,UAAT,CAAoB7B,KAApB,GAA4BR,aAA5B,CAA0C5C,GAAG,CAACL,UAA9C,CAAP;AAE3B,SAAOM,QAAQ,CAACgF,UAAT,CAAoB7B,KAApB,EAAP;AACH,C,CAED;;;AACA,SAAS8B,eAAT,CAAyBjF,QAAzB,EAAmCD,GAAnC,EAAwC;AAEpC,MAAIC,QAAQ,CAACkF,YAAb,EAA2B,OAAOlF,QAAQ,CAACkF,YAAhB,CAFS,CAIpC;;AACA,MAAIJ,UAAU,GAAGD,aAAa,CAAC7E,QAAD,EAAWD,GAAX,CAA9B;AACA,SAAO+E,UAAU,CAACK,MAAX,EAAP;AACH,C,CAED;;;AACA,SAASC,eAAT,CAAyBpF,QAAzB,EAAmCD,GAAnC,EAAwC;AAEpC,MAAIC,QAAQ,CAACqF,YAAb,EAA2B,OAAOrF,QAAQ,CAACqF,YAAhB,CAFS,CAIpC;;AACA,MAAIL,UAAU,GAAGD,aAAa,CAAC/E,QAAD,EAAWD,GAAX,CAA9B;AACA,SAAOiF,UAAU,CAACG,MAAX,EAAP,CANoC,CAMR;AAC/B,C,CAED;AACA;;;AACA,SAASG,iBAAT,CAA2BC,KAA3B,EAAkClE,GAAlC,EAAuCmE,aAAvC,EAAsDC,IAAtD,EAA4D1F,GAA5D,EAAiE;AAE7D,MAAI2F,QAAQ,GAAG,MAAMF,aAArB;AACA,MAAIG,UAAU,GAAGJ,KAAK,CAACK,KAAN,CAAYC,WAAW,CAACN,KAAD,EAAQlE,GAAR,EAAaoE,IAAb,EAAmB1F,GAAnB,CAAvB,CAAjB;AACA,MAAI+F,eAAe,GAAG7H,CAAC,CAAC8H,cAAF,CAAiBJ,UAAU,GAAID,QAAQ,GAAG,CAA1C,CAAtB;AACA,SAAOA,QAAQ,GAAGM,IAAI,CAACC,KAAL,CAAWH,eAAe,GAAGJ,QAA7B,CAAlB;AACH,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBN,KAArB,EAA4BlE,GAA5B,EAAiCoE,IAAjC,EAAuC1F,GAAvC,EAA4C;AAExC,MAAI1B,IAAI,GAAG0B,GAAG,CAAC1B,IAAf;AAEA,MAAI6H,KAAK,GAAG7E,GAAG,CAACrC,CAAJ,GAAQuG,KAAK,CAACvG,CAA1B;AACA,MAAImH,KAAK,GAAG9E,GAAG,CAACpC,CAAJ,GAAQsG,KAAK,CAACtG,CAA1B;AAEA,MAAImH,UAAU,GAAGF,KAAK,GAAGT,IAAI,CAACzG,CAA9B;AACA,MAAIqH,UAAU,GAAGF,KAAK,GAAGV,IAAI,CAACxG,CAA9B;AAEA,MAAIqH,SAAS,GAAGF,UAAU,GAAG/H,IAA7B;AACA,MAAIkI,SAAS,GAAGF,UAAU,GAAGhI,IAA7B;AAEA,SAAO,IAAIJ,CAAC,CAACuI,KAAN,CAAYjB,KAAK,CAACvG,CAAN,GAAUsH,SAAtB,EAAiCf,KAAK,CAACtG,CAAN,GAAUsH,SAA3C,CAAP;AACH,C,CAED;;;AACA,SAASE,kBAAT,CAA4BC,MAA5B,EAAoCC,MAApC,EAA4C;AAExC,MAAIC,eAAe,GAAGZ,IAAI,CAACa,GAAL,CAASH,MAAM,GAAGC,MAAlB,CAAtB;AACA,SAAQC,eAAe,GAAG,GAAnB,GAA2B,MAAMA,eAAjC,GAAoDA,eAA3D;AACH,C,CAED;;;AACA,SAASE,cAAT,CAAwBxH,UAAxB,EAAoCmG,IAApC,EAA0C1F,GAA1C,EAA+C;AAE3C,MAAI1B,IAAI,GAAG0B,GAAG,CAAC1B,IAAf;AAEAH,EAAAA,IAAI,CAAC+C,OAAL,CAAalB,GAAG,CAACT,UAAjB,EAA6ByH,OAA7B,CAAqC,UAASC,SAAT,EAAoB;AAErDA,IAAAA,SAAS,CAACC,WAAV,GAAyBD,SAAS,CAACzH,OAAV,GAAoBlB,IAArB,GAA6BoH,IAAI,CAACzG,CAA1D;AACAgI,IAAAA,SAAS,CAACE,WAAV,GAAyBF,SAAS,CAACxH,OAAV,GAAoBnB,IAArB,GAA6BoH,IAAI,CAACxG,CAA1D;AACH,GAJD;AAKH,C,CAED;;;AACA,SAASkI,OAAT,CAAiB9I,IAAjB,EAAuBuD,MAAvB,EAA+BG,MAA/B,EAAuC;AAEnC,SAAO;AACHH,IAAAA,MAAM,EAAEA,MAAM,CAACuB,KAAP,EADL;AAEHnE,IAAAA,CAAC,EAAEoI,gBAAgB,CAACrF,MAAM,CAAC/C,CAAP,GAAW4C,MAAM,CAAC5C,CAAnB,EAAsBX,IAAtB,CAFhB;AAGHY,IAAAA,CAAC,EAAEmI,gBAAgB,CAACrF,MAAM,CAAC9C,CAAP,GAAW2C,MAAM,CAAC3C,CAAnB,EAAsBZ,IAAtB;AAHhB,GAAP;AAKH,C,CAED;;;AACA,SAAS+I,gBAAT,CAA0BC,IAA1B,EAAgChJ,IAAhC,EAAsC;AAElC;AACA,MAAI,CAACgJ,IAAL,EAAW,OAAOhJ,IAAP;AAEX,MAAIiJ,OAAO,GAAGtB,IAAI,CAACa,GAAL,CAASQ,IAAT,CAAd;AACA,MAAIE,QAAQ,GAAGvB,IAAI,CAACwB,KAAL,CAAWF,OAAO,GAAGjJ,IAArB,CAAf,CANkC,CAQlC;;AACA,MAAI,CAACkJ,QAAL,EAAe,OAAOD,OAAP,CATmB,CAWlC;;AACA,MAAIG,WAAW,GAAGF,QAAQ,GAAGlJ,IAA7B;AACA,MAAIqJ,SAAS,GAAGJ,OAAO,GAAGG,WAA1B;AACA,MAAIE,cAAc,GAAGD,SAAS,GAAGH,QAAjC;AAEA,SAAOlJ,IAAI,GAAGsJ,cAAd;AACH,C,CAED;;;AACA,SAAS9E,UAAT,CAAoBI,KAApB,EAA2BwC,IAA3B,EAAiC;AAE7B,MAAI7D,MAAM,GAAG6D,IAAI,CAAC7D,MAAlB;AAEA,MAAIgG,QAAQ,GAAG3J,CAAC,CAAC4E,UAAF,CAAaI,KAAK,CAACjE,CAAN,GAAU4C,MAAM,CAAC5C,CAA9B,EAAiCyG,IAAI,CAACzG,CAAtC,IAA2C4C,MAAM,CAAC5C,CAAjE;AACA,MAAI6I,QAAQ,GAAG5J,CAAC,CAAC4E,UAAF,CAAaI,KAAK,CAAChE,CAAN,GAAU2C,MAAM,CAAC3C,CAA9B,EAAiCwG,IAAI,CAACxG,CAAtC,IAA2C2C,MAAM,CAAC3C,CAAjE;AAEA,SAAO,IAAIhB,CAAC,CAACuI,KAAN,CAAYoB,QAAZ,EAAsBC,QAAtB,CAAP;AACH,C,CAED;;;AACA,SAASL,KAAT,CAAevE,KAAf,EAAsB1E,SAAtB,EAAiC;AAE7B,SAAO0E,KAAK,CAACuE,KAAN,CAAYjJ,SAAZ,CAAP;AACH,C,CAED;;;AACA,SAASuJ,KAAT,CAAe7E,KAAf,EAAsBwC,IAAtB,EAA4BlH,SAA5B,EAAuC;AAEnC,SAAOiJ,KAAK,CAAC3E,UAAU,CAACI,KAAK,CAACE,KAAN,EAAD,EAAgBsC,IAAhB,CAAX,EAAkClH,SAAlC,CAAZ;AACH,C,CAED;AACA;;;AACA,SAASwJ,MAAT,CAAgB9E,KAAhB,EAAuB;AAEnB,SAAOA,KAAK,CAACE,KAAN,GAAcC,QAAd,EAAP;AACH,C,CAED;AACA;;;AACA,SAAS4E,cAAT,CAAwB/E,KAAxB,EAA+B;AAE3B,SAAO,IAAIhF,CAAC,CAACuI,KAAN,CACHvD,KAAK,CAACjE,CAAN,KAAY,CAAZ,GAAgB,CAAhB,GAAoBgH,IAAI,CAACa,GAAL,CAAS5D,KAAK,CAACjE,CAAf,IAAoBiE,KAAK,CAACjE,CAD3C,EAEHiE,KAAK,CAAChE,CAAN,KAAY,CAAZ,GAAgB,CAAhB,GAAoB+G,IAAI,CAACa,GAAL,CAAS5D,KAAK,CAAChE,CAAf,IAAoBgE,KAAK,CAAChE,CAF3C,CAAP;AAIH,C,CAED;AAEA;;;AACA,SAASgJ,gBAAT,CAA0BC,OAA1B,EAAmCC,MAAnC,EAA2CC,SAA3C,EAAsD/H,IAAtD,EAA4DC,EAA5D,EAAgEmF,IAAhE,EAAsE1F,GAAtE,EAA2E;AAEvE,MAAIsI,KAAK,GAAG,EAAZ;AAEA,MAAIC,QAAQ,GAAGN,cAAc,CAAC1H,EAAE,CAACiI,UAAH,CAAcH,SAAd,CAAD,CAA7B,CAJuE,CAMvE;;AACA,MAAII,UAAU,GAAGT,MAAM,CAACK,SAAD,CAAvB;AACA,MAAIK,MAAM,GAAGP,OAAO,CAACM,UAAD,CAApB;AAEA,MAAIvF,KAAJ;;AACA,SAAOwF,MAAP,EAAe;AAEX;AACAxF,IAAAA,KAAK,GAAGkF,MAAM,CAACK,UAAD,CAAd;AAEA,QAAInB,IAAI,GAAGW,cAAc,CAAC/E,KAAK,CAACsF,UAAN,CAAiBE,MAAjB,CAAD,CAAzB;;AACA,QAAI,CAACpB,IAAI,CAACqB,MAAL,CAAYJ,QAAZ,CAAL,EAA4B;AACxBD,MAAAA,KAAK,CAACM,OAAN,CAAc1F,KAAd;AACAqF,MAAAA,QAAQ,GAAGjB,IAAX;AACH,KATU,CAWX;;;AACAmB,IAAAA,UAAU,GAAGT,MAAM,CAACU,MAAD,CAAnB;AACAA,IAAAA,MAAM,GAAGP,OAAO,CAACM,UAAD,CAAhB;AACH,GAzBsE,CA2BvE;;;AACA,MAAII,SAAS,GAAGT,MAAM,CAACK,UAAD,CAAtB;AAEA,MAAIK,QAAQ,GAAGb,cAAc,CAACY,SAAS,CAACL,UAAV,CAAqBlI,IAArB,CAAD,CAA7B;;AACA,MAAI,CAACwI,QAAQ,CAACH,MAAT,CAAgBJ,QAAhB,CAAL,EAAgC;AAC5BD,IAAAA,KAAK,CAACM,OAAN,CAAcC,SAAd;AACH;;AAED,SAAOP,KAAP;AACH,C,CAED;;;AACA,SAASS,YAAT,CAAsBzI,IAAtB,EAA4B0I,SAA5B,EAAuC;AAEnC,MAAIC,GAAG,GAAGC,QAAV;;AAEA,OAAK,IAAI7E,CAAC,GAAG,CAAR,EAAW8E,GAAG,GAAGH,SAAS,CAACrE,MAAhC,EAAwCN,CAAC,GAAG8E,GAA5C,EAAiD9E,CAAC,EAAlD,EAAsD;AAClD,QAAI/E,IAAI,GAAGgB,IAAI,CAAC8I,iBAAL,CAAuBJ,SAAS,CAAC3E,CAAD,CAAhC,CAAX;AACA,QAAI/E,IAAI,GAAG2J,GAAX,EAAgBA,GAAG,GAAG3J,IAAN;AACnB;;AAED,SAAO2J,GAAP;AACH,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAuBC,MAAvB,EAA+B5G,IAA/B,EAAqC6G,aAArC,EAAoD7D,IAApD,EAA0D1F,GAA1D,EAA+D;AAE3D,MAAIxB,SAAS,GAAGwB,GAAG,CAACxB,SAApB;AACA,MAAIO,YAAY,GAAGiB,GAAG,CAACjB,YAAvB;AAEA,MAAIyK,kBAAkB,GAAGF,MAAM,CAACd,UAAP,CAAkB9F,IAAI,CAAC0C,MAAL,EAAlB,CAAzB;AAEA,MAAIqE,IAAI,GAAGtL,IAAI,CAACuL,QAAL,CAAc3K,YAAd,IAA8B4K,MAAM,CAACF,IAAP,CAAY1K,YAAZ,CAA9B,GAA0D,EAArE;AACA,MAAI6K,OAAO,GAAGzL,IAAI,CAAC+C,OAAL,CAAaqI,aAAb,CAAd;AACA,MAAIM,UAAU,GAAGJ,IAAI,CAACtI,MAAL,CAAY,UAASC,GAAT,EAAc0I,GAAd,EAAmB;AAE5C,QAAIF,OAAO,CAACxH,QAAR,CAAiB0H,GAAjB,CAAJ,EAA2B;AACvB,UAAI7C,SAAS,GAAGlI,YAAY,CAAC+K,GAAD,CAA5B,CADuB,CAGvB;AACA;;AACA,UAAIC,QAAQ,GAAG,IAAI7L,CAAC,CAACuI,KAAN,CACX6C,MAAM,CAACrK,CAAP,GAAWgI,SAAS,CAAChI,CAAV,IAAegH,IAAI,CAACa,GAAL,CAAS0C,kBAAkB,CAACvK,CAA5B,IAAiCyD,IAAI,CAAC9C,KAArD,CADA,EAEX0J,MAAM,CAACpK,CAAP,GAAW+H,SAAS,CAAC/H,CAAV,IAAe+G,IAAI,CAACa,GAAL,CAAS0C,kBAAkB,CAACtK,CAA5B,IAAiCwD,IAAI,CAAC7C,MAArD,CAFA,CAAf;AAIA,UAAImK,gBAAgB,GAAG,IAAI9L,CAAC,CAAC+L,IAAN,CAAWX,MAAX,EAAmBS,QAAnB,CAAvB,CATuB,CAWvB;AACA;;AACA,UAAIG,aAAa,GAAGF,gBAAgB,CAACG,SAAjB,CAA2BzH,IAA3B,KAAoC,EAAxD;AACA,UAAI0H,gBAAgB,GAAGF,aAAa,CAACvF,MAArC;AACA,UAAI0F,4BAAJ;AACA,UAAIC,oBAAoB,GAAG,IAA3B;;AACA,WAAK,IAAIjG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+F,gBAApB,EAAsC/F,CAAC,EAAvC,EAA2C;AACvC,YAAIkG,mBAAmB,GAAGL,aAAa,CAAC7F,CAAD,CAAvC;AACA,YAAImG,QAAQ,GAAGlB,MAAM,CAACmB,eAAP,CAAuBF,mBAAvB,CAAf;;AACA,YAAKF,4BAA4B,KAAKK,SAAlC,IAAiDF,QAAQ,GAAGH,4BAAhE,EAA+F;AAC3FA,UAAAA,4BAA4B,GAAGG,QAA/B;AACAF,UAAAA,oBAAoB,GAAGC,mBAAvB;AACH;AACJ,OAxBsB,CA0BvB;;;AACA,UAAID,oBAAJ,EAA0B;AACtB,YAAIpH,KAAK,GAAG6E,KAAK,CAACuC,oBAAD,EAAuB5E,IAAvB,EAA6BlH,SAA7B,CAAjB,CADsB,CAGtB;;AACA,YAAIkE,IAAI,CAACc,aAAL,CAAmBN,KAAnB,CAAJ,EAA+B;AAC3BA,UAAAA,KAAK,GAAG6E,KAAK,CAAC7E,KAAK,CAACyH,MAAN,CAAa1D,SAAS,CAAChI,CAAV,GAAcyG,IAAI,CAACzG,CAAhC,EAAmCgI,SAAS,CAAC/H,CAAV,GAAcwG,IAAI,CAACxG,CAAtD,CAAD,EAA2DwG,IAA3D,EAAiElH,SAAjE,CAAb;AACH,SANqB,CAQtB;AACA;;;AACA4C,QAAAA,GAAG,CAACO,IAAJ,CAASuB,KAAT;AACH;AACJ;;AAED,WAAO9B,GAAP;AACH,GA5CgB,EA4Cd,EA5Cc,CAAjB,CAT2D,CAuD3D;;AACA,MAAI,CAACsB,IAAI,CAACc,aAAL,CAAmB8F,MAAnB,CAAL,EAAiC;AAC7B;AACAO,IAAAA,UAAU,CAAClI,IAAX,CAAgBoG,KAAK,CAACuB,MAAD,EAAS5D,IAAT,EAAelH,SAAf,CAArB;AACH;;AAED,SAAOqL,UAAP;AACH,C,CAED;AACA;;;AACA,SAASe,SAAT,CAAmBtK,IAAnB,EAAyBC,EAAzB,EAA6BG,GAA7B,EAAkCV,GAAlC,EAAuC;AAEnC,MAAIxB,SAAS,GAAGwB,GAAG,CAACxB,SAApB,CAFmC,CAInC;;AAEA,MAAI2G,YAAJ,EAAkBG,YAAlB;;AAEA,MAAIhF,IAAI,YAAYpC,CAAC,CAAC2M,IAAtB,EAA4B;AAAE;AAC1B1F,IAAAA,YAAY,GAAGsC,KAAK,CAACvC,eAAe,CAAC,IAAD,EAAOlF,GAAP,CAAf,CAA2BoD,KAA3B,EAAD,EAAqC5E,SAArC,CAApB;AACH,GAFD,MAEO;AACH2G,IAAAA,YAAY,GAAGsC,KAAK,CAACnH,IAAI,CAAC8C,KAAL,EAAD,EAAe5E,SAAf,CAApB;AACH;;AAED,MAAI+B,EAAE,YAAYrC,CAAC,CAAC2M,IAApB,EAA0B;AAAE;AACxBvF,IAAAA,YAAY,GAAGmC,KAAK,CAACpC,eAAe,CAAC,IAAD,EAAOrF,GAAP,CAAf,CAA2BoD,KAA3B,EAAD,EAAqC5E,SAArC,CAApB;AACH,GAFD,MAEO;AACH8G,IAAAA,YAAY,GAAGmC,KAAK,CAAClH,EAAE,CAAC6C,KAAH,EAAD,EAAa5E,SAAb,CAApB;AACH;;AAED,MAAIkH,IAAI,GAAG0B,OAAO,CAACpH,GAAG,CAAC1B,IAAL,EAAW6G,YAAX,EAAyBG,YAAzB,CAAlB,CApBmC,CAsBnC;;AAEA,MAAIE,KAAJ,EAAWlE,GAAX,CAxBmC,CAwBnB;;AAChB,MAAIwJ,WAAJ,EAAiB9B,SAAjB,CAzBmC,CAyBP;AAE5B;;AACA,MAAI1I,IAAI,YAAYpC,CAAC,CAAC2M,IAAtB,EAA4B;AAAE;AAC1BrF,IAAAA,KAAK,GAAGL,YAAR;AACA2F,IAAAA,WAAW,GAAGzB,aAAa,CAAC7D,KAAD,EAAQlF,IAAR,EAAcN,GAAG,CAACnB,eAAlB,EAAmC6G,IAAnC,EAAyC1F,GAAzC,CAA3B;AAEH,GAJD,MAIO;AACHwF,IAAAA,KAAK,GAAGL,YAAR;AACA2F,IAAAA,WAAW,GAAG,CAACtF,KAAD,CAAd;AACH,GAnCkC,CAqCnC;;;AACA,MAAIjF,EAAE,YAAYrC,CAAC,CAAC2M,IAApB,EAA0B;AAAE;AACxBvJ,IAAAA,GAAG,GAAGgE,YAAN;AACA0D,IAAAA,SAAS,GAAGK,aAAa,CAAC/D,YAAD,EAAe/E,EAAf,EAAmBP,GAAG,CAAClB,aAAvB,EAAsC4G,IAAtC,EAA4C1F,GAA5C,CAAzB;AAEH,GAJD,MAIO;AACHsB,IAAAA,GAAG,GAAGgE,YAAN;AACA0D,IAAAA,SAAS,GAAG,CAAC1H,GAAD,CAAZ;AACH,GA7CkC,CA+CnC;;;AACAwJ,EAAAA,WAAW,GAAGA,WAAW,CAACC,MAAZ,CAAmBrK,GAAG,CAACuC,iBAAvB,EAA0CvC,GAA1C,CAAd;AACAsI,EAAAA,SAAS,GAAGA,SAAS,CAAC+B,MAAV,CAAiBrK,GAAG,CAACuC,iBAArB,EAAwCvC,GAAxC,CAAZ,CAjDmC,CAmDnC;AACA;;AACA,MAAIoK,WAAW,CAACnG,MAAZ,GAAqB,CAArB,IAA0BqE,SAAS,CAACrE,MAAV,GAAmB,CAAjD,EAAoD;AAEhD;AACA;AACA,QAAIqG,OAAO,GAAG,IAAIvH,SAAJ,EAAd,CAJgD,CAKhD;;AACA,QAAI2E,MAAM,GAAG,EAAb,CANgD,CAOhD;;AACA,QAAID,OAAO,GAAG,EAAd,CARgD,CAShD;;AACA,QAAI8C,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAI5G,CAAC,GAAG,CAAR,EAAW6G,CAAC,GAAGJ,WAAW,CAACnG,MAAhC,EAAwCN,CAAC,GAAG6G,CAA5C,EAA+C7G,CAAC,EAAhD,EAAoD;AAChD;AACA,UAAI8G,UAAU,GAAGL,WAAW,CAACzG,CAAD,CAA5B;AAEA,UAAIyF,GAAG,GAAG9B,MAAM,CAACmD,UAAD,CAAhB;AAEAH,MAAAA,OAAO,CAACjH,GAAR,CAAY+F,GAAZ,EAAiBf,YAAY,CAACoC,UAAD,EAAanC,SAAb,CAA7B;AACAZ,MAAAA,MAAM,CAAC0B,GAAD,CAAN,GAAcqB,UAAd;AACAF,MAAAA,KAAK,CAACnB,GAAD,CAAL,GAAa,CAAb;AACH;;AAED,QAAIsB,2BAA2B,GAAGpL,GAAG,CAACqL,sBAAtC,CAvBgD,CAuBc;;AAC9D,QAAIC,eAAe,GAAIF,2BAA2B,KAAKV,SAAvD,CAxBgD,CA0BhD;;AACA,QAAIzD,SAAJ,EAAeJ,eAAf;AACA,QAAItH,UAAU,GAAGS,GAAG,CAACT,UAArB;AACAwH,IAAAA,cAAc,CAACxH,UAAD,EAAamG,IAAb,EAAmB1F,GAAnB,CAAd;AAEA,QAAIyF,aAAa,GAAGlG,UAAU,CAACoF,MAA/B;AAEA,QAAI4G,aAAa,GAAGpN,IAAI,CAAC+C,OAAL,CAAa8H,SAAb,EAAwB7H,MAAxB,CAA+B,UAASC,GAAT,EAAcoK,QAAd,EAAwB;AACvE;AAEA,UAAI1B,GAAG,GAAG9B,MAAM,CAACwD,QAAD,CAAhB;AACApK,MAAAA,GAAG,CAACO,IAAJ,CAASmI,GAAT;AACA,aAAO1I,GAAP;AACH,KANmB,EAMjB,EANiB,CAApB,CAjCgD,CAyChD;;AACA,QAAIqK,cAAc,GAAGzL,GAAG,CAACzB,YAAzB;;AACA,WAAO,CAACyM,OAAO,CAACtG,OAAR,EAAD,IAAsB+G,cAAc,GAAG,CAA9C,EAAiD;AAE7C;AACA,UAAIhD,UAAU,GAAGuC,OAAO,CAACpG,GAAR,EAAjB;AACA,UAAI8G,YAAY,GAAGtD,MAAM,CAACK,UAAD,CAAzB;AACA,UAAIkD,aAAa,GAAGxD,OAAO,CAACM,UAAD,CAA3B;AACA,UAAImD,WAAW,GAAGX,KAAK,CAACxC,UAAD,CAAvB;AAEA,UAAIoD,gBAAgB,GAAIF,aAAa,KAAKjB,SAA1C,CAR6C,CAQS;;AACtD,UAAIoB,OAAO,GAAGJ,YAAY,CAAC/C,MAAb,CAAoBnD,KAApB,CAAd,CAT6C,CASH;;AAE1C,UAAI6F,sBAAJ;AACA,UAAI,CAACQ,gBAAL,EAAuBR,sBAAsB,GAAG9F,iBAAiB,CAACoG,aAAD,EAAgBD,YAAhB,EAA8BjG,aAA9B,EAA6CC,IAA7C,EAAmD1F,GAAnD,CAA1C,CAAvB,CAA0H;AAA1H,WACK,IAAI,CAACsL,eAAL,EAAsBD,sBAAsB,GAAGD,2BAAzB,CAAtB,CAA4E;AAA5E,aACA,IAAI,CAACU,OAAL,EAAcT,sBAAsB,GAAG9F,iBAAiB,CAACC,KAAD,EAAQkG,YAAR,EAAsBjG,aAAtB,EAAqCC,IAArC,EAA2C1F,GAA3C,CAA1C,CAAd,CAAyG;AAAzG,eACAqL,sBAAsB,GAAG,IAAzB,CAfwC,CAeT;AAEpC;;AACA,UAAIU,UAAU,GAAG5N,IAAI,CAAC6N,OAAL,CAAalB,WAAb,EAA0B9B,SAA1B,CAAjB;AACA,UAAIiD,YAAY,GAAIJ,gBAAgB,IAAIE,UAAxC;;AACA,UAAI,CAACE,YAAD,IAAkBV,aAAa,CAACrH,OAAd,CAAsBuE,UAAtB,KAAqC,CAA3D,EAA+D;AAC3DzI,QAAAA,GAAG,CAACqL,sBAAJ,GAA6BA,sBAA7B;AACA,eAAOnD,gBAAgB,CAACC,OAAD,EAAUC,MAAV,EAAkBsD,YAAlB,EAAgClG,KAAhC,EAAuClE,GAAvC,EAA4CoE,IAA5C,EAAkD1F,GAAlD,CAAvB;AACH,OAvB4C,CAyB7C;;;AACA,WAAKqE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGoB,aAAhB,EAA+BpB,CAAC,EAAhC,EAAoC;AAChC4C,QAAAA,SAAS,GAAG1H,UAAU,CAAC8E,CAAD,CAAtB;AAEA,YAAI6H,cAAc,GAAGjF,SAAS,CAACkF,KAA/B;AACAtF,QAAAA,eAAe,GAAGH,kBAAkB,CAAC2E,sBAAD,EAAyBa,cAAzB,CAApC,CAJgC,CAMhC;AACA;;AACA,YAAI,EAAEZ,eAAe,IAAIQ,OAArB,KAAiCjF,eAAe,GAAG7G,GAAG,CAACvB,yBAA3D,EAAsF;AAEtF,YAAI2N,aAAa,GAAGrE,KAAK,CAAC2D,YAAY,CAACtI,KAAb,GAAqBuH,MAArB,CAA4B1D,SAAS,CAACC,WAAtC,EAAmDD,SAAS,CAACE,WAA7D,CAAD,EAA4EzB,IAA5E,EAAkFlH,SAAlF,CAAzB;AACA,YAAI6N,WAAW,GAAGrE,MAAM,CAACoE,aAAD,CAAxB,CAXgC,CAahC;;AACA,YAAIpB,OAAO,CAACvG,OAAR,CAAgB4H,WAAhB,KAAgC,CAAC3L,GAAG,CAACuC,iBAAJ,CAAsBmJ,aAAtB,CAArC,EAA2E,SAd3C,CAgBhC;;AACA,YAAIb,aAAa,CAACrH,OAAd,CAAsBmI,WAAtB,KAAsC,CAA1C,EAA6C;AAAE;AAE3C,cAAIC,aAAa,GAAGF,aAAa,CAACzD,MAAd,CAAqBrH,GAArB,CAApB,CAFyC,CAEM;;AAE/C,cAAI,CAACgL,aAAL,EAAoB;AAChB,gBAAIC,iBAAiB,GAAGhH,iBAAiB,CAAC6G,aAAD,EAAgB9K,GAAhB,EAAqBmE,aAArB,EAAoCC,IAApC,EAA0C1F,GAA1C,CAAzC;AACA,gBAAIwM,kBAAkB,GAAG9F,kBAAkB,CAACwF,cAAD,EAAiBK,iBAAjB,CAA3C;AAEA,gBAAIC,kBAAkB,GAAGxM,GAAG,CAACvB,yBAA7B,EAAwD;AAC3D;AACJ,SA3B+B,CA6BhC;;;AAEA,YAAIgO,YAAY,GAAGxF,SAAS,CAAC3H,IAA7B;AACA,YAAIoN,eAAe,GAAGZ,OAAO,GAAG,CAAH,GAAO9L,GAAG,CAACN,SAAJ,CAAcmH,eAAd,CAApC,CAhCgC,CAgCoC;;AACpE,YAAI8F,aAAa,GAAGf,WAAW,GAAGa,YAAd,GAA6BC,eAAjD;;AAEA,YAAI,CAAC1B,OAAO,CAACxG,MAAR,CAAe6H,WAAf,CAAD,IAAiCM,aAAa,GAAG1B,KAAK,CAACoB,WAAD,CAA1D,EAA0E;AACtE;AACA;AAEAjE,UAAAA,MAAM,CAACiE,WAAD,CAAN,GAAsBD,aAAtB;AACAjE,UAAAA,OAAO,CAACkE,WAAD,CAAP,GAAuBX,YAAvB;AACAT,UAAAA,KAAK,CAACoB,WAAD,CAAL,GAAqBM,aAArB;AACA3B,UAAAA,OAAO,CAACjH,GAAR,CAAYsI,WAAZ,EAAyBM,aAAa,GAAG5D,YAAY,CAACqD,aAAD,EAAgBpD,SAAhB,CAArD;AACH;AACJ;;AAEDyC,MAAAA,cAAc;AACjB;AACJ,GA1KkC,CA4KnC;AACA;;;AACA,SAAOzL,GAAG,CAACK,aAAJ,CAAkBuM,IAAlB,CAAuB,IAAvB,EAA6BpH,KAA7B,EAAoClE,GAApC,EAAyCtB,GAAzC,CAAP;AACH,C,CAED;;;AACA,SAAS6M,cAAT,CAAwB7M,GAAxB,EAA6B;AAEzBA,EAAAA,GAAG,CAACT,UAAJ,GAAiBpB,IAAI,CAAC2O,MAAL,CAAY9M,GAAZ,EAAiB,YAAjB,CAAjB;AACAA,EAAAA,GAAG,CAACN,SAAJ,GAAgBvB,IAAI,CAAC2O,MAAL,CAAY9M,GAAZ,EAAiB,WAAjB,CAAhB;AACAA,EAAAA,GAAG,CAACL,UAAJ,GAAiBxB,IAAI,CAAC2O,MAAL,CAAY9M,GAAZ,EAAiB,YAAjB,CAAjB;AACAA,EAAAA,GAAG,CAAC+M,OAAJ,GAAc5O,IAAI,CAAC2O,MAAL,CAAY9M,GAAZ,EAAiB,SAAjB,CAAd;;AAEA,MAAIA,GAAG,CAAC+M,OAAR,EAAiB;AACb;AACA,QAAIC,KAAK,GAAG7O,IAAI,CAAC8O,cAAL,CAAoBjN,GAAG,CAAC+M,OAAxB,CAAZ;AACA/M,IAAAA,GAAG,CAACL,UAAJ,GAAiB;AACbV,MAAAA,CAAC,EAAE,CAAC+N,KAAK,CAAC3N,IADG;AAEbH,MAAAA,CAAC,EAAE,CAAC8N,KAAK,CAAChO,GAFG;AAGbY,MAAAA,KAAK,EAAEoN,KAAK,CAAC3N,IAAN,GAAa2N,KAAK,CAAC7N,KAHb;AAIbU,MAAAA,MAAM,EAAEmN,KAAK,CAAChO,GAAN,GAAYgO,KAAK,CAAC5N;AAJb,KAAjB;AAMH;;AAEDjB,EAAAA,IAAI,CAAC+C,OAAL,CAAalB,GAAG,CAACT,UAAjB,EAA6ByH,OAA7B,CAAqC,UAASC,SAAT,EAAoB;AAErD,QAAIiG,MAAM,GAAG,IAAIhP,CAAC,CAACuI,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAb;AACA,QAAI0G,MAAM,GAAG,IAAIjP,CAAC,CAACuI,KAAN,CAAYQ,SAAS,CAACzH,OAAtB,EAA+ByH,SAAS,CAACxH,OAAzC,CAAb;AAEAwH,IAAAA,SAAS,CAACkF,KAAV,GAAkBjO,CAAC,CAAC8H,cAAF,CAAiBkH,MAAM,CAACrH,KAAP,CAAasH,MAAb,CAAjB,CAAlB;AACH,GAND;AAOH,C,CAED;;;AACA,SAASC,MAAT,CAAgBrN,QAAhB,EAA0BC,GAA1B,EAA+BC,QAA/B,EAAyC;AAErC4M,EAAAA,cAAc,CAAC7M,GAAD,CAAd,CAFqC,CAIrC;;AACAC,EAAAA,QAAQ,CAACU,OAAT,CAAiBjC,aAAjB,GAAiC,CAAC,CAACsB,GAAG,CAACtB,aAAvC;AAEA,MAAIqG,UAAU,GAAGD,aAAa,CAAC7E,QAAD,EAAWD,GAAX,CAA9B;AACA,MAAIiF,UAAU,GAAGD,aAAa,CAAC/E,QAAD,EAAWD,GAAX,CAA9B;AAEA,MAAImF,YAAY,GAAGD,eAAe,CAACjF,QAAD,EAAWD,GAAX,CAAlC,CAVqC,CAWrC;AAEA;;AACA,MAAIU,GAAG,GAAI,IAAID,WAAJ,CAAgBT,GAAhB,CAAD,CAAuBc,KAAvB,CAA6Bb,QAAQ,CAACoN,KAAT,CAAeC,KAA5C,EAAmDrN,QAAQ,CAACqN,KAA5D,CAAV;AACA,MAAIC,WAAW,GAAGpP,IAAI,CAAC+C,OAAL,CAAanB,QAAb,EAAuBW,GAAvB,CAA2BxC,CAAC,CAACuI,KAA7B,CAAlB;AACA,MAAI+G,WAAW,GAAG,EAAlB;AACA,MAAInF,SAAS,GAAGlD,YAAhB,CAjBqC,CAiBP;AAE9B;AACA;;AACA,MAAI5E,EAAJ,EAAQD,IAAR;;AAEA,OAAK,IAAI+D,CAAC,GAAG,CAAR,EAAW8E,GAAG,GAAGoE,WAAW,CAAC5I,MAAlC,EAA0CN,CAAC,IAAI8E,GAA/C,EAAoD9E,CAAC,EAArD,EAAyD;AAErD,QAAIoJ,YAAY,GAAG,IAAnB;AAEAnN,IAAAA,IAAI,GAAGC,EAAE,IAAIwE,UAAb;AACAxE,IAAAA,EAAE,GAAGgN,WAAW,CAAClJ,CAAD,CAAhB;;AAEA,QAAI,CAAC9D,EAAL,EAAS;AACL;AACA;AACA;AAEAA,MAAAA,EAAE,GAAG0E,UAAL,CALK,CAOL;AACA;;AACA,UAAIyI,eAAe,GAAG,CAACzN,QAAQ,CAACqN,KAAT,CAAe/L,GAAf,CAAmB,QAAnB,EAA6BG,EAA9B,IAAoC,CAACzB,QAAQ,CAACqN,KAAT,CAAe/L,GAAf,CAAmB,QAAnB,EAA6BG,EAAxF;;AAEA,UAAIgM,eAAe,IAAIvP,IAAI,CAAC+B,UAAL,CAAgBF,GAAG,CAACQ,aAApB,CAAvB,EAA2D;AACvD;AACA,YAAImN,QAAQ,GAAIrN,IAAI,KAAKyE,UAAV,GAAwBI,YAAxB,GAAuC7E,IAAtD;AACA,YAAIsN,MAAM,GAAGrN,EAAE,CAACsC,MAAH,EAAb;AAEA4K,QAAAA,YAAY,GAAGzN,GAAG,CAACQ,aAAJ,CAAkBoM,IAAlB,CAAuB3M,QAAvB,EAAiC0N,QAAjC,EAA2CC,MAA3C,EAAmD5N,GAAnD,CAAf;AACH;AACJ,KAzBoD,CA2BrD;;;AACAyN,IAAAA,YAAY,GAAGA,YAAY,IAAI7C,SAAS,CAACgC,IAAV,CAAe3M,QAAf,EAAyBK,IAAzB,EAA+BC,EAA/B,EAAmCG,GAAnC,EAAwCV,GAAxC,CAA/B;;AAEA,QAAIyN,YAAY,KAAK,IAArB,EAA2B;AAAE;AACzB,aAAOzN,GAAG,CAACF,cAAJ,CAAmBC,QAAnB,EAA6BC,GAA7B,EAAkCC,QAAlC,CAAP;AACH;;AAED,QAAI4I,SAAS,GAAG4E,YAAY,CAAC,CAAD,CAA5B,CAlCqD,CAoCrD;;AACA,QAAI5E,SAAS,IAAIA,SAAS,CAACF,MAAV,CAAiBN,SAAjB,CAAjB,EAA8CoF,YAAY,CAAC5I,KAAb,GArCO,CAuCrD;;AACAwD,IAAAA,SAAS,GAAGoF,YAAY,CAACA,YAAY,CAAC9I,MAAb,GAAsB,CAAvB,CAAZ,IAAyC0D,SAArD;AAEAwF,IAAAA,KAAK,CAAChN,SAAN,CAAgBc,IAAhB,CAAqBmM,KAArB,CAA2BN,WAA3B,EAAwCC,YAAxC;AACH;;AAED,SAAOD,WAAP;AACH,C,CAED;;;AACA,OAAO,MAAMO,SAAS,GAAG,UAAShO,QAAT,EAAmBC,GAAnB,EAAwBC,QAAxB,EAAkC;AACvD,SAAOmN,MAAM,CAACrN,QAAD,EAAW5B,IAAI,CAACiC,MAAL,CAAY,EAAZ,EAAgB/B,MAAhB,EAAwB2B,GAAxB,CAAX,EAAyCC,QAAzC,CAAb;AACH,CAFM","sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\nimport { orthogonal } from './orthogonal.mjs';\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: ['basic.Text'],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!util.isFunction(orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return orthogonal(vertices, util.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = util.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = util.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = util.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = util.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return util.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = util.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new g.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = g.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = g.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new g.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new g.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = util.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = util.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new g.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new g.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, map, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof g.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof g.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(map.isPointAccessible, map);\n    endPoints = endPoints.filter(map.isPointAccessible, map);\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = util.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = util.isEqual(startPoints, endPoints);\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || !map.isPointAccessible(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = util.result(opt, 'directions');\n    opt.penalties = util.result(opt, 'penalties');\n    opt.paddingBox = util.result(opt, 'paddingBox');\n    opt.padding = util.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = util.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    util.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new g.Point(0, 0);\n        var point2 = new g.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = g.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    var map = (new ObstacleMap(opt)).build(linkView.paper.model, linkView.model);\n    var oldVertices = util.toArray(vertices).map(g.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && util.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, map, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nexport const manhattan = function(vertices, opt, linkView) {\n    return router(vertices, util.assign({}, config, opt), linkView);\n};\n"]},"metadata":{},"sourceType":"module"}