{"ast":null,"code":"import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs'; // default size of jump if not specified in options\n\nvar JUMP_SIZE = 5; // available jump types\n// first one taken as default\n\nvar JUMP_TYPES = ['arc', 'gap', 'cubic']; // default radius\n\nvar RADIUS = 0; // takes care of math. error for case when jump is too close to end of line\n\nvar CLOSE_PROXIMITY_PADDING = 1; // list of connector types not to jump over.\n\nvar IGNORED_CONNECTORS = ['smooth']; // internal constants for round segment\n\nvar _13 = 1 / 3;\n\nvar _23 = 2 / 3;\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\n\n\nfunction createLines(sourcePoint, targetPoint, route) {\n  // make a flattened array of all points\n  var points = [].concat(sourcePoint, route, targetPoint);\n  return points.reduce(function (resultLines, point, idx) {\n    // if there is a next point, make a line with it\n    var nextPoint = points[idx + 1];\n\n    if (nextPoint != null) {\n      resultLines[idx] = g.line(point, nextPoint);\n    }\n\n    return resultLines;\n  }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n  var paper = jumpOverLinkView.paper;\n  var updateList = paper._jumpOverUpdateList; // first time setup for this paper\n\n  if (updateList == null) {\n    updateList = paper._jumpOverUpdateList = [];\n    var graph = paper.model;\n    graph.on('batch:stop', function () {\n      if (this.hasActiveBatch()) return;\n      updateJumpOver(paper);\n    });\n    graph.on('reset', function () {\n      updateList = paper._jumpOverUpdateList = [];\n    });\n  } // add this link to a list so it can be updated when some other link is updated\n\n\n  if (updateList.indexOf(jumpOverLinkView) < 0) {\n    updateList.push(jumpOverLinkView); // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n\n    jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function () {\n      updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n    });\n  }\n}\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\n\n\nfunction updateJumpOver(paper) {\n  var updateList = paper._jumpOverUpdateList;\n\n  for (var i = 0; i < updateList.length; i++) {\n    updateList[i].requestConnectionUpdate();\n  }\n}\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\n\n\nfunction findLineIntersections(line, crossCheckLines) {\n  return util.toArray(crossCheckLines).reduce(function (res, crossCheckLine) {\n    var intersection = line.intersection(crossCheckLine);\n\n    if (intersection) {\n      res.push(intersection);\n    }\n\n    return res;\n  }, []);\n}\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\n\n\nfunction sortPoints(p1, p2) {\n  return g.line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\n\n\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce(function (resultLines, point, idx) {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (point.skip === true) {\n      return resultLines;\n    } // always grab the last line from buffer and modify it\n\n\n    var lastLine = resultLines.pop() || line; // calculate start and end of jump by moving by a given size of jump\n\n    var jumpStart = g.point(point).move(lastLine.start, -jumpSize);\n    var jumpEnd = g.point(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point\n\n    var nextPoint = intersections[idx + 1];\n\n    if (nextPoint != null) {\n      var distance = jumpEnd.distance(nextPoint);\n\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        nextPoint.skip = true;\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      var endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump\n\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        resultLines.push(lastLine);\n        return resultLines;\n      }\n    }\n\n    var startDistance = jumpEnd.distance(lastLine.start);\n\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      resultLines.push(lastLine);\n      return resultLines;\n    } // finally create a jump line\n\n\n    var jumpLine = g.line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property\n\n    jumpLine.isJump = true;\n    resultLines.push(g.line(lastLine.start, jumpStart), jumpLine, g.line(jumpEnd, lastLine.end));\n    return resultLines;\n  }, []);\n}\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\n\n\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  var path = new g.Path();\n  var segment; // first move to the start of a first line\n\n  segment = g.Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment); // make a paths from lines\n\n  util.toArray(lines).forEach(function (line, index) {\n    if (line.isJump) {\n      var angle, diff;\n      var control1, control2;\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90; // determine rotation of arc based on difference between points\n\n        diff = line.start.difference(line.end); // make sure the arc always points up (or right)\n\n        var xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) angle += 180;\n        var midpoint = line.midpoint();\n        var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n        var halfLine; // first half\n\n        halfLine = new g.Line(line.start, midpoint);\n        control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n        control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment); // second half\n\n        halfLine = new g.Line(midpoint, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n        control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = g.Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        var xOffset = jumpSize * 0.6;\n        var yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points\n\n        diff = line.start.difference(line.end); // make sure the arc always points up (or right)\n\n        xAxisRotate = Number(diff.x < 0 || diff.x === 0 && diff.y < 0);\n        if (xAxisRotate) yOffset *= -1;\n        control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n        control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n        segment = g.Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      var nextLine = lines[index + 1];\n\n      if (radius == 0 || !nextLine || nextLine.isJump) {\n        segment = g.Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  var prevDistance = curr.distance(prev) / 2;\n  var nextDistance = curr.distance(next) / 2;\n  var startMove = -Math.min(offset, prevDistance);\n  var endMove = -Math.min(offset, nextDistance);\n  var roundedStart = curr.clone().move(prev, startMove).round();\n  var roundedEnd = curr.clone().move(next, endMove).round();\n  var control1 = new g.Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);\n  var control2 = new g.Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);\n  var segment;\n  segment = g.Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\n\n\nexport const jumpover = function (sourcePoint, targetPoint, route, opt) {\n  // eslint-disable-line max-params\n  setupUpdating(this);\n  var raw = opt.raw;\n  var jumpSize = opt.size || JUMP_SIZE;\n  var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n  var radius = opt.radius || RADIUS;\n  var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS; // grab the first jump type as a default if specified one is invalid\n\n  if (JUMP_TYPES.indexOf(jumpType) === -1) {\n    jumpType = JUMP_TYPES[0];\n  }\n\n  var paper = this.paper;\n  var graph = paper.model;\n  var allLinks = graph.getLinks(); // there is just one link, draw it directly\n\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);\n  }\n\n  var thisModel = this.model;\n  var thisIndex = allLinks.indexOf(thisModel);\n  var defaultConnector = paper.options.defaultConnector || {}; // not all links are meant to be jumped over.\n\n  var links = allLinks.filter(function (link, idx) {\n    var connector = link.get('connector') || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.\n\n    if (util.toArray(ignoreConnectors).includes(connector.name)) {\n      return false;\n    } // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n\n\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n\n    return true;\n  }); // find views for all links\n\n  var linkViews = links.map(function (link) {\n    return paper.findViewByModel(link);\n  }); // create lines for this link\n\n  var thisLines = createLines(sourcePoint, targetPoint, route); // create lines for all other links\n\n  var linkLines = linkViews.map(function (linkView) {\n    if (linkView == null) {\n      return [];\n    }\n\n    if (linkView === this) {\n      return thisLines;\n    }\n\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);\n  }, this); // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n\n  var jumpingLines = thisLines.reduce(function (resultLines, thisLine) {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    var intersections = links.reduce(function (res, link, i) {\n      // don't intersection with itself\n      if (link !== thisModel) {\n        var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n        res.push.apply(res, lineIntersections);\n      }\n\n      return res;\n    }, []).sort(function (a, b) {\n      return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n    });\n\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      resultLines.push(thisLine);\n    }\n\n    return resultLines;\n  }, []);\n  var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  return raw ? path : path.serialize();\n};","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/connectors/jumpover.mjs"],"names":["util","g","JUMP_SIZE","JUMP_TYPES","RADIUS","CLOSE_PROXIMITY_PADDING","IGNORED_CONNECTORS","_13","_23","createLines","sourcePoint","targetPoint","route","points","concat","reduce","resultLines","point","idx","nextPoint","line","setupUpdating","jumpOverLinkView","paper","updateList","_jumpOverUpdateList","graph","model","on","hasActiveBatch","updateJumpOver","indexOf","push","listenToOnce","splice","i","length","requestConnectionUpdate","findLineIntersections","crossCheckLines","toArray","res","crossCheckLine","intersection","sortPoints","p1","p2","squaredLength","createJumps","intersections","jumpSize","skip","lastLine","pop","jumpStart","move","start","jumpEnd","distance","endDistance","end","startDistance","jumpLine","isJump","buildPath","lines","jumpType","radius","path","Path","segment","createSegment","appendSegment","forEach","index","angle","diff","control1","control2","difference","xAxisRotate","Number","x","y","midpoint","centerLine","Line","rotate","halfLine","pointAt","theta","xOffset","yOffset","Point","nextLine","buildRoundedSegment","offset","curr","prev","next","prevDistance","nextDistance","startMove","Math","min","endMove","roundedStart","clone","round","roundedEnd","jumpover","opt","raw","size","jump","toLowerCase","ignoreConnectors","allLinks","getLinks","thisModel","thisIndex","defaultConnector","options","links","filter","link","connector","get","includes","name","linkViews","map","findViewByModel","thisLines","linkLines","linkView","jumpingLines","thisLine","lineIntersections","apply","sort","a","b","serialize"],"mappings":"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","sourcesContent":["import * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = g.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        updateList[i].requestConnectionUpdate();\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return util.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return g.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = g.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = g.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = g.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            g.line(lastLine.start, jumpStart),\n            jumpLine,\n            g.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new g.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = g.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    util.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new g.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new g.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new g.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = g.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = g.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = g.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = g.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = g.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new g.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new g.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = g.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = g.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nexport const jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (util.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                var lineIntersections = findLineIntersections(thisLine, linkLines[i]);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n"]},"metadata":{},"sourceType":"module"}