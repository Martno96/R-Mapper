{"ast":null,"code":"import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs'; // bearing -> opposite bearing\n\nvar opposites = {\n  N: 'S',\n  S: 'N',\n  E: 'W',\n  W: 'E'\n}; // bearing -> radians\n\nvar radians = {\n  N: -Math.PI / 2 * 3,\n  S: -Math.PI / 2,\n  E: 0,\n  W: Math.PI\n}; // HELPERS //\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\n\nfunction freeJoin(p1, p2, bbox) {\n  var p = new g.Point(p1.x, p2.y);\n  if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y); // kept for reference\n  // if (bbox.containsPoint(p)) p = null;\n\n  return p;\n} // returns either width or height of a bbox based on the given bearing\n\n\nfunction getBBoxSize(bbox, bearing) {\n  return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n} // simple bearing method (calculates only orthogonal cardinals)\n\n\nfunction getBearing(from, to) {\n  if (from.x === to.x) return from.y > to.y ? 'N' : 'S';\n  if (from.y === to.y) return from.x > to.x ? 'W' : 'E';\n  return null;\n} // transform point to a rect\n\n\nfunction getPointBox(p) {\n  return new g.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n  // if both provided, opt.padding wins over opt.elementPadding\n  var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n  return {\n    x: -sides.left,\n    y: -sides.top,\n    width: sides.left + sides.right,\n    height: sides.top + sides.bottom\n  };\n} // return source bbox\n\n\nfunction getSourceBBox(linkView, opt) {\n  return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n} // return target bbox\n\n\nfunction getTargetBBox(linkView, opt) {\n  return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n} // return source anchor\n\n\nfunction getSourceAnchor(linkView, opt) {\n  if (linkView.sourceAnchor) return linkView.sourceAnchor; // fallback: center of bbox\n\n  var sourceBBox = getSourceBBox(linkView, opt);\n  return sourceBBox.center();\n} // return target anchor\n\n\nfunction getTargetAnchor(linkView, opt) {\n  if (linkView.targetAnchor) return linkView.targetAnchor; // fallback: center of bbox\n\n  var targetBBox = getTargetBBox(linkView, opt);\n  return targetBBox.center(); // default\n} // PARTIAL ROUTERS //\n\n\nfunction vertexVertex(from, to, bearing) {\n  var p1 = new g.Point(from.x, to.y);\n  var p2 = new g.Point(to.x, from.y);\n  var d1 = getBearing(from, p1);\n  var d2 = getBearing(from, p2);\n  var opposite = opposites[bearing];\n  var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n  return {\n    points: [p],\n    direction: getBearing(p, to)\n  };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n  var p = freeJoin(from, to, fromBBox);\n  return {\n    points: [p],\n    direction: getBearing(p, to)\n  };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n  var route = {};\n  var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n  var freePoints = points.filter(function (pt) {\n    return !toBBox.containsPoint(pt);\n  });\n  var freeBearingPoints = freePoints.filter(function (pt) {\n    return getBearing(pt, from) !== bearing;\n  });\n  var p;\n\n  if (freeBearingPoints.length > 0) {\n    // Try to pick a point which bears the same direction as the previous segment.\n    p = freeBearingPoints.filter(function (pt) {\n      return getBearing(from, pt) === bearing;\n    }).pop();\n    p = p || freeBearingPoints[0];\n    route.points = [p];\n    route.direction = getBearing(p, to);\n  } else {\n    // Here we found only points which are either contained in the element or they would create\n    // a link segment going in opposite direction from the previous one.\n    // We take the point inside element and move it outside the element in the direction the\n    // route is going. Now we can join this point with the current end (using freeJoin).\n    p = util.difference(points, freePoints)[0];\n    var p2 = new g.Point(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n    var p1 = freeJoin(p2, from, toBBox);\n    route.points = [p1, p2];\n    route.direction = getBearing(p2, to);\n  }\n\n  return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n  var route = elementVertex(to, from, toBBox);\n  var p1 = route.points[0];\n\n  if (fromBBox.containsPoint(p1)) {\n    route = elementVertex(from, to, fromBBox);\n    var p2 = route.points[0];\n\n    if (toBBox.containsPoint(p2)) {\n      var fromBorder = new g.Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n      var toBorder = new g.Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n      var mid = new g.Line(fromBorder, toBorder).midpoint();\n      var startRoute = elementVertex(from, mid, fromBBox);\n      var endRoute = vertexVertex(mid, to, startRoute.direction);\n      route.points = [startRoute.points[0], endRoute.points[0]];\n      route.direction = endRoute.direction;\n    }\n  }\n\n  return route;\n} // Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\n\n\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n  var route = {};\n  var boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary\n\n  var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n  var start = reversed ? to : from;\n  var end = reversed ? from : to;\n  var p1, p2, p3;\n\n  if (bearing) {\n    // Points on circle with radius equals 'W + H` are always outside the rectangle\n    // with width W and height H if the center of that circle is the center of that rectangle.\n    p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n    p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n  } else {\n    p1 = boundary.pointNearestToPoint(start).move(start, 1);\n  }\n\n  p2 = freeJoin(p1, end, boundary);\n\n  if (p1.round().equals(p2.round())) {\n    p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n    p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n    p3 = freeJoin(p1, p2, boundary);\n    route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n  } else {\n    route.points = reversed ? [p2, p1] : [p1, p2];\n  }\n\n  route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n  return route;\n} // MAIN ROUTER //\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\n\n\nexport function orthogonal(vertices, opt, linkView) {\n  var sourceBBox = getSourceBBox(linkView, opt);\n  var targetBBox = getTargetBBox(linkView, opt);\n  var sourceAnchor = getSourceAnchor(linkView, opt);\n  var targetAnchor = getTargetAnchor(linkView, opt); // if anchor lies outside of bbox, the bbox expands to include it\n\n  sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n  targetBBox = targetBBox.union(getPointBox(targetAnchor));\n  vertices = util.toArray(vertices).map(g.Point);\n  vertices.unshift(sourceAnchor);\n  vertices.push(targetAnchor);\n  var bearing; // bearing of previous route segment\n\n  var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n\n  for (var i = 0, max = vertices.length - 1; i < max; i++) {\n    var route = null;\n    var from = vertices[i];\n    var to = vertices[i + 1];\n    var isOrthogonal = !!getBearing(from, to);\n\n    if (i === 0) {\n      // source\n      if (i + 1 === max) {\n        // route source -> target\n        // Expand one of the elements by 1px to detect situations when the two\n        // elements are positioned next to each other with no gap in between.\n        if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n          route = insideElement(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = elementElement(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // route source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n        } else if (!isOrthogonal) {\n          route = elementVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === max) {\n      // route vertex -> target\n      // prevent overlaps with previous line segment\n      var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = vertexElement(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // route vertex -> vertex\n      route = vertexVertex(from, to, bearing);\n    } // applicable to all routes:\n    // set bearing for next iteration\n\n\n    if (route) {\n      Array.prototype.push.apply(orthogonalVertices, route.points);\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = getBearing(from, to);\n    } // push `to` point to identified orthogonal vertices array\n\n\n    if (i + 1 < max) {\n      orthogonalVertices.push(to);\n    }\n  }\n\n  return orthogonalVertices;\n}","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/routers/orthogonal.mjs"],"names":["g","util","opposites","N","S","E","W","radians","Math","PI","freeJoin","p1","p2","bbox","p","Point","x","y","containsPoint","getBBoxSize","bearing","getBearing","from","to","getPointBox","Rect","getPaddingBox","opt","sides","normalizeSides","padding","elementPadding","left","top","width","right","height","bottom","getSourceBBox","linkView","sourceBBox","clone","moveAndExpand","getTargetBBox","targetBBox","getSourceAnchor","sourceAnchor","center","getTargetAnchor","targetAnchor","vertexVertex","d1","d2","opposite","points","direction","elementVertex","fromBBox","vertexElement","toBBox","route","freePoints","filter","pt","freeBearingPoints","length","pop","difference","move","elementElement","fromBorder","toBorder","mid","Line","midpoint","startRoute","endRoute","insideElement","boundary","union","inflate","reversed","distance","start","end","p3","fromPolar","pointNearestToPoint","round","equals","toRad","theta","orthogonal","vertices","toArray","map","unshift","push","orthogonalVertices","i","max","isOrthogonal","intersect","isOrthogonalLoop","Array","prototype","apply"],"mappings":"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","sourcesContent":["import * as g from '../g/index.mjs';\nimport * as util from '../util/index.mjs';\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new g.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new g.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new g.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = util.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new g.Point(from.x, to.y);\n    var p2 = new g.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new g.Point(from.x, to.y), new g.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = util.difference(points, freePoints)[0];\n\n        var p2 = (new g.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new g.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new g.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new g.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = g.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = g.Point.fromPolar(boundary.width + boundary.height, g.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nexport function orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = util.toArray(vertices).map(g.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n"]},"metadata":{},"sourceType":"module"}