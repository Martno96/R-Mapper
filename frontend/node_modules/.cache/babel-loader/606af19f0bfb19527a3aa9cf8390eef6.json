{"ast":null,"code":"import * as util from '../../util/index.mjs';\nimport { Graph } from '../../dia/index.mjs';\nimport * as g from '../../g/index.mjs';\nexport const DirectedGraph = {\n  exportElement: function (element) {\n    // The width and height of the element.\n    return element.size();\n  },\n  exportLink: function (link) {\n    var labelSize = link.get('labelSize') || {};\n    var edge = {\n      // The number of ranks to keep between the source and target of the edge.\n      minLen: link.get('minLen') || 1,\n      // The weight to assign edges. Higher weight edges are generally\n      // made shorter and straighter than lower weight edges.\n      weight: link.get('weight') || 1,\n      // Where to place the label relative to the edge.\n      // l = left, c = center r = right.\n      labelpos: link.get('labelPosition') || 'c',\n      // How many pixels to move the label away from the edge.\n      // Applies only when labelpos is l or r.\n      labeloffset: link.get('labelOffset') || 0,\n      // The width of the edge label in pixels.\n      width: labelSize.width || 0,\n      // The height of the edge label in pixels.\n      height: labelSize.height || 0\n    };\n    return edge;\n  },\n  importElement: function (opt, v, gl) {\n    var element = this.getCell(v);\n    var glNode = gl.node(v);\n\n    if (opt.setPosition) {\n      opt.setPosition(element, glNode);\n    } else {\n      element.set('position', {\n        x: glNode.x - glNode.width / 2,\n        y: glNode.y - glNode.height / 2\n      });\n    }\n  },\n  importLink: function (opt, edgeObj, gl) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.getCell(edgeObj.name);\n    const glEdge = gl.edge(edgeObj);\n    const points = glEdge.points || [];\n    const polyline = new g.Polyline(points); // check the `setLinkVertices` here for backwards compatibility\n\n    if (opt.setVertices || opt.setLinkVertices) {\n      if (util.isFunction(opt.setVertices)) {\n        opt.setVertices(link, points);\n      } else {\n        // simplify the `points` polyline\n        polyline.simplify({\n          threshold: SIMPLIFY_THRESHOLD\n        });\n        const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n        // set simplified polyline points as link vertices\n        // remove first and last polyline points (= source/target sonnectionPoints)\n\n        link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n      }\n    }\n\n    if (opt.setLabels && 'x' in glEdge && 'y' in glEdge) {\n      const labelPosition = {\n        x: glEdge.x,\n        y: glEdge.y\n      };\n\n      if (util.isFunction(opt.setLabels)) {\n        opt.setLabels(link, labelPosition, points);\n      } else {\n        // convert the absolute label position to a relative position\n        // towards the closest point on the edge\n        const length = polyline.closestPointLength(labelPosition);\n        const closestPoint = polyline.pointAtLength(length);\n        const distance = length / polyline.length();\n        const offset = new g.Point(labelPosition).difference(closestPoint).toJSON();\n        link.label(0, {\n          position: {\n            distance: distance,\n            offset: offset\n          }\n        });\n      }\n    }\n  },\n  layout: function (graphOrCells, opt) {\n    var graph;\n\n    if (graphOrCells instanceof Graph) {\n      graph = graphOrCells;\n    } else {\n      // Reset cells in dry mode so the graph reference is not stored on the cells.\n      // `sort: false` to prevent elements to change their order based on the z-index\n      graph = new Graph().resetCells(graphOrCells, {\n        dry: true,\n        sort: false\n      });\n    } // This is not needed anymore.\n\n\n    graphOrCells = null;\n    opt = util.defaults(opt || {}, {\n      resizeClusters: true,\n      clusterPadding: 10,\n      exportElement: this.exportElement,\n      exportLink: this.exportLink\n    });\n    /* global dagre: true */\n\n    const dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n    /* global dagre: false */\n\n    if (dagreUtil === undefined) throw new Error('The the \"dagre\" utility is a mandatory dependency.'); // create a graphlib.Graph that represents the joint.dia.Graph\n    // var glGraph = graph.toGraphLib({\n\n    var glGraph = DirectedGraph.toGraphLib(graph, {\n      graphlib: opt.graphlib,\n      directed: true,\n      // We are about to use edge naming feature.\n      multigraph: true,\n      // We are able to layout graphs with embeds.\n      compound: true,\n      setNodeLabel: opt.exportElement,\n      setEdgeLabel: opt.exportLink,\n      setEdgeName: function (link) {\n        // Graphlib edges have no ids. We use edge name property\n        // to store and retrieve ids instead.\n        return link.id;\n      }\n    });\n    var glLabel = {};\n    var marginX = opt.marginX || 0;\n    var marginY = opt.marginY || 0; // Dagre layout accepts options as lower case.\n    // Direction for rank nodes. Can be TB, BT, LR, or RL\n\n    if (opt.rankDir) glLabel.rankdir = opt.rankDir; // Alignment for rank nodes. Can be UL, UR, DL, or DR\n\n    if (opt.align) glLabel.align = opt.align; // Number of pixels that separate nodes horizontally in the layout.\n\n    if (opt.nodeSep) glLabel.nodesep = opt.nodeSep; // Number of pixels that separate edges horizontally in the layout.\n\n    if (opt.edgeSep) glLabel.edgesep = opt.edgeSep; // Number of pixels between each rank in the layout.\n\n    if (opt.rankSep) glLabel.ranksep = opt.rankSep; // Type of algorithm to assign a rank to each node in the input graph.\n    // Possible values: network-simplex, tight-tree or longest-path\n\n    if (opt.ranker) glLabel.ranker = opt.ranker; // Number of pixels to use as a margin around the left and right of the graph.\n\n    if (marginX) glLabel.marginx = marginX; // Number of pixels to use as a margin around the top and bottom of the graph.\n\n    if (marginY) glLabel.marginy = marginY; // Set the option object for the graph label.\n\n    glGraph.setGraph(glLabel); // Executes the layout.\n\n    dagreUtil.layout(glGraph, {\n      debugTiming: !!opt.debugTiming\n    }); // Wrap all graph changes into a batch.\n\n    graph.startBatch('layout');\n    DirectedGraph.fromGraphLib(glGraph, {\n      importNode: this.importElement.bind(graph, opt),\n      importEdge: this.importLink.bind(graph, opt)\n    }); // // Update the graph.\n    // graph.fromGraphLib(glGraph, {\n    //     importNode: this.importElement.bind(graph, opt),\n    //     importEdge: this.importLink.bind(graph, opt)\n    // });\n\n    if (opt.resizeClusters) {\n      // Resize and reposition cluster elements (parents of other elements)\n      // to fit their children.\n      // 1. filter clusters only\n      // 2. map id on cells\n      // 3. sort cells by their depth (the deepest first)\n      // 4. resize cell to fit their direct children only.\n      var clusters = glGraph.nodes().filter(function (v) {\n        return glGraph.children(v).length > 0;\n      }).map(graph.getCell.bind(graph)).sort(function (aCluster, bCluster) {\n        return bCluster.getAncestors().length - aCluster.getAncestors().length;\n      });\n      util.invoke(clusters, 'fitEmbeds', {\n        padding: opt.clusterPadding\n      });\n    }\n\n    graph.stopBatch('layout'); // Width and height of the graph extended by margins.\n\n    var glSize = glGraph.graph(); // Return the bounding box of the graph after the layout.\n\n    return new g.Rect(marginX, marginY, Math.abs(glSize.width - 2 * marginX), Math.abs(glSize.height - 2 * marginY));\n  },\n  fromGraphLib: function (glGraph, opt) {\n    opt = opt || {};\n    var importNode = opt.importNode || util.noop;\n    var importEdge = opt.importEdge || util.noop;\n    var graph = this instanceof Graph ? this : new Graph(); // Import all nodes.\n\n    glGraph.nodes().forEach(function (node) {\n      importNode.call(graph, node, glGraph, graph, opt);\n    }); // Import all edges.\n\n    glGraph.edges().forEach(function (edge) {\n      importEdge.call(graph, edge, glGraph, graph, opt);\n    });\n    return graph;\n  },\n  // Create new graphlib graph from existing JointJS graph.\n  toGraphLib: function (graph, opt) {\n    opt = opt || {};\n    /* global graphlib: true */\n\n    const graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n    /* global graphlib: false */\n\n    if (graphlibUtil === undefined) throw new Error('The the \"graphlib\" utility is a mandatory dependency.');\n    var glGraphType = util.pick(opt, 'directed', 'compound', 'multigraph');\n    var glGraph = new graphlibUtil.Graph(glGraphType);\n    var setNodeLabel = opt.setNodeLabel || util.noop;\n    var setEdgeLabel = opt.setEdgeLabel || util.noop;\n    var setEdgeName = opt.setEdgeName || util.noop;\n    var collection = graph.get('cells');\n\n    for (var i = 0, n = collection.length; i < n; i++) {\n      var cell = collection.at(i);\n\n      if (cell.isLink()) {\n        var source = cell.get('source');\n        var target = cell.get('target'); // Links that end at a point are ignored.\n\n        if (!source.id || !target.id) break; // Note that if we are creating a multigraph we can name the edges. If\n        // we try to name edges on a non-multigraph an exception is thrown.\n\n        glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n      } else {\n        glGraph.setNode(cell.id, setNodeLabel(cell)); // For the compound graphs we have to take embeds into account.\n\n        if (glGraph.isCompound() && cell.has('parent')) {\n          var parentId = cell.get('parent');\n\n          if (collection.has(parentId)) {\n            // Make sure the parent cell is included in the graph (this can\n            // happen when the layout is run on part of the graph only).\n            glGraph.setParent(cell.id, parentId);\n          }\n        }\n      }\n    }\n\n    return glGraph;\n  }\n};\n\nGraph.prototype.toGraphLib = function (opt) {\n  return DirectedGraph.toGraphLib(this, opt);\n};\n\nGraph.prototype.fromGraphLib = function (glGraph, opt) {\n  return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n};","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/layout/DirectedGraph/DirectedGraph.mjs"],"names":["util","Graph","g","DirectedGraph","exportElement","element","size","exportLink","link","labelSize","get","edge","minLen","weight","labelpos","labeloffset","width","height","importElement","opt","v","gl","getCell","glNode","node","setPosition","set","x","y","importLink","edgeObj","SIMPLIFY_THRESHOLD","name","glEdge","points","polyline","Polyline","setVertices","setLinkVertices","isFunction","simplify","threshold","polylinePoints","map","point","toJSON","numPolylinePoints","length","slice","setLabels","labelPosition","closestPointLength","closestPoint","pointAtLength","distance","offset","Point","difference","label","position","layout","graphOrCells","graph","resetCells","dry","sort","defaults","resizeClusters","clusterPadding","dagreUtil","dagre","undefined","Error","glGraph","toGraphLib","graphlib","directed","multigraph","compound","setNodeLabel","setEdgeLabel","setEdgeName","id","glLabel","marginX","marginY","rankDir","rankdir","align","nodeSep","nodesep","edgeSep","edgesep","rankSep","ranksep","ranker","marginx","marginy","setGraph","debugTiming","startBatch","fromGraphLib","importNode","bind","importEdge","clusters","nodes","filter","children","aCluster","bCluster","getAncestors","invoke","padding","stopBatch","glSize","Rect","Math","abs","noop","forEach","call","edges","graphlibUtil","glGraphType","pick","collection","i","n","cell","at","isLink","source","target","setEdge","setNode","isCompound","has","parentId","setParent","prototype"],"mappings":"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","sourcesContent":["import * as util from '../../util/index.mjs';\nimport { Graph } from '../../dia/index.mjs';\nimport * as g from '../../g/index.mjs';\n\nexport const DirectedGraph = {\n\n    exportElement: function(element) {\n\n        // The width and height of the element.\n        return element.size();\n    },\n\n    exportLink: function(link) {\n\n        var labelSize = link.get('labelSize') || {};\n        var edge = {\n            // The number of ranks to keep between the source and target of the edge.\n            minLen: link.get('minLen') || 1,\n            // The weight to assign edges. Higher weight edges are generally\n            // made shorter and straighter than lower weight edges.\n            weight: link.get('weight') || 1,\n            // Where to place the label relative to the edge.\n            // l = left, c = center r = right.\n            labelpos: link.get('labelPosition') || 'c',\n            // How many pixels to move the label away from the edge.\n            // Applies only when labelpos is l or r.\n            labeloffset: link.get('labelOffset') || 0,\n            // The width of the edge label in pixels.\n            width: labelSize.width || 0,\n            // The height of the edge label in pixels.\n            height: labelSize.height || 0\n        };\n\n        return edge;\n    },\n\n    importElement: function(opt, v, gl) {\n\n        var element = this.getCell(v);\n        var glNode = gl.node(v);\n\n        if (opt.setPosition) {\n            opt.setPosition(element, glNode);\n        } else {\n            element.set('position', {\n                x: glNode.x - glNode.width / 2,\n                y: glNode.y - glNode.height / 2\n            });\n        }\n    },\n\n    importLink: function(opt, edgeObj, gl) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.getCell(edgeObj.name);\n        const glEdge = gl.edge(edgeObj);\n        const points = glEdge.points || [];\n        const polyline = new g.Polyline(points);\n\n        // check the `setLinkVertices` here for backwards compatibility\n        if (opt.setVertices || opt.setLinkVertices) {\n            if (util.isFunction(opt.setVertices)) {\n                opt.setVertices(link, points);\n            } else {\n                // simplify the `points` polyline\n                polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n                const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n                const numPolylinePoints = polylinePoints.length; // number of points after simplification\n                // set simplified polyline points as link vertices\n                // remove first and last polyline points (= source/target sonnectionPoints)\n                link.set('vertices', polylinePoints.slice(1, numPolylinePoints - 1));\n            }\n        }\n\n        if (opt.setLabels && ('x' in glEdge) && ('y' in glEdge)) {\n            const labelPosition = { x: glEdge.x, y: glEdge.y };\n            if (util.isFunction(opt.setLabels)) {\n                opt.setLabels(link, labelPosition, points);\n            } else {\n                // convert the absolute label position to a relative position\n                // towards the closest point on the edge\n                const length = polyline.closestPointLength(labelPosition);\n                const closestPoint = polyline.pointAtLength(length);\n                const distance = (length / polyline.length());\n                const offset = new g.Point(labelPosition).difference(closestPoint).toJSON();\n                link.label(0, {\n                    position: {\n                        distance: distance,\n                        offset: offset\n                    }\n                });\n            }\n        }\n    },\n\n    layout: function(graphOrCells, opt) {\n\n        var graph;\n\n        if (graphOrCells instanceof Graph) {\n            graph = graphOrCells;\n        } else {\n            // Reset cells in dry mode so the graph reference is not stored on the cells.\n            // `sort: false` to prevent elements to change their order based on the z-index\n            graph = (new Graph()).resetCells(graphOrCells, { dry: true, sort: false });\n        }\n\n        // This is not needed anymore.\n        graphOrCells = null;\n\n        opt = util.defaults(opt || {}, {\n            resizeClusters: true,\n            clusterPadding: 10,\n            exportElement: this.exportElement,\n            exportLink: this.exportLink\n        });\n\n        /* global dagre: true */\n        const dagreUtil = opt.dagre || (typeof dagre !== 'undefined' ? dagre : undefined);\n        /* global dagre: false */\n\n        if (dagreUtil === undefined) throw new Error('The the \"dagre\" utility is a mandatory dependency.');\n\n        // create a graphlib.Graph that represents the joint.dia.Graph\n        // var glGraph = graph.toGraphLib({\n        var glGraph = DirectedGraph.toGraphLib(graph, {\n            graphlib: opt.graphlib,\n            directed: true,\n            // We are about to use edge naming feature.\n            multigraph: true,\n            // We are able to layout graphs with embeds.\n            compound: true,\n            setNodeLabel: opt.exportElement,\n            setEdgeLabel: opt.exportLink,\n            setEdgeName: function(link) {\n                // Graphlib edges have no ids. We use edge name property\n                // to store and retrieve ids instead.\n                return link.id;\n            }\n        });\n\n        var glLabel = {};\n        var marginX = opt.marginX || 0;\n        var marginY = opt.marginY || 0;\n\n        // Dagre layout accepts options as lower case.\n        // Direction for rank nodes. Can be TB, BT, LR, or RL\n        if (opt.rankDir) glLabel.rankdir = opt.rankDir;\n        // Alignment for rank nodes. Can be UL, UR, DL, or DR\n        if (opt.align) glLabel.align = opt.align;\n        // Number of pixels that separate nodes horizontally in the layout.\n        if (opt.nodeSep) glLabel.nodesep = opt.nodeSep;\n        // Number of pixels that separate edges horizontally in the layout.\n        if (opt.edgeSep) glLabel.edgesep = opt.edgeSep;\n        // Number of pixels between each rank in the layout.\n        if (opt.rankSep) glLabel.ranksep = opt.rankSep;\n        // Type of algorithm to assign a rank to each node in the input graph.\n        // Possible values: network-simplex, tight-tree or longest-path\n        if (opt.ranker) glLabel.ranker = opt.ranker;\n        // Number of pixels to use as a margin around the left and right of the graph.\n        if (marginX) glLabel.marginx = marginX;\n        // Number of pixels to use as a margin around the top and bottom of the graph.\n        if (marginY) glLabel.marginy = marginY;\n\n        // Set the option object for the graph label.\n        glGraph.setGraph(glLabel);\n\n        // Executes the layout.\n        dagreUtil.layout(glGraph, { debugTiming: !!opt.debugTiming });\n\n        // Wrap all graph changes into a batch.\n        graph.startBatch('layout');\n\n        DirectedGraph.fromGraphLib(glGraph, {\n            importNode: this.importElement.bind(graph, opt),\n            importEdge: this.importLink.bind(graph, opt)\n        });\n\n        // // Update the graph.\n        // graph.fromGraphLib(glGraph, {\n        //     importNode: this.importElement.bind(graph, opt),\n        //     importEdge: this.importLink.bind(graph, opt)\n        // });\n\n        if (opt.resizeClusters) {\n            // Resize and reposition cluster elements (parents of other elements)\n            // to fit their children.\n            // 1. filter clusters only\n            // 2. map id on cells\n            // 3. sort cells by their depth (the deepest first)\n            // 4. resize cell to fit their direct children only.\n            var clusters = glGraph.nodes()\n                .filter(function(v) { return glGraph.children(v).length > 0; })\n                .map(graph.getCell.bind(graph))\n                .sort(function(aCluster, bCluster) {\n                    return bCluster.getAncestors().length - aCluster.getAncestors().length;\n                });\n\n            util.invoke(clusters, 'fitEmbeds', { padding: opt.clusterPadding });\n        }\n\n        graph.stopBatch('layout');\n\n        // Width and height of the graph extended by margins.\n        var glSize = glGraph.graph();\n        // Return the bounding box of the graph after the layout.\n        return new g.Rect(\n            marginX,\n            marginY,\n            Math.abs(glSize.width - 2 * marginX),\n            Math.abs(glSize.height - 2 * marginY)\n        );\n    },\n\n    fromGraphLib: function(glGraph, opt) {\n\n        opt = opt || {};\n\n        var importNode = opt.importNode || util.noop;\n        var importEdge = opt.importEdge || util.noop;\n        var graph = (this instanceof Graph) ? this : new Graph;\n\n        // Import all nodes.\n        glGraph.nodes().forEach(function(node) {\n            importNode.call(graph, node, glGraph, graph, opt);\n        });\n\n        // Import all edges.\n        glGraph.edges().forEach(function(edge) {\n            importEdge.call(graph, edge, glGraph, graph, opt);\n        });\n\n        return graph;\n    },\n\n    // Create new graphlib graph from existing JointJS graph.\n    toGraphLib: function(graph, opt) {\n\n        opt = opt || {};\n\n        /* global graphlib: true */\n        const graphlibUtil = opt.graphlib || (typeof graphlib !== 'undefined' ? graphlib : undefined);\n        /* global graphlib: false */\n\n        if (graphlibUtil === undefined) throw new Error('The the \"graphlib\" utility is a mandatory dependency.');\n\n        var glGraphType = util.pick(opt, 'directed', 'compound', 'multigraph');\n        var glGraph = new graphlibUtil.Graph(glGraphType);\n        var setNodeLabel = opt.setNodeLabel || util.noop;\n        var setEdgeLabel = opt.setEdgeLabel || util.noop;\n        var setEdgeName = opt.setEdgeName || util.noop;\n        var collection = graph.get('cells');\n\n        for (var i = 0, n = collection.length; i < n; i++) {\n\n            var cell = collection.at(i);\n            if (cell.isLink()) {\n\n                var source = cell.get('source');\n                var target = cell.get('target');\n\n                // Links that end at a point are ignored.\n                if (!source.id || !target.id) break;\n\n                // Note that if we are creating a multigraph we can name the edges. If\n                // we try to name edges on a non-multigraph an exception is thrown.\n                glGraph.setEdge(source.id, target.id, setEdgeLabel(cell), setEdgeName(cell));\n\n            } else {\n\n                glGraph.setNode(cell.id, setNodeLabel(cell));\n\n                // For the compound graphs we have to take embeds into account.\n                if (glGraph.isCompound() && cell.has('parent')) {\n                    var parentId = cell.get('parent');\n                    if (collection.has(parentId)) {\n                        // Make sure the parent cell is included in the graph (this can\n                        // happen when the layout is run on part of the graph only).\n                        glGraph.setParent(cell.id, parentId);\n                    }\n                }\n            }\n        }\n\n        return glGraph;\n    }\n};\n\nGraph.prototype.toGraphLib = function(opt) {\n\n    return DirectedGraph.toGraphLib(this, opt);\n};\n\nGraph.prototype.fromGraphLib = function(glGraph, opt) {\n\n    return DirectedGraph.fromGraphLib.call(this, glGraph, opt);\n};\n"]},"metadata":{},"sourceType":"module"}