{"ast":null,"code":"import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\nvar config = {\n  maxAllowedDirectionChange: 45,\n  // cost of a diagonal step\n  diagonalCost: function () {\n    var step = this.step;\n    return Math.ceil(Math.sqrt(step * step << 1));\n  },\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions: function () {\n    var step = this.step;\n    var cost = this.cost();\n    var diagonalCost = this.diagonalCost();\n    return [{\n      offsetX: step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: step,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: step,\n      cost: diagonalCost\n    }, {\n      offsetX: -step,\n      offsetY: 0,\n      cost: cost\n    }, {\n      offsetX: -step,\n      offsetY: -step,\n      cost: diagonalCost\n    }, {\n      offsetX: 0,\n      offsetY: -step,\n      cost: cost\n    }, {\n      offsetX: step,\n      offsetY: -step,\n      cost: diagonalCost\n    }];\n  },\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute: function (from, to, opt) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    var theta = from.theta(to);\n    var route = [];\n    var a = {\n      x: to.x,\n      y: from.y\n    };\n    var b = {\n      x: from.x,\n      y: to.y\n    };\n\n    if (theta % 180 > 90) {\n      var t = a;\n      a = b;\n      b = t;\n    }\n\n    var p1 = theta % 90 < 45 ? a : b;\n    var l1 = new g.Line(from, p1);\n    var alpha = 90 * Math.ceil(theta / 90);\n    var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n    var l2 = new g.Line(to, p2);\n    var intersectionPoint = l1.intersection(l2);\n    var point = intersectionPoint ? intersectionPoint : to;\n    var directionFrom = intersectionPoint ? point : from;\n    var quadrant = 360 / opt.directions.length;\n    var angleTheta = directionFrom.theta(to);\n    var normalizedAngle = g.normalizeAngle(angleTheta + quadrant / 2);\n    var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    opt.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n}; // public function\n\nexport const metro = function (vertices, opt, linkView) {\n  if (!util.isFunction(manhattan)) {\n    throw new Error('Metro requires the manhattan router.');\n  }\n\n  return manhattan(vertices, util.assign({}, config, opt), linkView);\n};","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/r-mapper v.2/r-mapper/node_modules/jointjs/src/routers/metro.mjs"],"names":["manhattan","util","g","config","maxAllowedDirectionChange","diagonalCost","step","Math","ceil","sqrt","directions","cost","offsetX","offsetY","fallbackRoute","from","to","opt","theta","route","a","x","y","b","t","p1","l1","Line","alpha","p2","Point","fromPolar","squaredLength","toRad","l2","intersectionPoint","intersection","point","directionFrom","quadrant","length","angleTheta","normalizedAngle","normalizeAngle","directionAngle","floor","previousDirectionAngle","push","round","metro","vertices","linkView","isFunction","Error","assign"],"mappings":"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","sourcesContent":["import { manhattan } from './manhattan.mjs';\nimport * as util from '../util/index.mjs';\nimport * as g from '../g/index.mjs';\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new g.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = g.Point.fromPolar(l1.squaredLength(), g.toRad(alpha + 135), p1);\n        var l2 = new g.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = g.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nexport const metro = function(vertices, opt, linkView) {\n\n    if (!util.isFunction(manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return manhattan(vertices, util.assign({}, config, opt), linkView);\n};\n\n"]},"metadata":{},"sourceType":"module"}