{"ast":null,"code":"import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery'; // Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('link');\n    return classNames.join(' ');\n  },\n  options: {\n    shortLinkLength: 105,\n    doubleLinkTools: false,\n    longLinkLength: 155,\n    linkToolsOffset: 40,\n    doubleLinkToolsOffset: 65,\n    sampleInterval: 50\n  },\n  _labelCache: null,\n  _labelSelectors: null,\n  _markerCache: null,\n  _V: null,\n  _dragData: null,\n  // deprecated\n  metrics: null,\n  decimalsRounding: 2,\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments); // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n    // nodes in `updateLabelPosition()` in order to update the label positions.\n\n    this._labelCache = {}; // a cache of label selectors\n\n    this._labelSelectors = {}; // keeps markers bboxes and positions again for quicker access\n\n    this._markerCache = {}; // cache of default markup nodes\n\n    this._V = {}; // connection path metrics\n\n    this.metrics = {};\n  },\n  presentationAttributes: {\n    markup: ['RENDER'],\n    attrs: ['UPDATE'],\n    router: ['UPDATE'],\n    connector: ['UPDATE'],\n    smooth: ['UPDATE'],\n    manhattan: ['UPDATE'],\n    toolMarkup: ['LEGACY_TOOLS'],\n    labels: ['LABELS'],\n    labelMarkup: ['LABELS'],\n    vertices: ['VERTICES', 'UPDATE'],\n    vertexMarkup: ['VERTICES'],\n    source: ['SOURCE', 'UPDATE'],\n    target: ['TARGET', 'UPDATE']\n  },\n  initFlag: ['RENDER', 'SOURCE', 'TARGET', 'TOOLS'],\n  UPDATE_PRIORITY: 1,\n  confirmUpdate: function (flags, opt) {\n    opt || (opt = {});\n\n    if (this.hasFlag(flags, 'SOURCE')) {\n      if (!this.updateEndProperties('source')) return flags;\n      flags = this.removeFlag(flags, 'SOURCE');\n    }\n\n    if (this.hasFlag(flags, 'TARGET')) {\n      if (!this.updateEndProperties('target')) return flags;\n      flags = this.removeFlag(flags, 'TARGET');\n    }\n\n    const {\n      paper,\n      sourceView,\n      targetView\n    } = this;\n\n    if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered\n      return flags;\n    }\n\n    if (this.hasFlag(flags, 'RENDER')) {\n      this.render();\n      this.updateHighlighters(true);\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, ['RENDER', 'UPDATE', 'VERTICES', 'LABELS', 'TOOLS', 'LEGACY_TOOLS']);\n      return flags;\n    }\n\n    let updateHighlighters = false;\n\n    if (this.hasFlag(flags, 'VERTICES')) {\n      this.renderVertexMarkers();\n      flags = this.removeFlag(flags, 'VERTICES');\n    }\n\n    const {\n      model\n    } = this;\n    const {\n      attributes\n    } = model;\n    let updateLabels = this.hasFlag(flags, 'LABELS');\n    let updateLegacyTools = this.hasFlag(flags, 'LEGACY_TOOLS');\n\n    if (updateLabels) {\n      this.onLabelsChange(model, attributes.labels, opt);\n      flags = this.removeFlag(flags, 'LABELS');\n      updateHighlighters = true;\n    }\n\n    if (updateLegacyTools) {\n      this.renderTools();\n      flags = this.removeFlag(flags, 'LEGACY_TOOLS');\n    }\n\n    if (this.hasFlag(flags, 'UPDATE')) {\n      this.update(model, null, opt);\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, ['UPDATE', 'TOOLS']);\n      updateLabels = false;\n      updateLegacyTools = false;\n      updateHighlighters = true;\n    }\n\n    if (updateLabels) {\n      this.updateLabelPositions();\n    }\n\n    if (updateLegacyTools) {\n      this.updateToolsPosition();\n    }\n\n    if (updateHighlighters) {\n      this.updateHighlighters();\n    }\n\n    if (this.hasFlag(flags, 'TOOLS')) {\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, 'TOOLS');\n    }\n\n    return flags;\n  },\n  requestConnectionUpdate: function (opt) {\n    this.requestUpdate(this.getFlag('UPDATE', opt));\n  },\n  isLabelsRenderRequired: function (opt = {}) {\n    const previousLabels = this.model.previous('labels');\n    if (!previousLabels) return true; // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n\n    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n      // The label is setting by `prop()` method\n      var pathArray = opt.propertyPathArray || [];\n      var pathLength = pathArray.length;\n\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        var labelExists = !!previousLabels[pathArray[1]];\n\n        if (labelExists) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return 'markup' in Object(opt.propertyValue);\n          } else if (pathArray[2] !== 'markup') {\n            // We are changing a label property but not the markup\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  },\n  onLabelsChange: function (_link, _labels, opt) {\n    // Note: this optimization works in async=false mode only\n    if (this.isLabelsRenderRequired(opt)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n  },\n  // Rendering.\n  // ----------\n  render: function () {\n    this.vel.empty();\n    this._V = {};\n    this.renderMarkup(); // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n    // returns zero values)\n\n    this.renderLabels();\n    this.update();\n    return this;\n  },\n  renderMarkup: function () {\n    var link = this.model;\n    var markup = link.get('markup') || link.markup;\n    if (!markup) throw new Error('dia.LinkView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.LinkView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el); // Selectors\n\n    this.selectors = doc.selectors; // Fragment\n\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    // A special markup can be given in the `properties.markup` property. This might be handy\n    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n    // of elements with special meaning though. Therefore, those classes should be preserved in any\n    // special markup passed in `properties.markup`.\n    var children = V(markup); // custom markup may contain only one children\n\n    if (!Array.isArray(children)) children = [children]; // Cache all children elements for quicker access.\n\n    var cache = this._V; // vectorized markup;\n\n    for (var i = 0, n = children.length; i < n; i++) {\n      var child = children[i];\n      var className = child.attr('class');\n\n      if (className) {\n        // Strip the joint class name prefix, if there is one.\n        className = removeClassNamePrefix(className);\n        cache[$.camelCase(className)] = child;\n      }\n    } // partial rendering\n\n\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    this.vel.append(children);\n  },\n  _getLabelMarkup: function (labelMarkup) {\n    if (!labelMarkup) return undefined;\n    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n    throw new Error('dia.linkView: invalid label markup');\n  },\n  _getLabelStringMarkup: function (labelMarkup) {\n    var children = V(labelMarkup);\n    var fragment = document.createDocumentFragment();\n\n    if (!Array.isArray(children)) {\n      fragment.appendChild(children.node);\n    } else {\n      for (var i = 0, n = children.length; i < n; i++) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n    }\n\n    return {\n      fragment: fragment,\n      selectors: {}\n    }; // no selectors\n  },\n  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n  // If it doesn't, add the <g /> container here.\n  _normalizeLabelMarkup: function (markup) {\n    if (!markup) return undefined;\n    var fragment = markup.fragment;\n    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n    var vNode;\n    var childNodes = fragment.childNodes;\n\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in <g />\n      // add a <g /> container\n      vNode = V('g').append(fragment);\n    } else {\n      vNode = V(childNodes[0]);\n    }\n\n    vNode.addClass('label');\n    return {\n      node: vNode.node,\n      selectors: markup.selectors\n    };\n  },\n  renderLabels: function () {\n    var cache = this._V;\n    var vLabels = cache.labels;\n    var labelCache = this._labelCache = {};\n    var labelSelectors = this._labelSelectors = {};\n    var model = this.model;\n    var labels = model.attributes.labels || [];\n    var labelsCount = labels.length;\n\n    if (labelsCount === 0) {\n      if (vLabels) vLabels.remove();\n      return this;\n    }\n\n    if (vLabels) {\n      vLabels.empty();\n    } else {\n      // there is no label container in the markup but some labels are defined\n      // add a <g class=\"labels\" /> container\n      vLabels = cache.labels = V('g').addClass('labels');\n    }\n\n    var container = vLabels.node;\n\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n\n      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n\n      var labelNode;\n      var selectors;\n\n      if (labelMarkup) {\n        labelNode = labelMarkup.node;\n        selectors = labelMarkup.selectors;\n      } else {\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n\n        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n\n        var defaultLabel = model._getDefaultLabel();\n\n        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n\n        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n        labelNode = defaultMarkup.node;\n        selectors = defaultMarkup.selectors;\n      }\n\n      labelNode.setAttribute('label-idx', i); // assign label-idx\n\n      container.appendChild(labelNode);\n      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n      selectors[rootSelector] = labelNode;\n      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n    }\n\n    if (!container.parentNode) {\n      this.el.appendChild(container);\n    }\n\n    this.updateLabels();\n    return this;\n  },\n  findLabelNode: function (labelIndex, selector) {\n    const labelRoot = this._labelCache[labelIndex];\n    if (!labelRoot) return null;\n    const labelSelectors = this._labelSelectors[labelIndex];\n    const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n    return node;\n  },\n  // merge default label attrs into label attrs\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n    if (labelAttrs === null) return null;\n\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) return null;\n\n      if (defaultLabelAttrs === undefined) {\n        if (hasCustomMarkup) return undefined;\n        return builtinDefaultLabelAttrs;\n      }\n\n      if (hasCustomMarkup) return defaultLabelAttrs;\n      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n    }\n\n    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n  },\n  updateLabels: function () {\n    if (!this._V.labels) return this;\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    var canLabelMove = this.can('labelMove');\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n    var defaultLabel = model._getDefaultLabel();\n\n    var defaultLabelMarkup = defaultLabel.markup;\n    var defaultLabelAttrs = defaultLabel.attrs;\n\n    for (var i = 0, n = labels.length; i < n; i++) {\n      var labelNode = this._labelCache[i];\n      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n      var selectors = this._labelSelectors[i];\n      var label = labels[i];\n      var labelMarkup = label.markup;\n      var labelAttrs = label.attrs;\n\n      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n\n      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n        rootBBox: new Rect(label.size),\n        selectors: selectors\n      });\n    }\n\n    return this;\n  },\n  renderTools: function () {\n    if (!this._V.linkTools) return this; // Tools are a group of clickable elements that manipulate the whole link.\n    // A good example of this is the remove tool that removes the whole link.\n    // Tools appear after hovering the link close to the `source` element/point of the link\n    // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n    var $tools = $(this._V.linkTools.node).empty();\n    var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n    var tool = V(toolTemplate());\n    $tools.append(tool.node); // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n\n    this._toolCache = tool; // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n    // link as well but only if the link is longer than `longLinkLength`.\n\n    if (this.options.doubleLinkTools) {\n      var tool2;\n\n      if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n        toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n        tool2 = V(toolTemplate());\n      } else {\n        tool2 = tool.clone();\n      }\n\n      $tools.append(tool2.node);\n      this._tool2Cache = tool2;\n    }\n\n    return this;\n  },\n  renderVertexMarkers: function () {\n    if (!this._V.markerVertices) return this;\n    var $markerVertices = $(this._V.markerVertices.node).empty(); // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\n    var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n    this.model.vertices().forEach(function (vertex, idx) {\n      $markerVertices.append(V(markupTemplate(assign({\n        idx: idx\n      }, vertex))).node);\n    });\n    return this;\n  },\n  renderArrowheadMarkers: function () {\n    // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n    if (!this._V.markerArrowheads) return this;\n    var $markerArrowheads = $(this._V.markerArrowheads.node);\n    $markerArrowheads.empty(); // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n    // if default styling (elements) are not desired. This makes it possible to use any\n    // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n\n    var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n    this._V.sourceArrowhead = V(markupTemplate({\n      end: 'source'\n    }));\n    this._V.targetArrowhead = V(markupTemplate({\n      end: 'target'\n    }));\n    $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n    return this;\n  },\n  // Updating.\n  // ---------\n  // Default is to process the `attrs` object and set attributes on subelements based on the selectors.\n  update: function (model, attributes, opt) {\n    opt || (opt = {});\n    this.cleanNodesCache(); // update the link path\n\n    this.updateConnection(opt); // update SVG attributes defined by 'attrs/'.\n\n    this.updateDOMSubtreeAttributes(this.el, this.model.attr(), {\n      selectors: this.selectors\n    });\n    this.updateDefaultConnectionPath(); // update the label position etc.\n\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers(); // *Deprecated*\n    // Local perpendicular flag (as opposed to one defined on paper).\n    // Could be enabled inside a connector/router. It's valid only\n    // during the update execution.\n\n    this.options.perpendicular = null;\n    return this;\n  },\n  // remove vertices that lie on (or nearly on) straight lines within the link\n  // return the number of removed points\n  removeRedundantLinearVertices: function (opt) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.model;\n    const vertices = link.vertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const numRoutePoints = routePoints.length; // put routePoints into a polyline and try to simplify\n\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: SIMPLIFY_THRESHOLD\n    });\n    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n\n    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n    // shortcut if simplification did not remove any redundant vertices:\n\n    if (numRoutePoints === numPolylinePoints) return 0; // else: set simplified polyline points as link vertices\n    // remove first and last polyline points again (= source/target anchors)\n\n    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n    return numRoutePoints - numPolylinePoints;\n  },\n  updateDefaultConnectionPath: function () {\n    var cache = this._V;\n\n    if (cache.connection) {\n      cache.connection.attr('d', this.getSerializedConnection());\n    }\n\n    if (cache.connectionWrap) {\n      cache.connectionWrap.attr('d', this.getSerializedConnection());\n    }\n\n    if (cache.markerSource && cache.markerTarget) {\n      this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n    }\n  },\n  getEndView: function (type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n\n      case 'target':\n        return this.targetView || null;\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndAnchor: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourceAnchor);\n\n      case 'target':\n        return new Point(this.targetAnchor);\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndConnectionPoint: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourcePoint);\n\n      case 'target':\n        return new Point(this.targetPoint);\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndMagnet: function (type) {\n    switch (type) {\n      case 'source':\n        var sourceView = this.sourceView;\n        if (!sourceView) break;\n        return this.sourceMagnet || sourceView.el;\n\n      case 'target':\n        var targetView = this.targetView;\n        if (!targetView) break;\n        return this.targetMagnet || targetView.el;\n\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n\n    return null;\n  },\n  updateConnection: function (opt) {\n    opt = opt || {};\n    var model = this.model;\n    var route, path;\n\n    if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n      // The link is being translated by an ancestor that will\n      // shift source point, target point and all vertices\n      // by an equal distance.\n      var tx = opt.tx || 0;\n      var ty = opt.ty || 0;\n      route = new Polyline(this.route).translate(tx, ty).points; // translate source and target connection and marker points.\n\n      this._translateConnectionPoints(tx, ty); // translate the path itself\n\n\n      path = this.path;\n      path.translate(tx, ty);\n    } else {\n      var vertices = model.vertices(); // 1. Find Anchors\n\n      var anchors = this.findAnchors(vertices);\n      var sourceAnchor = this.sourceAnchor = anchors.source;\n      var targetAnchor = this.targetAnchor = anchors.target; // 2. Find Route\n\n      route = this.findRoute(vertices, opt); // 3. Find Connection Points\n\n      var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n      var sourcePoint = this.sourcePoint = connectionPoints.source;\n      var targetPoint = this.targetPoint = connectionPoints.target; // 3b. Find Marker Connection Point - Backwards Compatibility\n\n      var markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint); // 4. Find Connection\n\n      path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n    }\n\n    this.route = route;\n    this.path = path;\n    this.metrics = {};\n  },\n  findMarkerPoints: function (route, sourcePoint, targetPoint) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1]; // Move the source point by the width of the marker taking into account\n    // its scale around x-axis. Note that scale is the only transform that\n    // makes sense to be set in `.marker-source` attributes object\n    // as all other transforms (translate/rotate) will be replaced\n    // by the `translateAndAutoOrient()` function.\n\n    var cache = this._markerCache; // cache source and target points\n\n    var sourceMarkerPoint, targetMarkerPoint;\n\n    if (this._V.markerSource) {\n      cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n      sourceMarkerPoint = Point(sourcePoint).move(firstWaypoint || targetPoint, cache.sourceBBox.width * this._V.markerSource.scale().sx * -1).round();\n    }\n\n    if (this._V.markerTarget) {\n      cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n      targetMarkerPoint = Point(targetPoint).move(lastWaypoint || sourcePoint, cache.targetBBox.width * this._V.markerTarget.scale().sx * -1).round();\n    } // if there was no markup for the marker, use the connection point.\n\n\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  },\n  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n    var firstAnchor, secondAnchor;\n    var firstAnchorRef, secondAnchorRef;\n    var model = this.model;\n    var firstDef = model.get(firstEndType);\n    var secondDef = model.get(secondEndType);\n    var firstView = this.getEndView(firstEndType);\n    var secondView = this.getEndView(secondEndType);\n    var firstMagnet = this.getEndMagnet(firstEndType);\n    var secondMagnet = this.getEndMagnet(secondEndType); // Anchor first\n\n    if (firstView) {\n      if (firstRef) {\n        firstAnchorRef = new Point(firstRef);\n      } else if (secondView) {\n        firstAnchorRef = secondMagnet;\n      } else {\n        firstAnchorRef = new Point(secondDef);\n      }\n\n      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n    } else {\n      firstAnchor = new Point(firstDef);\n    } // Anchor second\n\n\n    if (secondView) {\n      secondAnchorRef = new Point(secondRef || firstAnchor);\n      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n    } else {\n      secondAnchor = new Point(secondDef);\n    }\n\n    var res = {};\n    res[firstEndType] = firstAnchor;\n    res[secondEndType] = secondAnchor;\n    return res;\n  },\n  findAnchors: function (vertices) {\n    var model = this.model;\n    var firstVertex = vertices[0];\n    var lastVertex = vertices[vertices.length - 1];\n\n    if (model.target().priority && !model.source().priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    } // Usual order\n\n\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  },\n  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1];\n    var model = this.model;\n    var sourceDef = model.get('source');\n    var targetDef = model.get('target');\n    var sourceView = this.sourceView;\n    var targetView = this.targetView;\n    var paperOptions = this.paper.options;\n    var sourceMagnet, targetMagnet; // Connection Point Source\n\n    var sourcePoint;\n\n    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n      sourceMagnet = this.sourceMagnet || sourceView.el;\n      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var sourcePointRef = firstWaypoint || targetAnchor;\n      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    } // Connection Point Target\n\n\n    var targetPoint;\n\n    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n      targetMagnet = this.targetMagnet || targetView.el;\n      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var targetPointRef = lastWaypoint || sourceAnchor;\n      var targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  },\n  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n    var isConnection = cellView.isNodeConnection(magnet);\n    var paperOptions = this.paper.options;\n\n    if (!anchorDef) {\n      if (isConnection) {\n        anchorDef = paperOptions.defaultLinkAnchor;\n      } else {\n        if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n          // Backwards compatibility\n          // If `perpendicularLinks` flag is set on the paper and there are vertices\n          // on the link, then try to find a connection point that makes the link perpendicular\n          // even though the link won't point to the center of the targeted object.\n          anchorDef = {\n            name: 'perpendicular'\n          };\n        } else {\n          anchorDef = paperOptions.defaultAnchor;\n        }\n      }\n    }\n\n    if (!anchorDef) throw new Error('Anchor required.');\n    var anchorFn;\n\n    if (typeof anchorDef === 'function') {\n      anchorFn = anchorDef;\n    } else {\n      var anchorName = anchorDef.name;\n      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n      anchorFn = paperOptions[anchorNamespace][anchorName];\n      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n    }\n\n    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n    if (!anchor) return new Point();\n    return anchor.round(this.decimalsRounding);\n  },\n  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n    var connectionPoint;\n    var anchor = line.end;\n    var paperOptions = this.paper.options; // Backwards compatibility\n\n    if (typeof paperOptions.linkConnectionPoint === 'function') {\n      var linkConnectionMagnet = magnet === view.el ? undefined : magnet;\n      connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n      if (connectionPoint) return connectionPoint;\n    }\n\n    if (!connectionPointDef) return anchor;\n    var connectionPointFn;\n\n    if (typeof connectionPointDef === 'function') {\n      connectionPointFn = connectionPointDef;\n    } else {\n      var connectionPointName = connectionPointDef.name;\n      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n    }\n\n    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n    if (!connectionPoint) return anchor;\n    return connectionPoint.round(this.decimalsRounding);\n  },\n  _translateConnectionPoints: function (tx, ty) {\n    var cache = this._markerCache;\n    cache.sourcePoint.offset(tx, ty);\n    cache.targetPoint.offset(tx, ty);\n    this.sourcePoint.offset(tx, ty);\n    this.targetPoint.offset(tx, ty);\n    this.sourceAnchor.offset(tx, ty);\n    this.targetAnchor.offset(tx, ty);\n  },\n  // if label position is a number, normalize it to a position object\n  // this makes sure that label positions can be merged properly\n  _normalizeLabelPosition: function (labelPosition) {\n    if (typeof labelPosition === 'number') return {\n      distance: labelPosition,\n      offset: null,\n      angle: 0,\n      args: null\n    };\n    return labelPosition;\n  },\n  updateLabelPositions: function () {\n    if (!this._V.labels) return this;\n    var path = this.path;\n    if (!path) return this; // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    if (!labels.length) return this;\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n    var defaultLabel = model._getDefaultLabel();\n\n    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n    var defaultPosition = merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\n    for (var idx = 0, n = labels.length; idx < n; idx++) {\n      var labelNode = this._labelCache[idx];\n      if (!labelNode) continue;\n      var label = labels[idx];\n\n      var labelPosition = this._normalizeLabelPosition(label.position);\n\n      var position = merge({}, defaultPosition, labelPosition);\n\n      var transformationMatrix = this._getLabelTransformationMatrix(position);\n\n      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n\n      this._cleanLabelMatrices(idx);\n    }\n\n    return this;\n  },\n  _cleanLabelMatrices: function (index) {\n    // Clean magnetMatrix for all nodes of the label.\n    // Cached BoundingRect does not need to updated when the position changes\n    // TODO: this doesn't work for labels with XML String markups.\n    const {\n      metrics,\n      _labelSelectors\n    } = this;\n    const selectors = _labelSelectors[index];\n    if (!selectors) return;\n\n    for (let selector in selectors) {\n      const {\n        id\n      } = selectors[selector];\n      if (id && id in metrics) delete metrics[id].magnetMatrix;\n    }\n  },\n  updateToolsPosition: function () {\n    if (!this._V.linkTools) return this; // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n    // Note that the offset is hardcoded here. The offset should be always\n    // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n    var scale = '';\n    var offset = this.options.linkToolsOffset;\n    var connectionLength = this.getConnectionLength(); // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n\n    if (!Number.isNaN(connectionLength)) {\n      // If the link is too short, make the tools half the size and the offset twice as low.\n      if (connectionLength < this.options.shortLinkLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n\n      var toolPosition = this.getPointAtLength(offset);\n\n      this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n      if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n        var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n        toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n\n        this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n        this._tool2Cache.attr('visibility', 'visible');\n      } else if (this.options.doubleLinkTools) {\n        this._tool2Cache.attr('visibility', 'hidden');\n      }\n    }\n\n    return this;\n  },\n  updateArrowheadMarkers: function () {\n    if (!this._V.markerArrowheads) return this; // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n\n    if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n    var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n\n    this._V.sourceArrowhead.scale(sx);\n\n    this._V.targetArrowhead.scale(sx);\n\n    this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n    return this;\n  },\n  updateEndProperties: function (endType) {\n    const {\n      model,\n      paper\n    } = this;\n    const endViewProperty = `${endType}View`;\n    const endDef = model.get(endType);\n    const endId = endDef && endDef.id;\n\n    if (!endId) {\n      // the link end is a point ~ rect 0x0\n      this[endViewProperty] = null;\n      this.updateEndMagnet(endType);\n      return true;\n    }\n\n    const endModel = paper.getModelById(endId);\n    if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n    const endView = endModel.findView(paper);\n\n    if (!endView) {\n      // A view for a model should always exist\n      return false;\n    }\n\n    this[endViewProperty] = endView;\n    this.updateEndMagnet(endType);\n    return true;\n  },\n  updateEndMagnet: function (endType) {\n    const endMagnetProperty = `${endType}Magnet`;\n    const endView = this.getEndView(endType);\n\n    if (endView) {\n      let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n      if (connectedMagnet === endView.el) connectedMagnet = null;\n      this[endMagnetProperty] = connectedMagnet;\n    } else {\n      this[endMagnetProperty] = null;\n    }\n  },\n  _translateAndAutoOrientArrows: function (sourceArrow, targetArrow) {\n    // Make the markers \"point\" to their sticky points being auto-oriented towards\n    // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n    var route = toArray(this.route);\n\n    if (sourceArrow) {\n      sourceArrow.translateAndAutoOrient(this.sourcePoint, route[0] || this.targetPoint, this.paper.cells);\n    }\n\n    if (targetArrow) {\n      targetArrow.translateAndAutoOrient(this.targetPoint, route[route.length - 1] || this.sourcePoint, this.paper.cells);\n    }\n  },\n  _getLabelPositionAngle: function (idx) {\n    var labelPosition = this.model.label(idx).position || {};\n    return labelPosition.angle || 0;\n  },\n  _getLabelPositionArgs: function (idx) {\n    var labelPosition = this.model.label(idx).position || {};\n    return labelPosition.args;\n  },\n  _getDefaultLabelPositionArgs: function () {\n    var defaultLabel = this.model._getDefaultLabel();\n\n    var defaultLabelPosition = defaultLabel.position || {};\n    return defaultLabelPosition.args;\n  },\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) return null;\n\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) return null;\n      return defaultLabelPositionArgs;\n    }\n\n    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  },\n  // Add default label at given position at end of `labels` array.\n  // Four signatures:\n  // - obj, obj = point, opt\n  // - obj, num, obj = point, angle, opt\n  // - num, num, obj = x, y, opt\n  // - num, num, num, obj = x, y, angle, opt\n  // Assigns relative coordinates by default:\n  // `opt.absoluteDistance` forces absolute coordinates.\n  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n  // `opt.absoluteOffset` forces absolute coordinates for offset.\n  // Additional args:\n  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n  addLabel: function (p1, p2, p3, p4) {\n    // normalize data from the four possible signatures\n    var localX;\n    var localY;\n    var localAngle = 0;\n    var localOpt;\n\n    if (typeof p1 !== 'number') {\n      // {x, y} object provided as first parameter\n      localX = p1.x;\n      localY = p1.y;\n\n      if (typeof p2 === 'number') {\n        // angle and opt provided as second and third parameters\n        localAngle = p2;\n        localOpt = p3;\n      } else {\n        // opt provided as second parameter\n        localOpt = p2;\n      }\n    } else {\n      // x and y provided as first and second parameters\n      localX = p1;\n      localY = p2;\n\n      if (typeof p3 === 'number') {\n        // angle and opt provided as third and fourth parameters\n        localAngle = p3;\n        localOpt = p4;\n      } else {\n        // opt provided as third parameter\n        localOpt = p3;\n      }\n    } // merge label position arguments\n\n\n    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\n    var labelPositionArgs = localOpt;\n\n    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n\n    var label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    var idx = -1;\n    this.model.insertLabel(idx, label, localOpt);\n    return idx;\n  },\n  // Add a new vertex at calculated index to the `vertices` array.\n  addVertex: function (x, y, opt) {\n    // accept input in form `{ x, y }, opt` or `x, y, opt`\n    var isPointProvided = typeof x !== 'number';\n    var localX = isPointProvided ? x.x : x;\n    var localY = isPointProvided ? x.y : y;\n    var localOpt = isPointProvided ? y : opt;\n    var vertex = {\n      x: localX,\n      y: localY\n    };\n    var idx = this.getVertexIndex(localX, localY);\n    this.model.insertVertex(idx, vertex, localOpt);\n    return idx;\n  },\n  // Send a token (an SVG element, usually a circle) along the connection path.\n  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n  // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n  // `opt.connection` is an optional selector to the connection path.\n  // `callback` is optional and is a function to be called once the token reaches the target.\n  sendToken: function (token, opt, callback) {\n    function onAnimationEnd(vToken, callback) {\n      return function () {\n        vToken.remove();\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n    }\n\n    var duration, isReversed, selector;\n\n    if (isObject(opt)) {\n      duration = opt.duration;\n      isReversed = opt.direction === 'reverse';\n      selector = opt.connection;\n    } else {\n      // Backwards compatibility\n      duration = opt;\n      isReversed = false;\n      selector = null;\n    }\n\n    duration = duration || 1000;\n    var animationAttributes = {\n      dur: duration + 'ms',\n      repeatCount: 1,\n      calcMode: 'linear',\n      fill: 'freeze'\n    };\n\n    if (isReversed) {\n      animationAttributes.keyPoints = '1;0';\n      animationAttributes.keyTimes = '0;1';\n    }\n\n    var vToken = V(token);\n    var connection;\n\n    if (typeof selector === 'string') {\n      // Use custom connection path.\n      connection = this.findBySelector(selector, this.el, this.selectors)[0];\n    } else {\n      // Select connection path automatically.\n      var cache = this._V;\n      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n    }\n\n    if (!(connection instanceof SVGPathElement)) {\n      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n    }\n\n    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n    setTimeout(onAnimationEnd(vToken, callback), duration);\n  },\n  findRoute: function (vertices) {\n    vertices || (vertices = []);\n    var namespace = routers;\n    var router = this.model.router();\n    var defaultRouter = this.paper.options.defaultRouter;\n\n    if (!router) {\n      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n    }\n\n    var routerFn = isFunction(router) ? router : namespace[router.name];\n\n    if (!isFunction(routerFn)) {\n      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n    }\n\n    var args = router.args || {};\n    var route = routerFn.call(this, // context\n    vertices, // vertices\n    args, // options\n    this // linkView\n    );\n    if (!route) return vertices.map(Point);\n    return route;\n  },\n  // Return the `d` attribute value of the `<path>` element representing the link\n  // between `source` and `target`.\n  findPath: function (route, sourcePoint, targetPoint) {\n    var namespace = connectors;\n    var connector = this.model.connector();\n    var defaultConnector = this.paper.options.defaultConnector;\n\n    if (!connector) {\n      connector = defaultConnector || {};\n    }\n\n    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n\n    if (!isFunction(connectorFn)) {\n      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n    }\n\n    var args = clone(connector.args || {});\n    args.raw = true; // Request raw g.Path as the result.\n\n    var path = connectorFn.call(this, // context\n    sourcePoint, // start point\n    targetPoint, // end point\n    route, // vertices\n    args, // options\n    this // linkView\n    );\n\n    if (typeof path === 'string') {\n      // Backwards compatibility for connectors not supporting `raw` option.\n      path = new Path(V.normalizePathData(path));\n    }\n\n    return path;\n  },\n  // Public API.\n  // -----------\n  getConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    return path.clone();\n  },\n  getSerializedConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('data')) return metrics.data;\n    var data = path.serialize();\n    metrics.data = data;\n    return data;\n  },\n  getConnectionSubdivisions: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n    var subdivisions = path.getSegmentSubdivisions();\n    metrics.segmentSubdivisions = subdivisions;\n    return subdivisions;\n  },\n  getConnectionLength: function () {\n    var path = this.path;\n    if (!path) return 0;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('length')) return metrics.length;\n    var length = path.length({\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n    metrics.length = length;\n    return length;\n  },\n  getPointAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getPointAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n    return path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPoint: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointLength: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointRatio: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  // Get label position object based on two provided coordinates, x and y.\n  // (Used behind the scenes when user moves labels around.)\n  // Two signatures:\n  // - num, num, obj = x, y, options\n  // - num, num, num, obj = x, y, angle, options\n  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n  getLabelPosition: function (x, y, p3, p4) {\n    var position = {}; // normalize data from the two possible signatures\n\n    var localAngle = 0;\n    var localOpt;\n\n    if (typeof p3 === 'number') {\n      // angle and opt provided as third and fourth argument\n      localAngle = p3;\n      localOpt = p4;\n    } else {\n      // opt provided as third argument\n      localOpt = p3;\n    } // save localOpt as `args` of the position object that is passed along\n\n\n    if (localOpt) position.args = localOpt; // identify distance/offset settings\n\n    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n\n    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n\n    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n    // find closest point t\n\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var labelPoint = new Point(x, y);\n    var t = path.closestPointT(labelPoint, pathOpt); // DISTANCE:\n\n    var labelDistance = path.lengthAtT(t, pathOpt);\n    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n\n    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n\n    position.distance = labelDistance; // OFFSET:\n    // use absolute offset if:\n    // - opt.absoluteOffset is true,\n    // - opt.absoluteOffset is not true but there is no tangent\n\n    var tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    var labelOffset;\n\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      var closestPoint = path.pointAtT(t);\n      var labelOffsetDiff = labelPoint.difference(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n\n    position.offset = labelOffset; // ANGLE:\n\n    position.angle = localAngle;\n    return position;\n  },\n  _getLabelTransformationMatrix: function (labelPosition) {\n    var labelDistance;\n    var labelAngle = 0;\n    var args = {};\n\n    if (typeof labelPosition === 'number') {\n      labelDistance = labelPosition;\n    } else if (typeof labelPosition.distance === 'number') {\n      args = labelPosition.args || {};\n      labelDistance = labelPosition.distance;\n      labelAngle = labelPosition.angle || 0;\n    } else {\n      throw new Error('dia.LinkView: invalid label position distance.');\n    }\n\n    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    var labelOffset = 0;\n    var labelOffsetCoordinates = {\n      x: 0,\n      y: 0\n    };\n\n    if (labelPosition.offset) {\n      var positionOffset = labelPosition.offset;\n      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n    }\n\n    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n    var isKeepGradient = args.keepGradient;\n    var isEnsureLegibility = args.ensureLegibility;\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    var tangent = path.tangentAtLength(distance, pathOpt);\n    var translation;\n    var angle = labelAngle;\n\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.offset(labelOffsetCoordinates);\n      } else {\n        var normal = tangent.clone();\n        normal.rotate(tangent.start, -90);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n\n        if (isEnsureLegibility) {\n          angle = normalizeAngle((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n    }\n\n    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  },\n  getLabelCoordinates: function (labelPosition) {\n    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n\n    return new Point(transformationMatrix.e, transformationMatrix.f);\n  },\n  getVertexIndex: function (x, y) {\n    var model = this.model;\n    var vertices = model.vertices();\n    var vertexLength = this.getClosestPointLength(new Point(x, y));\n    var idx = 0;\n\n    for (var n = vertices.length; idx < n; idx++) {\n      var currentVertex = vertices[idx];\n      var currentVertexLength = this.getClosestPointLength(currentVertex);\n      if (vertexLength < currentVertexLength) break;\n    }\n\n    return idx;\n  },\n\n  // Interaction. The controller part.\n  // ---------------------------------\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('link:pointerdown', evt, x, y);\n  },\n\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('link:pointermove', evt, x, y);\n  },\n\n  notifyPointerup(evt, x, y) {\n    this.notify('link:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('link:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('link:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('link:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y); // Backwards compatibility for the default markup\n\n    var className = evt.target.getAttribute('class');\n\n    switch (className) {\n      case 'marker-vertex':\n        this.dragVertexStart(evt, x, y);\n        return;\n\n      case 'marker-vertex-remove':\n      case 'marker-vertex-remove-area':\n        this.dragVertexRemoveStart(evt, x, y);\n        return;\n\n      case 'marker-arrowhead':\n        this.dragArrowheadStart(evt, x, y);\n        return;\n\n      case 'connection':\n      case 'connection-wrap':\n        this.dragConnectionStart(evt, x, y);\n        return;\n\n      case 'marker-source':\n      case 'marker-target':\n        return;\n    }\n\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) this.eventData(evt, dragData);\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertex(evt, x, y);\n        break;\n\n      case 'label-move':\n        this.dragLabel(evt, x, y);\n        break;\n\n      case 'arrowhead-move':\n        this.dragArrowhead(evt, x, y);\n        break;\n\n      case 'move':\n        this.drag(evt, x, y);\n        break;\n    } // Backwards compatibility\n\n\n    if (dragData) assign(dragData, this.eventData(evt));\n    this.notifyPointermove(evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n\n    if (dragData) {\n      this.eventData(evt, dragData);\n      this._dragData = null;\n    }\n\n    var data = this.eventData(evt);\n\n    switch (data.action) {\n      case 'vertex-move':\n        this.dragVertexEnd(evt, x, y);\n        break;\n\n      case 'label-move':\n        this.dragLabelEnd(evt, x, y);\n        break;\n\n      case 'arrowhead-move':\n        this.dragArrowheadEnd(evt, x, y);\n        break;\n\n      case 'move':\n        this.dragEnd(evt, x, y);\n    }\n\n    this.notifyPointerup(evt, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('link:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('link:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('link:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('link:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('link:mousewheel', evt, x, y, delta);\n  },\n  onevent: function (evt, eventName, x, y) {\n    // Backwards compatibility\n    var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n\n    if (linkTool) {\n      // No further action to be executed\n      evt.stopPropagation(); // Allow `interactive.useLinkTools=false`\n\n      if (this.can('useLinkTools')) {\n        if (eventName === 'remove') {\n          // Built-in remove event\n          this.model.remove({\n            ui: true\n          }); // Do not trigger link pointerdown\n\n          return;\n        } else {\n          // link:options and other custom events inside the link tools\n          this.notify(eventName, evt, x, y);\n        }\n      }\n\n      this.notifyPointerdown(evt, x, y);\n      this.paper.delegateDragEvents(this, evt.data);\n    } else {\n      CellView.prototype.onevent.apply(this, arguments);\n    }\n  },\n  onlabel: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragLabelStart(evt, x, y);\n    var stopPropagation = this.eventData(evt).stopPropagation;\n    if (stopPropagation) evt.stopPropagation();\n  },\n  // Drag Start Handlers\n  dragConnectionStart: function (evt, x, y) {\n    if (!this.can('vertexAdd')) return; // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n\n    var vertexIdx = this.addVertex({\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragLabelStart: function (evt, _x, _y) {\n    if (this.can('labelMove')) {\n      var labelNode = evt.currentTarget;\n      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n      var positionAngle = this._getLabelPositionAngle(labelIdx);\n\n      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n\n      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n\n      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n      this.eventData(evt, {\n        action: 'label-move',\n        labelIdx: labelIdx,\n        positionAngle: positionAngle,\n        positionArgs: positionArgs,\n        stopPropagation: true\n      });\n    } else {\n      // Backwards compatibility:\n      // If labels can't be dragged no default action is triggered.\n      this.eventData(evt, {\n        stopPropagation: true\n      });\n    }\n\n    this.paper.delegateDragEvents(this, evt.data);\n  },\n  dragVertexStart: function (evt, x, y) {\n    if (!this.can('vertexMove')) return;\n    var vertexNode = evt.target;\n    var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n    this.eventData(evt, {\n      action: 'vertex-move',\n      vertexIdx: vertexIdx\n    });\n  },\n  dragVertexRemoveStart: function (evt, x, y) {\n    if (!this.can('vertexRemove')) return;\n    var removeNode = evt.target;\n    var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n    this.model.removeVertex(vertexIdx);\n  },\n  dragArrowheadStart: function (evt, x, y) {\n    if (!this.can('arrowheadMove')) return;\n    var arrowheadNode = evt.target;\n    var arrowheadType = arrowheadNode.getAttribute('end');\n    var data = this.startArrowheadMove(arrowheadType, {\n      ignoreBackwardsCompatibility: true\n    });\n    this.eventData(evt, data);\n  },\n  dragStart: function (evt, x, y) {\n    if (!this.can('linkMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag Handlers\n  dragLabel: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var label = {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    };\n    if (this.paper.options.snapLabels) delete label.position.offset;\n    this.model.label(data.labelIdx, label);\n  },\n  dragVertex: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.vertex(data.vertexIdx, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  dragArrowhead: function (evt, x, y) {\n    if (this.paper.options.snapLinks) {\n      this._snapArrowhead(evt, x, y);\n    } else {\n      this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n    }\n  },\n  drag: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.translate(x - data.dx, y - data.dy, {\n      ui: true\n    });\n    this.eventData(evt, {\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag End Handlers\n  dragLabelEnd: function () {// noop\n  },\n  dragVertexEnd: function () {// noop\n  },\n  dragArrowheadEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var paper = this.paper;\n\n    if (paper.options.snapLinks) {\n      this._snapArrowheadEnd(data);\n    } else {\n      this._connectArrowheadEnd(data, x, y);\n    }\n\n    if (!paper.linkAllowed(this)) {\n      // If the changed link is not allowed, revert to its previous state.\n      this._disallow(data);\n    } else {\n      this._finishEmbedding(data);\n\n      this._notifyConnectEvent(data, evt);\n    }\n\n    this._afterArrowheadMove(data);\n  },\n  dragEnd: function () {// noop\n  },\n  _disallow: function (data) {\n    switch (data.whenNotAllowed) {\n      case 'remove':\n        this.model.remove({\n          ui: true\n        });\n        break;\n\n      case 'revert':\n      default:\n        this.model.set(data.arrowhead, data.initialEnd, {\n          ui: true\n        });\n        break;\n    }\n  },\n  _finishEmbedding: function (data) {\n    // Reparent the link if embedding is enabled\n    if (this.paper.options.embeddingMode && this.model.reparent()) {\n      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n      data.z = null;\n    }\n  },\n  _notifyConnectEvent: function (data, evt) {\n    var arrowhead = data.arrowhead;\n    var initialEnd = data.initialEnd;\n    var currentEnd = this.model.prop(arrowhead);\n    var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n\n    if (endChanged) {\n      var paper = this.paper;\n\n      if (initialEnd.id) {\n        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n      }\n\n      if (currentEnd.id) {\n        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n      }\n    }\n  },\n  _snapArrowhead: function (evt, x, y) {\n    const data = this.eventData(evt); // checking view in close area of the pointer\n\n    var r = this.paper.options.snapLinks.radius || 50;\n    var viewsInArea = this.paper.findViewsInArea({\n      x: x - r,\n      y: y - r,\n      width: 2 * r,\n      height: 2 * r\n    });\n    var prevClosestView = data.closestView || null;\n    var prevClosestMagnet = data.closestMagnet || null;\n    var prevMagnetProxy = data.magnetProxy || null;\n    data.closestView = data.closestMagnet = data.magnetProxy = null;\n    var minDistance = Number.MAX_VALUE;\n    var pointer = new Point(x, y);\n    var paper = this.paper;\n    viewsInArea.forEach(function (view) {\n      const candidates = []; // skip connecting to the element in case '.': { magnet: false } attribute present\n\n      if (view.el.getAttribute('magnet') !== 'false') {\n        candidates.push({\n          bbox: view.model.getBBox(),\n          magnet: view.el\n        });\n      }\n\n      view.$('[magnet]').toArray().forEach(magnet => {\n        candidates.push({\n          bbox: view.getNodeBBox(magnet),\n          magnet\n        });\n      });\n      candidates.forEach(candidate => {\n        const {\n          magnet,\n          bbox\n        } = candidate; // find distance from the center of the model to pointer coordinates\n\n        const distance = bbox.center().squaredDistance(pointer); // the connection is looked up in a circle area by `distance < r`\n\n        if (distance < minDistance) {\n          const isAlreadyValidated = prevClosestMagnet === magnet;\n\n          if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = magnet;\n          }\n        }\n      });\n    }, this);\n    var end;\n    var magnetProxy = null;\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n\n    if (closestMagnet) {\n      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n    }\n\n    var endType = data.arrowhead;\n    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n\n    if (prevClosestView && newClosestMagnet) {\n      prevClosestView.unhighlight(prevMagnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n    }\n\n    if (closestView) {\n      if (!newClosestMagnet) return;\n      closestView.highlight(magnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n    } else {\n      end = {\n        x: x,\n        y: y\n      };\n    }\n\n    this.model.set(endType, end || {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n\n    if (prevClosestView) {\n      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n    }\n\n    if (closestView) {\n      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n    }\n  },\n  _snapArrowheadEnd: function (data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(data.magnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n    }\n\n    data.closestView = data.closestMagnet = null;\n  },\n  _connectArrowhead: function (target, x, y, data) {\n    // checking views right under the pointer\n    const {\n      paper,\n      model\n    } = this;\n\n    if (data.eventTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.magnetProxy) {\n        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n          connecting: true\n        });\n      }\n\n      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n\n      if (viewUnderPointer) {\n        // If we found a view that is under the pointer, we need to find the closest\n        // magnet based on the real target element of the event.\n        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n          // If there was no magnet found, do not highlight anything and assume there\n          // is no view under pointer we're interested in reconnecting to.\n          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n          if (magnetProxy) {\n            viewUnderPointer.highlight(magnetProxy, {\n              connecting: true\n            });\n          }\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.magnetUnderPointer = null;\n          data.magnetProxy = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.magnetUnderPointer = null;\n        data.magnetProxy = null;\n      }\n    }\n\n    data.eventTarget = target;\n    model.set(data.arrowhead, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  _connectArrowheadEnd: function (data = {}, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      viewUnderPointer,\n      magnetUnderPointer,\n      magnetProxy,\n      arrowhead\n    } = data;\n    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n    viewUnderPointer.unhighlight(magnetProxy, {\n      connecting: true\n    }); // The link end is taken from the magnet under the pointer, not the proxy.\n\n    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n    model.set(arrowhead, end, {\n      ui: true\n    });\n  },\n  _beforeArrowheadMove: function (data) {\n    data.z = this.model.get('z');\n    this.model.toFront(); // Let the pointer propagate through the link view elements so that\n    // the `evt.target` is another element under the pointer, not the link itself.\n\n    var style = this.el.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n\n    if (this.paper.options.markAvailable) {\n      this._markAvailableMagnets(data);\n    }\n  },\n  _afterArrowheadMove: function (data) {\n    if (data.z !== null) {\n      this.model.set('z', data.z, {\n        ui: true\n      });\n      data.z = null;\n    } // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n\n\n    this.el.style.pointerEvents = data.pointerEvents;\n\n    if (this.paper.options.markAvailable) {\n      this._unmarkAvailableMagnets(data);\n    }\n  },\n  _createValidateConnectionArgs: function (arrowhead) {\n    // It makes sure the arguments for validateConnection have the following form:\n    // (source view, source magnet, target view, target magnet and link view)\n    var args = [];\n    args[4] = arrowhead;\n    args[5] = this;\n    var oppositeArrowhead;\n    var i = 0;\n    var j = 0;\n\n    if (arrowhead === 'source') {\n      i = 2;\n      oppositeArrowhead = 'target';\n    } else {\n      j = 2;\n      oppositeArrowhead = 'source';\n    }\n\n    var end = this.model.get(oppositeArrowhead);\n\n    if (end.id) {\n      var view = args[i] = this.paper.findViewByModel(end.id);\n      var magnet = view.getMagnetFromLinkEnd(end);\n      if (magnet === view.el) magnet = undefined;\n      args[i + 1] = magnet;\n    }\n\n    function validateConnectionArgs(cellView, magnet) {\n      args[j] = cellView;\n      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n      return args;\n    }\n\n    return validateConnectionArgs;\n  },\n  _markAvailableMagnets: function (data) {\n    function isMagnetAvailable(view, magnet) {\n      var paper = view.paper;\n      var validate = paper.options.validateConnection;\n      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n    }\n\n    var paper = this.paper;\n    var elements = paper.model.getCells();\n    data.marked = {};\n\n    for (var i = 0, n = elements.length; i < n; i++) {\n      var view = elements[i].findView(paper);\n\n      if (!view) {\n        continue;\n      }\n\n      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n\n      if (view.el.getAttribute('magnet') !== 'false') {\n        // Element wrapping group is also a magnet\n        magnets.push(view.el);\n      }\n\n      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n          view.highlight(availableMagnets[j], {\n            magnetAvailability: true\n          });\n        } // highlight the entire view\n\n\n        view.highlight(null, {\n          elementAvailability: true\n        });\n        data.marked[view.model.id] = availableMagnets;\n      }\n    }\n  },\n  _unmarkAvailableMagnets: function (data) {\n    var markedKeys = Object.keys(data.marked);\n    var id;\n    var markedMagnets;\n\n    for (var i = 0, n = markedKeys.length; i < n; i++) {\n      id = markedKeys[i];\n      markedMagnets = data.marked[id];\n      var view = this.paper.findViewByModel(id);\n\n      if (view) {\n        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n          view.unhighlight(markedMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n\n        view.unhighlight(null, {\n          elementAvailability: true\n        });\n      }\n    }\n\n    data.marked = null;\n  },\n  startArrowheadMove: function (end, opt) {\n    opt || (opt = {}); // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n    // move without need to click on the actual arrowhead dom element.\n\n    var data = {\n      action: 'arrowhead-move',\n      arrowhead: end,\n      whenNotAllowed: opt.whenNotAllowed || 'revert',\n      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n      initialEnd: clone(this.model.get(end)),\n      validateConnectionArgs: this._createValidateConnectionArgs(end)\n    };\n\n    this._beforeArrowheadMove(data);\n\n    if (opt.ignoreBackwardsCompatibility !== true) {\n      this._dragData = data;\n    }\n\n    return data;\n  }\n});\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n  enumerable: true,\n  get: function () {\n    var sourceView = this.sourceView;\n\n    if (!sourceView) {\n      var sourceDef = this.model.source();\n      return new Rect(sourceDef.x, sourceDef.y);\n    }\n\n    var sourceMagnet = this.sourceMagnet;\n\n    if (sourceView.isNodeConnection(sourceMagnet)) {\n      return new Rect(this.sourceAnchor);\n    }\n\n    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n  }\n});\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n  enumerable: true,\n  get: function () {\n    var targetView = this.targetView;\n\n    if (!targetView) {\n      var targetDef = this.model.target();\n      return new Rect(targetDef.x, targetDef.y);\n    }\n\n    var targetMagnet = this.targetMagnet;\n\n    if (targetView.isNodeConnection(targetMagnet)) {\n      return new Rect(this.targetAnchor);\n    }\n\n    return targetView.getNodeBBox(targetMagnet || targetView.el);\n  }\n});","map":{"version":3,"sources":["C:/Users/martn/Documents/New Documents 2019/Technigo codin/storymapper spreadsheet/my-app/node_modules/jointjs/src/dia/LinkView.mjs"],"names":["CellView","Link","V","removeClassNamePrefix","merge","template","assign","toArray","isObject","isFunction","clone","isPercentage","Point","Line","Path","normalizeAngle","Rect","Polyline","routers","connectors","$","LinkView","extend","className","classNames","prototype","apply","split","push","join","options","shortLinkLength","doubleLinkTools","longLinkLength","linkToolsOffset","doubleLinkToolsOffset","sampleInterval","_labelCache","_labelSelectors","_markerCache","_V","_dragData","metrics","decimalsRounding","initialize","arguments","presentationAttributes","markup","attrs","router","connector","smooth","manhattan","toolMarkup","labels","labelMarkup","vertices","vertexMarkup","source","target","initFlag","UPDATE_PRIORITY","confirmUpdate","flags","opt","hasFlag","updateEndProperties","removeFlag","paper","sourceView","targetView","isViewMounted","render","updateHighlighters","updateTools","renderVertexMarkers","model","attributes","updateLabels","updateLegacyTools","onLabelsChange","renderTools","update","updateLabelPositions","updateToolsPosition","requestConnectionUpdate","requestUpdate","getFlag","isLabelsRenderRequired","previousLabels","previous","pathArray","propertyPathArray","pathLength","length","labelExists","Object","propertyValue","_link","_labels","renderLabels","vel","empty","renderMarkup","link","get","Error","Array","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","el","selectors","append","fragment","children","cache","i","n","child","attr","camelCase","renderArrowheadMarkers","_getLabelMarkup","undefined","_getLabelStringMarkup","document","createDocumentFragment","appendChild","node","currentChild","_normalizeLabelMarkup","DocumentFragment","hasChildNodes","vNode","childNodes","nodeName","toUpperCase","addClass","vLabels","labelCache","labelSelectors","labelsCount","remove","container","label","labelNode","builtinDefaultLabel","_builtins","defaultLabel","builtinDefaultLabelMarkup","_getDefaultLabel","defaultLabelMarkup","defaultMarkup","setAttribute","rootSelector","selector","parentNode","findLabelNode","labelIndex","labelRoot","findBySelector","_mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","builtinDefaultLabelAttrs","canLabelMove","can","updateDOMSubtreeAttributes","rootBBox","size","linkTools","$tools","toolTemplate","tool","_toolCache","tool2","doubleToolMarkup","_tool2Cache","markerVertices","$markerVertices","markupTemplate","forEach","vertex","idx","markerArrowheads","$markerArrowheads","arrowheadMarkup","sourceArrowhead","end","targetArrowhead","cleanNodesCache","updateConnection","updateDefaultConnectionPath","updateArrowheadMarkers","perpendicular","removeRedundantLinearVertices","SIMPLIFY_THRESHOLD","routePoints","sourceAnchor","targetAnchor","numRoutePoints","polyline","simplify","threshold","polylinePoints","points","map","point","toJSON","numPolylinePoints","slice","connection","getSerializedConnection","connectionWrap","markerSource","markerTarget","_translateAndAutoOrientArrows","getEndView","type","getEndAnchor","getEndConnectionPoint","sourcePoint","targetPoint","getEndMagnet","sourceMagnet","targetMagnet","route","path","translateBy","isRelationshipEmbeddedIn","tx","ty","translate","_translateConnectionPoints","anchors","findAnchors","findRoute","connectionPoints","findConnectionPoints","markerPoints","findMarkerPoints","findPath","firstWaypoint","lastWaypoint","sourceMarkerPoint","targetMarkerPoint","sourceBBox","getBBox","move","width","scale","sx","round","targetBBox","findAnchorsOrdered","firstEndType","firstRef","secondEndType","secondRef","firstAnchor","secondAnchor","firstAnchorRef","secondAnchorRef","firstDef","secondDef","firstView","secondView","firstMagnet","secondMagnet","getAnchor","anchor","res","firstVertex","lastVertex","priority","sourceDef","targetDef","paperOptions","isNodeConnection","sourceConnectionPointDef","connectionPoint","defaultConnectionPoint","sourcePointRef","sourceLine","getConnectionPoint","targetConnectionPointDef","targetPointRef","targetLine","anchorDef","cellView","magnet","ref","endType","isConnection","defaultLinkAnchor","perpendicularLinks","name","defaultAnchor","anchorFn","anchorName","anchorNamespace","call","args","connectionPointDef","view","line","linkConnectionPoint","linkConnectionMagnet","start","connectionPointFn","connectionPointName","connectionPointNamespace","offset","_normalizeLabelPosition","labelPosition","distance","angle","builtinDefaultLabelPosition","position","defaultLabelPosition","defaultPosition","transformationMatrix","_getLabelTransformationMatrix","matrixToTransformString","_cleanLabelMatrices","index","id","magnetMatrix","connectionLength","getConnectionLength","Number","isNaN","toolPosition","getPointAtLength","x","y","css","endViewProperty","endDef","endId","updateEndMagnet","endModel","getModelById","endView","findView","endMagnetProperty","connectedMagnet","getMagnetFromLinkEnd","sourceArrow","targetArrow","translateAndAutoOrient","cells","_getLabelPositionAngle","_getLabelPositionArgs","_getDefaultLabelPositionArgs","_mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","p1","p2","p3","p4","localX","localY","localAngle","localOpt","positionArgs","getLabelPosition","insertLabel","addVertex","isPointProvided","getVertexIndex","insertVertex","sendToken","token","callback","onAnimationEnd","vToken","duration","isReversed","direction","animationAttributes","dur","repeatCount","calcMode","fill","keyPoints","keyTimes","querySelector","SVGPathElement","appendTo","animateAlongPath","setTimeout","namespace","defaultRouter","routerFn","defaultConnector","connectorFn","raw","normalizePathData","getConnection","hasOwnProperty","data","serialize","getConnectionSubdivisions","segmentSubdivisions","subdivisions","getSegmentSubdivisions","pointAtLength","getPointAtRatio","ratio","parseFloat","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","isOffsetAbsolute","absoluteOffset","pathOpt","labelPoint","t","closestPointT","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","difference","labelAngle","labelOffsetCoordinates","positionOffset","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","translation","normal","rotate","setLength","createSVGMatrix","getLabelCoordinates","e","f","vertexLength","currentVertex","currentVertexLength","notifyPointerdown","evt","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","getAttribute","dragVertexStart","dragVertexRemoveStart","dragArrowheadStart","dragConnectionStart","dragStart","dragData","eventData","action","dragVertex","dragLabel","dragArrowhead","drag","dragVertexEnd","dragLabelEnd","dragArrowheadEnd","dragEnd","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onevent","eventName","linkTool","findParentByClass","stopPropagation","ui","delegateDragEvents","onlabel","dragLabelStart","vertexIdx","_x","_y","currentTarget","labelIdx","parseInt","positionAngle","vertexNode","removeNode","removeVertex","arrowheadNode","arrowheadType","startArrowheadMove","ignoreBackwardsCompatibility","dx","dy","snapLabels","snapLinks","_snapArrowhead","_connectArrowhead","getEventTarget","_snapArrowheadEnd","_connectArrowheadEnd","linkAllowed","_disallow","_finishEmbedding","_notifyConnectEvent","_afterArrowheadMove","whenNotAllowed","set","arrowhead","initialEnd","embeddingMode","reparent","z","currentEnd","prop","endChanged","endsEqual","findViewByModel","initialMagnet","magnetUnderPointer","r","radius","viewsInArea","findViewsInArea","height","prevClosestView","closestView","prevClosestMagnet","closestMagnet","prevMagnetProxy","magnetProxy","minDistance","MAX_VALUE","pointer","candidates","bbox","getNodeBBox","candidate","center","squaredDistance","isAlreadyValidated","validateConnection","validateConnectionArgs","findProxyNode","newClosestMagnet","unhighlight","connecting","snapping","highlight","getLinkEnd","findMagnet","eventTarget","viewUnderPointer","_beforeArrowheadMove","toFront","style","pointerEvents","markAvailable","_markAvailableMagnets","_unmarkAvailableMagnets","_createValidateConnectionArgs","oppositeArrowhead","j","isMagnetAvailable","validate","elements","getCells","marked","magnets","querySelectorAll","availableMagnets","filter","bind","m","magnetAvailability","elementAvailability","markedKeys","keys","markedMagnets","defineProperty","enumerable"],"mappings":"AAAA,SAASA,QAAT,QAAyB,gBAAzB;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,OAAOC,CAAP,MAAc,gBAAd;AACA,SAASC,qBAAT,EAAgCC,KAAhC,EAAuCC,QAAvC,EAAiDC,MAAjD,EAAyDC,OAAzD,EAAkEC,QAAlE,EAA4EC,UAA5E,EAAwFC,KAAxF,EAA+FC,YAA/F,QAAmH,mBAAnH;AACA,SAASC,KAAT,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA4BC,cAA5B,EAA4CC,IAA5C,EAAkDC,QAAlD,QAAkE,gBAAlE;AACA,OAAO,KAAKC,OAAZ,MAAyB,sBAAzB;AACA,OAAO,KAAKC,UAAZ,MAA4B,yBAA5B;AACA,OAAOC,CAAP,MAAc,QAAd,C,CAEA;AACA;;AAEA,OAAO,MAAMC,QAAQ,GAAGrB,QAAQ,CAACsB,MAAT,CAAgB;AAEpCC,EAAAA,SAAS,EAAE,YAAW;AAElB,QAAIC,UAAU,GAAGxB,QAAQ,CAACyB,SAAT,CAAmBF,SAAnB,CAA6BG,KAA7B,CAAmC,IAAnC,EAAyCC,KAAzC,CAA+C,GAA/C,CAAjB;AAEAH,IAAAA,UAAU,CAACI,IAAX,CAAgB,MAAhB;AAEA,WAAOJ,UAAU,CAACK,IAAX,CAAgB,GAAhB,CAAP;AACH,GATmC;AAWpCC,EAAAA,OAAO,EAAE;AAELC,IAAAA,eAAe,EAAE,GAFZ;AAGLC,IAAAA,eAAe,EAAE,KAHZ;AAILC,IAAAA,cAAc,EAAE,GAJX;AAKLC,IAAAA,eAAe,EAAE,EALZ;AAMLC,IAAAA,qBAAqB,EAAE,EANlB;AAOLC,IAAAA,cAAc,EAAE;AAPX,GAX2B;AAqBpCC,EAAAA,WAAW,EAAE,IArBuB;AAsBpCC,EAAAA,eAAe,EAAE,IAtBmB;AAuBpCC,EAAAA,YAAY,EAAE,IAvBsB;AAwBpCC,EAAAA,EAAE,EAAE,IAxBgC;AAyBpCC,EAAAA,SAAS,EAAE,IAzByB;AAyBnB;AAEjBC,EAAAA,OAAO,EAAE,IA3B2B;AA4BpCC,EAAAA,gBAAgB,EAAE,CA5BkB;AA8BpCC,EAAAA,UAAU,EAAE,YAAW;AAEnB5C,IAAAA,QAAQ,CAACyB,SAAT,CAAmBmB,UAAnB,CAA8BlB,KAA9B,CAAoC,IAApC,EAA0CmB,SAA1C,EAFmB,CAInB;AACA;AACA;;AACA,SAAKR,WAAL,GAAmB,EAAnB,CAPmB,CASnB;;AACA,SAAKC,eAAL,GAAuB,EAAvB,CAVmB,CAYnB;;AACA,SAAKC,YAAL,GAAoB,EAApB,CAbmB,CAenB;;AACA,SAAKC,EAAL,GAAU,EAAV,CAhBmB,CAkBnB;;AACA,SAAKE,OAAL,GAAe,EAAf;AACH,GAlDmC;AAoDpCI,EAAAA,sBAAsB,EAAE;AACpBC,IAAAA,MAAM,EAAE,CAAC,QAAD,CADY;AAEpBC,IAAAA,KAAK,EAAE,CAAC,QAAD,CAFa;AAGpBC,IAAAA,MAAM,EAAE,CAAC,QAAD,CAHY;AAIpBC,IAAAA,SAAS,EAAE,CAAC,QAAD,CAJS;AAKpBC,IAAAA,MAAM,EAAE,CAAC,QAAD,CALY;AAMpBC,IAAAA,SAAS,EAAE,CAAC,QAAD,CANS;AAOpBC,IAAAA,UAAU,EAAE,CAAC,cAAD,CAPQ;AAQpBC,IAAAA,MAAM,EAAE,CAAC,QAAD,CARY;AASpBC,IAAAA,WAAW,EAAE,CAAC,QAAD,CATO;AAUpBC,IAAAA,QAAQ,EAAE,CAAC,UAAD,EAAa,QAAb,CAVU;AAWpBC,IAAAA,YAAY,EAAE,CAAC,UAAD,CAXM;AAYpBC,IAAAA,MAAM,EAAE,CAAC,QAAD,EAAW,QAAX,CAZY;AAapBC,IAAAA,MAAM,EAAE,CAAC,QAAD,EAAW,QAAX;AAbY,GApDY;AAoEpCC,EAAAA,QAAQ,EAAE,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+B,OAA/B,CApE0B;AAsEpCC,EAAAA,eAAe,EAAE,CAtEmB;AAwEpCC,EAAAA,aAAa,EAAE,UAASC,KAAT,EAAgBC,GAAhB,EAAqB;AAEhCA,IAAAA,GAAG,KAAKA,GAAG,GAAG,EAAX,CAAH;;AAEA,QAAI,KAAKC,OAAL,CAAaF,KAAb,EAAoB,QAApB,CAAJ,EAAmC;AAC/B,UAAI,CAAC,KAAKG,mBAAL,CAAyB,QAAzB,CAAL,EAAyC,OAAOH,KAAP;AACzCA,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,QAAvB,CAAR;AACH;;AAED,QAAI,KAAKE,OAAL,CAAaF,KAAb,EAAoB,QAApB,CAAJ,EAAmC;AAC/B,UAAI,CAAC,KAAKG,mBAAL,CAAyB,QAAzB,CAAL,EAAyC,OAAOH,KAAP;AACzCA,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,QAAvB,CAAR;AACH;;AAED,UAAM;AAAEK,MAAAA,KAAF;AAASC,MAAAA,UAAT;AAAqBC,MAAAA;AAArB,QAAoC,IAA1C;;AACA,QAAIF,KAAK,KAAMC,UAAU,IAAI,CAACD,KAAK,CAACG,aAAN,CAAoBF,UAApB,CAAhB,IAAqDC,UAAU,IAAI,CAACF,KAAK,CAACG,aAAN,CAAoBD,UAApB,CAAzE,CAAT,EAAqH;AACjH;AACA,aAAOP,KAAP;AACH;;AAED,QAAI,KAAKE,OAAL,CAAaF,KAAb,EAAoB,QAApB,CAAJ,EAAmC;AAC/B,WAAKS,MAAL;AACA,WAAKC,kBAAL,CAAwB,IAAxB;AACA,WAAKC,WAAL,CAAiBV,GAAjB;AACAD,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,CAAC,QAAD,EAAW,QAAX,EAAqB,UAArB,EAAiC,QAAjC,EAA2C,OAA3C,EAAoD,cAApD,CAAvB,CAAR;AACA,aAAOA,KAAP;AACH;;AAED,QAAIU,kBAAkB,GAAG,KAAzB;;AAEA,QAAI,KAAKR,OAAL,CAAaF,KAAb,EAAoB,UAApB,CAAJ,EAAqC;AACjC,WAAKY,mBAAL;AACAZ,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,UAAvB,CAAR;AACH;;AAED,UAAM;AAAEa,MAAAA;AAAF,QAAY,IAAlB;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiBD,KAAvB;AACA,QAAIE,YAAY,GAAG,KAAKb,OAAL,CAAaF,KAAb,EAAoB,QAApB,CAAnB;AACA,QAAIgB,iBAAiB,GAAG,KAAKd,OAAL,CAAaF,KAAb,EAAoB,cAApB,CAAxB;;AAEA,QAAIe,YAAJ,EAAkB;AACd,WAAKE,cAAL,CAAoBJ,KAApB,EAA2BC,UAAU,CAACvB,MAAtC,EAA8CU,GAA9C;AACAD,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,QAAvB,CAAR;AACAU,MAAAA,kBAAkB,GAAG,IAArB;AACH;;AAED,QAAIM,iBAAJ,EAAuB;AACnB,WAAKE,WAAL;AACAlB,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,cAAvB,CAAR;AACH;;AAED,QAAI,KAAKE,OAAL,CAAaF,KAAb,EAAoB,QAApB,CAAJ,EAAmC;AAC/B,WAAKmB,MAAL,CAAYN,KAAZ,EAAmB,IAAnB,EAAyBZ,GAAzB;AACA,WAAKU,WAAL,CAAiBV,GAAjB;AACAD,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,CAAC,QAAD,EAAW,OAAX,CAAvB,CAAR;AACAe,MAAAA,YAAY,GAAG,KAAf;AACAC,MAAAA,iBAAiB,GAAG,KAApB;AACAN,MAAAA,kBAAkB,GAAG,IAArB;AACH;;AAED,QAAIK,YAAJ,EAAkB;AACd,WAAKK,oBAAL;AACH;;AAED,QAAIJ,iBAAJ,EAAuB;AACnB,WAAKK,mBAAL;AACH;;AAED,QAAIX,kBAAJ,EAAwB;AACpB,WAAKA,kBAAL;AACH;;AAED,QAAI,KAAKR,OAAL,CAAaF,KAAb,EAAoB,OAApB,CAAJ,EAAkC;AAC9B,WAAKW,WAAL,CAAiBV,GAAjB;AACAD,MAAAA,KAAK,GAAG,KAAKI,UAAL,CAAgBJ,KAAhB,EAAuB,OAAvB,CAAR;AACH;;AAED,WAAOA,KAAP;AACH,GAtJmC;AAwJpCsB,EAAAA,uBAAuB,EAAE,UAASrB,GAAT,EAAc;AACnC,SAAKsB,aAAL,CAAmB,KAAKC,OAAL,CAAa,QAAb,EAAuBvB,GAAvB,CAAnB;AACH,GA1JmC;AA4JpCwB,EAAAA,sBAAsB,EAAE,UAASxB,GAAG,GAAG,EAAf,EAAmB;AAEvC,UAAMyB,cAAc,GAAG,KAAKb,KAAL,CAAWc,QAAX,CAAoB,QAApB,CAAvB;AACA,QAAI,CAACD,cAAL,EAAqB,OAAO,IAAP,CAHkB,CAKvC;AACA;;AACA,QAAK,uBAAuBzB,GAAxB,IAAiC,mBAAmBA,GAAxD,EAA8D;AAC1D;AACA,UAAI2B,SAAS,GAAG3B,GAAG,CAAC4B,iBAAJ,IAAyB,EAAzC;AACA,UAAIC,UAAU,GAAGF,SAAS,CAACG,MAA3B;;AACA,UAAID,UAAU,GAAG,CAAjB,EAAoB;AAChB;AACA,YAAIE,WAAW,GAAG,CAAC,CAACN,cAAc,CAACE,SAAS,CAAC,CAAD,CAAV,CAAlC;;AACA,YAAII,WAAJ,EAAiB;AACb,cAAIF,UAAU,KAAK,CAAnB,EAAsB;AAClB;AACA;AACA,mBAAQ,YAAYG,MAAM,CAAChC,GAAG,CAACiC,aAAL,CAA1B;AACH,WAJD,MAIO,IAAIN,SAAS,CAAC,CAAD,CAAT,KAAiB,QAArB,EAA+B;AAClC;AACA,mBAAO,KAAP;AACH;AACJ;AACJ;AACJ;;AAED,WAAO,IAAP;AACH,GAxLmC;AA0LpCX,EAAAA,cAAc,EAAE,UAASkB,KAAT,EAAgBC,OAAhB,EAAyBnC,GAAzB,EAA8B;AAE1C;AACA,QAAI,KAAKwB,sBAAL,CAA4BxB,GAA5B,CAAJ,EAAsC;AAClC,WAAKoC,YAAL;AACH,KAFD,MAEO;AACH,WAAKtB,YAAL;AACH;AACJ,GAlMmC;AAoMpC;AACA;AAEAN,EAAAA,MAAM,EAAE,YAAW;AAEf,SAAK6B,GAAL,CAASC,KAAT;AACA,SAAK9D,EAAL,GAAU,EAAV;AACA,SAAK+D,YAAL,GAJe,CAKf;AACA;;AACA,SAAKH,YAAL;AACA,SAAKlB,MAAL;AAEA,WAAO,IAAP;AACH,GAlNmC;AAoNpCqB,EAAAA,YAAY,EAAE,YAAW;AAErB,QAAIC,IAAI,GAAG,KAAK5B,KAAhB;AACA,QAAI7B,MAAM,GAAGyD,IAAI,CAACC,GAAL,CAAS,QAAT,KAAsBD,IAAI,CAACzD,MAAxC;AACA,QAAI,CAACA,MAAL,EAAa,MAAM,IAAI2D,KAAJ,CAAU,+BAAV,CAAN;AACb,QAAIC,KAAK,CAACC,OAAN,CAAc7D,MAAd,CAAJ,EAA2B,OAAO,KAAK8D,gBAAL,CAAsB9D,MAAtB,CAAP;AAC3B,QAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC,OAAO,KAAK+D,kBAAL,CAAwB/D,MAAxB,CAAP;AAChC,UAAM,IAAI2D,KAAJ,CAAU,8BAAV,CAAN;AACH,GA5NmC;AA8NpCG,EAAAA,gBAAgB,EAAE,UAAS9D,MAAT,EAAiB;AAE/B,QAAIgE,GAAG,GAAG,KAAKC,YAAL,CAAkBjE,MAAlB,EAA0B,KAAKkE,EAA/B,CAAV,CAF+B,CAG/B;;AACA,SAAKC,SAAL,GAAiBH,GAAG,CAACG,SAArB,CAJ+B,CAK/B;;AACA,SAAKb,GAAL,CAASc,MAAT,CAAgBJ,GAAG,CAACK,QAApB;AACH,GArOmC;AAuOpCN,EAAAA,kBAAkB,EAAE,UAAS/D,MAAT,EAAiB;AAEjC;AACA;AACA;AACA;AACA;AACA,QAAIsE,QAAQ,GAAGnH,CAAC,CAAC6C,MAAD,CAAhB,CAPiC,CAQjC;;AACA,QAAI,CAAC4D,KAAK,CAACC,OAAN,CAAcS,QAAd,CAAL,EAA8BA,QAAQ,GAAG,CAACA,QAAD,CAAX,CATG,CAUjC;;AACA,QAAIC,KAAK,GAAG,KAAK9E,EAAjB,CAXiC,CAWZ;;AACrB,SAAK,IAAI+E,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,QAAQ,CAACvB,MAA7B,EAAqCyB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,UAAIE,KAAK,GAAGJ,QAAQ,CAACE,CAAD,CAApB;AACA,UAAIhG,SAAS,GAAGkG,KAAK,CAACC,IAAN,CAAW,OAAX,CAAhB;;AACA,UAAInG,SAAJ,EAAe;AACX;AACAA,QAAAA,SAAS,GAAGpB,qBAAqB,CAACoB,SAAD,CAAjC;AACA+F,QAAAA,KAAK,CAAClG,CAAC,CAACuG,SAAF,CAAYpG,SAAZ,CAAD,CAAL,GAAgCkG,KAAhC;AACH;AACJ,KApBgC,CAqBjC;;;AACA,SAAKxC,WAAL;AACA,SAAKN,mBAAL;AACA,SAAKiD,sBAAL;AACA,SAAKvB,GAAL,CAASc,MAAT,CAAgBE,QAAhB;AACH,GAjQmC;AAmQpCQ,EAAAA,eAAe,EAAE,UAAStE,WAAT,EAAsB;AAEnC,QAAI,CAACA,WAAL,EAAkB,OAAOuE,SAAP;AAElB,QAAInB,KAAK,CAACC,OAAN,CAAcrD,WAAd,CAAJ,EAAgC,OAAO,KAAKyD,YAAL,CAAkBzD,WAAlB,EAA+B,IAA/B,CAAP;AAChC,QAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC,OAAO,KAAKwE,qBAAL,CAA2BxE,WAA3B,CAAP;AACrC,UAAM,IAAImD,KAAJ,CAAU,oCAAV,CAAN;AACH,GA1QmC;AA4QpCqB,EAAAA,qBAAqB,EAAE,UAASxE,WAAT,EAAsB;AAEzC,QAAI8D,QAAQ,GAAGnH,CAAC,CAACqD,WAAD,CAAhB;AACA,QAAI6D,QAAQ,GAAGY,QAAQ,CAACC,sBAAT,EAAf;;AAEA,QAAI,CAACtB,KAAK,CAACC,OAAN,CAAcS,QAAd,CAAL,EAA8B;AAC1BD,MAAAA,QAAQ,CAACc,WAAT,CAAqBb,QAAQ,CAACc,IAA9B;AAEH,KAHD,MAGO;AACH,WAAK,IAAIZ,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGH,QAAQ,CAACvB,MAA7B,EAAqCyB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,YAAIa,YAAY,GAAGf,QAAQ,CAACE,CAAD,CAAR,CAAYY,IAA/B;AACAf,QAAAA,QAAQ,CAACc,WAAT,CAAqBE,YAArB;AACH;AACJ;;AAED,WAAO;AAAEhB,MAAAA,QAAQ,EAAEA,QAAZ;AAAsBF,MAAAA,SAAS,EAAE;AAAjC,KAAP,CAfyC,CAeI;AAChD,GA5RmC;AA8RpC;AACA;AACAmB,EAAAA,qBAAqB,EAAE,UAAStF,MAAT,EAAiB;AAEpC,QAAI,CAACA,MAAL,EAAa,OAAO+E,SAAP;AAEb,QAAIV,QAAQ,GAAGrE,MAAM,CAACqE,QAAtB;AACA,QAAI,EAAErE,MAAM,CAACqE,QAAP,YAA2BkB,gBAA7B,KAAkD,CAACvF,MAAM,CAACqE,QAAP,CAAgBmB,aAAhB,EAAvD,EAAwF,MAAM,IAAI7B,KAAJ,CAAU,qCAAV,CAAN;AAExF,QAAI8B,KAAJ;AACA,QAAIC,UAAU,GAAGrB,QAAQ,CAACqB,UAA1B;;AAEA,QAAKA,UAAU,CAAC3C,MAAX,GAAoB,CAArB,IAA2B2C,UAAU,CAAC,CAAD,CAAV,CAAcC,QAAd,CAAuBC,WAAvB,OAAyC,GAAxE,EAA6E;AACzE;AACA;AACAH,MAAAA,KAAK,GAAGtI,CAAC,CAAC,GAAD,CAAD,CAAOiH,MAAP,CAAcC,QAAd,CAAR;AACH,KAJD,MAIO;AACHoB,MAAAA,KAAK,GAAGtI,CAAC,CAACuI,UAAU,CAAC,CAAD,CAAX,CAAT;AACH;;AAEDD,IAAAA,KAAK,CAACI,QAAN,CAAe,OAAf;AAEA,WAAO;AAAET,MAAAA,IAAI,EAAEK,KAAK,CAACL,IAAd;AAAoBjB,MAAAA,SAAS,EAAEnE,MAAM,CAACmE;AAAtC,KAAP;AACH,GArTmC;AAuTpCd,EAAAA,YAAY,EAAE,YAAW;AAErB,QAAIkB,KAAK,GAAG,KAAK9E,EAAjB;AACA,QAAIqG,OAAO,GAAGvB,KAAK,CAAChE,MAApB;AACA,QAAIwF,UAAU,GAAG,KAAKzG,WAAL,GAAmB,EAApC;AACA,QAAI0G,cAAc,GAAG,KAAKzG,eAAL,GAAuB,EAA5C;AACA,QAAIsC,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAItB,MAAM,GAAGsB,KAAK,CAACC,UAAN,CAAiBvB,MAAjB,IAA2B,EAAxC;AACA,QAAI0F,WAAW,GAAG1F,MAAM,CAACwC,MAAzB;;AAEA,QAAIkD,WAAW,KAAK,CAApB,EAAuB;AACnB,UAAIH,OAAJ,EAAaA,OAAO,CAACI,MAAR;AACb,aAAO,IAAP;AACH;;AAED,QAAIJ,OAAJ,EAAa;AACTA,MAAAA,OAAO,CAACvC,KAAR;AACH,KAFD,MAEQ;AACJ;AACA;AACAuC,MAAAA,OAAO,GAAGvB,KAAK,CAAChE,MAAN,GAAepD,CAAC,CAAC,GAAD,CAAD,CAAO0I,QAAP,CAAgB,QAAhB,CAAzB;AACH;;AAED,QAAIM,SAAS,GAAGL,OAAO,CAACV,IAAxB;;AAEA,SAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,WAApB,EAAiCzB,CAAC,EAAlC,EAAsC;AAElC,UAAI4B,KAAK,GAAG7F,MAAM,CAACiE,CAAD,CAAlB;;AACA,UAAIhE,WAAW,GAAG,KAAK8E,qBAAL,CAA2B,KAAKR,eAAL,CAAqBsB,KAAK,CAACpG,MAA3B,CAA3B,CAAlB;;AACA,UAAIqG,SAAJ;AACA,UAAIlC,SAAJ;;AACA,UAAI3D,WAAJ,EAAiB;AAEb6F,QAAAA,SAAS,GAAG7F,WAAW,CAAC4E,IAAxB;AACAjB,QAAAA,SAAS,GAAG3D,WAAW,CAAC2D,SAAxB;AAEH,OALD,MAKO;AAEH,YAAImC,mBAAmB,GAAIzE,KAAK,CAAC0E,SAAN,CAAgBC,YAA3C;;AACA,YAAIC,yBAAyB,GAAG,KAAKnB,qBAAL,CAA2B,KAAKR,eAAL,CAAqBwB,mBAAmB,CAACtG,MAAzC,CAA3B,CAAhC;;AACA,YAAIwG,YAAY,GAAG3E,KAAK,CAAC6E,gBAAN,EAAnB;;AACA,YAAIC,kBAAkB,GAAG,KAAKrB,qBAAL,CAA2B,KAAKR,eAAL,CAAqB0B,YAAY,CAACxG,MAAlC,CAA3B,CAAzB;;AACA,YAAI4G,aAAa,GAAGD,kBAAkB,IAAIF,yBAA1C;AAEAJ,QAAAA,SAAS,GAAGO,aAAa,CAACxB,IAA1B;AACAjB,QAAAA,SAAS,GAAGyC,aAAa,CAACzC,SAA1B;AACH;;AAEDkC,MAAAA,SAAS,CAACQ,YAAV,CAAuB,WAAvB,EAAoCrC,CAApC,EAvBkC,CAuBM;;AACxC2B,MAAAA,SAAS,CAAChB,WAAV,CAAsBkB,SAAtB;AACAN,MAAAA,UAAU,CAACvB,CAAD,CAAV,GAAgB6B,SAAhB,CAzBkC,CAyBP;;AAE3B,UAAIS,YAAY,GAAG,KAAKC,QAAxB;AACA,UAAI5C,SAAS,CAAC2C,YAAD,CAAb,EAA6B,MAAM,IAAInD,KAAJ,CAAU,8CAAV,CAAN;AAC7BQ,MAAAA,SAAS,CAAC2C,YAAD,CAAT,GAA0BT,SAA1B;AAEAL,MAAAA,cAAc,CAACxB,CAAD,CAAd,GAAoBL,SAApB,CA/BkC,CA+BH;AAClC;;AAED,QAAI,CAACgC,SAAS,CAACa,UAAf,EAA2B;AACvB,WAAK9C,EAAL,CAAQiB,WAAR,CAAoBgB,SAApB;AACH;;AAED,SAAKpE,YAAL;AAEA,WAAO,IAAP;AACH,GAzXmC;AA2XpCkF,EAAAA,aAAa,EAAE,UAASC,UAAT,EAAqBH,QAArB,EAA+B;AAC1C,UAAMI,SAAS,GAAG,KAAK7H,WAAL,CAAiB4H,UAAjB,CAAlB;AACA,QAAI,CAACC,SAAL,EAAgB,OAAO,IAAP;AAChB,UAAMnB,cAAc,GAAG,KAAKzG,eAAL,CAAqB2H,UAArB,CAAvB;AACA,UAAM,CAAC9B,IAAI,GAAG,IAAR,IAAgB,KAAKgC,cAAL,CAAoBL,QAApB,EAA8BI,SAA9B,EAAyCnB,cAAzC,CAAtB;AACA,WAAOZ,IAAP;AACH,GAjYmC;AAoYpC;AACA;AACAiC,EAAAA,gBAAgB,EAAE,UAASC,eAAT,EAA0BC,UAA1B,EAAsCC,iBAAtC,EAAyDC,wBAAzD,EAAmF;AAEjG,QAAIF,UAAU,KAAK,IAAnB,EAAyB,OAAO,IAAP;;AACzB,QAAIA,UAAU,KAAKxC,SAAnB,EAA8B;AAE1B,UAAIyC,iBAAiB,KAAK,IAA1B,EAAgC,OAAO,IAAP;;AAChC,UAAIA,iBAAiB,KAAKzC,SAA1B,EAAqC;AAEjC,YAAIuC,eAAJ,EAAqB,OAAOvC,SAAP;AACrB,eAAO0C,wBAAP;AACH;;AAED,UAAIH,eAAJ,EAAqB,OAAOE,iBAAP;AACrB,aAAOnK,KAAK,CAAC,EAAD,EAAKoK,wBAAL,EAA+BD,iBAA/B,CAAZ;AACH;;AAED,QAAIF,eAAJ,EAAqB,OAAOjK,KAAK,CAAC,EAAD,EAAKmK,iBAAL,EAAwBD,UAAxB,CAAZ;AACrB,WAAOlK,KAAK,CAAC,EAAD,EAAKoK,wBAAL,EAA+BD,iBAA/B,EAAkDD,UAAlD,CAAZ;AACH,GAxZmC;AA0ZpCxF,EAAAA,YAAY,EAAE,YAAW;AAErB,QAAI,CAAC,KAAKtC,EAAL,CAAQc,MAAb,EAAqB,OAAO,IAAP;AAErB,QAAIsB,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAItB,MAAM,GAAGsB,KAAK,CAAC6B,GAAN,CAAU,QAAV,KAAuB,EAApC;AACA,QAAIgE,YAAY,GAAG,KAAKC,GAAL,CAAS,WAAT,CAAnB;AAEA,QAAIrB,mBAAmB,GAAGzE,KAAK,CAAC0E,SAAN,CAAgBC,YAA1C;AACA,QAAIiB,wBAAwB,GAAGnB,mBAAmB,CAACrG,KAAnD;;AAEA,QAAIuG,YAAY,GAAG3E,KAAK,CAAC6E,gBAAN,EAAnB;;AACA,QAAIC,kBAAkB,GAAGH,YAAY,CAACxG,MAAtC;AACA,QAAIwH,iBAAiB,GAAGhB,YAAY,CAACvG,KAArC;;AAEA,SAAK,IAAIuE,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGlE,MAAM,CAACwC,MAA3B,EAAmCyB,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAE3C,UAAI6B,SAAS,GAAG,KAAK/G,WAAL,CAAiBkF,CAAjB,CAAhB;AACA6B,MAAAA,SAAS,CAACQ,YAAV,CAAuB,QAAvB,EAAkCa,YAAY,GAAG,MAAH,GAAY,SAA1D;AAEA,UAAIvD,SAAS,GAAG,KAAK5E,eAAL,CAAqBiF,CAArB,CAAhB;AAEA,UAAI4B,KAAK,GAAG7F,MAAM,CAACiE,CAAD,CAAlB;AACA,UAAIhE,WAAW,GAAG4F,KAAK,CAACpG,MAAxB;AACA,UAAIuH,UAAU,GAAGnB,KAAK,CAACnG,KAAvB;;AAEA,UAAIA,KAAK,GAAG,KAAKoH,gBAAL,CACP7G,WAAW,IAAImG,kBADR,EAERY,UAFQ,EAGRC,iBAHQ,EAIRC,wBAJQ,CAAZ;;AAOA,WAAKG,0BAAL,CAAgCvB,SAAhC,EAA2CpG,KAA3C,EAAkD;AAC9C4H,QAAAA,QAAQ,EAAE,IAAI5J,IAAJ,CAASmI,KAAK,CAAC0B,IAAf,CADoC;AAE9C3D,QAAAA,SAAS,EAAEA;AAFmC,OAAlD;AAIH;;AAED,WAAO,IAAP;AACH,GAlcmC;AAocpCjC,EAAAA,WAAW,EAAE,YAAW;AAEpB,QAAI,CAAC,KAAKzC,EAAL,CAAQsI,SAAb,EAAwB,OAAO,IAAP,CAFJ,CAIpB;AACA;AACA;AACA;;AAEA,QAAIC,MAAM,GAAG3J,CAAC,CAAC,KAAKoB,EAAL,CAAQsI,SAAR,CAAkB3C,IAAnB,CAAD,CAA0B7B,KAA1B,EAAb;AACA,QAAI0E,YAAY,GAAG3K,QAAQ,CAAC,KAAKuE,KAAL,CAAW6B,GAAX,CAAe,YAAf,KAAgC,KAAK7B,KAAL,CAAWvB,UAA5C,CAA3B;AACA,QAAI4H,IAAI,GAAG/K,CAAC,CAAC8K,YAAY,EAAb,CAAZ;AAEAD,IAAAA,MAAM,CAAC5D,MAAP,CAAc8D,IAAI,CAAC9C,IAAnB,EAboB,CAepB;;AACA,SAAK+C,UAAL,GAAkBD,IAAlB,CAhBoB,CAkBpB;AACA;;AACA,QAAI,KAAKnJ,OAAL,CAAaE,eAAjB,EAAkC;AAE9B,UAAImJ,KAAJ;;AACA,UAAI,KAAKvG,KAAL,CAAW6B,GAAX,CAAe,kBAAf,KAAsC,KAAK7B,KAAL,CAAWwG,gBAArD,EAAuE;AACnEJ,QAAAA,YAAY,GAAG3K,QAAQ,CAAC,KAAKuE,KAAL,CAAW6B,GAAX,CAAe,kBAAf,KAAsC,KAAK7B,KAAL,CAAWwG,gBAAlD,CAAvB;AACAD,QAAAA,KAAK,GAAGjL,CAAC,CAAC8K,YAAY,EAAb,CAAT;AACH,OAHD,MAGO;AACHG,QAAAA,KAAK,GAAGF,IAAI,CAACvK,KAAL,EAAR;AACH;;AAEDqK,MAAAA,MAAM,CAAC5D,MAAP,CAAcgE,KAAK,CAAChD,IAApB;AACA,WAAKkD,WAAL,GAAmBF,KAAnB;AACH;;AAED,WAAO,IAAP;AACH,GAvemC;AAyepCxG,EAAAA,mBAAmB,EAAE,YAAW;AAE5B,QAAI,CAAC,KAAKnC,EAAL,CAAQ8I,cAAb,EAA6B,OAAO,IAAP;AAE7B,QAAIC,eAAe,GAAGnK,CAAC,CAAC,KAAKoB,EAAL,CAAQ8I,cAAR,CAAuBnD,IAAxB,CAAD,CAA+B7B,KAA/B,EAAtB,CAJ4B,CAM5B;AACA;AACA;;AACA,QAAIkF,cAAc,GAAGnL,QAAQ,CAAC,KAAKuE,KAAL,CAAW6B,GAAX,CAAe,cAAf,KAAkC,KAAK7B,KAAL,CAAWnB,YAA9C,CAA7B;AAEA,SAAKmB,KAAL,CAAWpB,QAAX,GAAsBiI,OAAtB,CAA8B,UAASC,MAAT,EAAiBC,GAAjB,EAAsB;AAChDJ,MAAAA,eAAe,CAACpE,MAAhB,CAAuBjH,CAAC,CAACsL,cAAc,CAAClL,MAAM,CAAC;AAAEqL,QAAAA,GAAG,EAAEA;AAAP,OAAD,EAAeD,MAAf,CAAP,CAAf,CAAD,CAAgDvD,IAAvE;AACH,KAFD;AAIA,WAAO,IAAP;AACH,GAzfmC;AA2fpCP,EAAAA,sBAAsB,EAAE,YAAW;AAE/B;AACA,QAAI,CAAC,KAAKpF,EAAL,CAAQoJ,gBAAb,EAA+B,OAAO,IAAP;AAE/B,QAAIC,iBAAiB,GAAGzK,CAAC,CAAC,KAAKoB,EAAL,CAAQoJ,gBAAR,CAAyBzD,IAA1B,CAAzB;AAEA0D,IAAAA,iBAAiB,CAACvF,KAAlB,GAP+B,CAS/B;AACA;AACA;;AACA,QAAIkF,cAAc,GAAGnL,QAAQ,CAAC,KAAKuE,KAAL,CAAW6B,GAAX,CAAe,iBAAf,KAAqC,KAAK7B,KAAL,CAAWkH,eAAjD,CAA7B;AAEA,SAAKtJ,EAAL,CAAQuJ,eAAR,GAA0B7L,CAAC,CAACsL,cAAc,CAAC;AAAEQ,MAAAA,GAAG,EAAE;AAAP,KAAD,CAAf,CAA3B;AACA,SAAKxJ,EAAL,CAAQyJ,eAAR,GAA0B/L,CAAC,CAACsL,cAAc,CAAC;AAAEQ,MAAAA,GAAG,EAAE;AAAP,KAAD,CAAf,CAA3B;AAEAH,IAAAA,iBAAiB,CAAC1E,MAAlB,CAAyB,KAAK3E,EAAL,CAAQuJ,eAAR,CAAwB5D,IAAjD,EAAuD,KAAK3F,EAAL,CAAQyJ,eAAR,CAAwB9D,IAA/E;AAEA,WAAO,IAAP;AACH,GA/gBmC;AAihBpC;AACA;AAEA;AACAjD,EAAAA,MAAM,EAAE,UAASN,KAAT,EAAgBC,UAAhB,EAA4Bb,GAA5B,EAAiC;AAErCA,IAAAA,GAAG,KAAKA,GAAG,GAAG,EAAX,CAAH;AAEA,SAAKkI,eAAL,GAJqC,CAMrC;;AACA,SAAKC,gBAAL,CAAsBnI,GAAtB,EAPqC,CASrC;;AACA,SAAK2G,0BAAL,CAAgC,KAAK1D,EAArC,EAAyC,KAAKrC,KAAL,CAAW8C,IAAX,EAAzC,EAA4D;AAAER,MAAAA,SAAS,EAAE,KAAKA;AAAlB,KAA5D;AAEA,SAAKkF,2BAAL,GAZqC,CAcrC;;AACA,SAAKjH,oBAAL;AACA,SAAKC,mBAAL;AACA,SAAKiH,sBAAL,GAjBqC,CAmBrC;AACA;AACA;AACA;;AACA,SAAKvK,OAAL,CAAawK,aAAb,GAA6B,IAA7B;AAEA,WAAO,IAAP;AACH,GA/iBmC;AAijBpC;AACA;AACAC,EAAAA,6BAA6B,EAAE,UAASvI,GAAT,EAAc;AAEzC,UAAMwI,kBAAkB,GAAG,KAA3B;AAEA,UAAMhG,IAAI,GAAG,KAAK5B,KAAlB;AACA,UAAMpB,QAAQ,GAAGgD,IAAI,CAAChD,QAAL,EAAjB;AACA,UAAMiJ,WAAW,GAAG,CAAC,KAAKC,YAAN,EAAoB,GAAGlJ,QAAvB,EAAiC,KAAKmJ,YAAtC,CAApB;AACA,UAAMC,cAAc,GAAGH,WAAW,CAAC3G,MAAnC,CAPyC,CASzC;;AACA,UAAM+G,QAAQ,GAAG,IAAI5L,QAAJ,CAAawL,WAAb,CAAjB;AACAI,IAAAA,QAAQ,CAACC,QAAT,CAAkB;AAAEC,MAAAA,SAAS,EAAEP;AAAb,KAAlB;AACA,UAAMQ,cAAc,GAAGH,QAAQ,CAACI,MAAT,CAAgBC,GAAhB,CAAqBC,KAAD,IAAYA,KAAK,CAACC,MAAN,EAAhC,CAAvB,CAZyC,CAYgC;;AACzE,UAAMC,iBAAiB,GAAGL,cAAc,CAAClH,MAAzC,CAbyC,CAaQ;AAEjD;;AACA,QAAI8G,cAAc,KAAKS,iBAAvB,EAA0C,OAAO,CAAP,CAhBD,CAkBzC;AACA;;AACA7G,IAAAA,IAAI,CAAChD,QAAL,CAAcwJ,cAAc,CAACM,KAAf,CAAqB,CAArB,EAAwBD,iBAAiB,GAAG,CAA5C,CAAd,EAA8DrJ,GAA9D;AACA,WAAQ4I,cAAc,GAAGS,iBAAzB;AACH,GAzkBmC;AA2kBpCjB,EAAAA,2BAA2B,EAAE,YAAW;AAEpC,QAAI9E,KAAK,GAAG,KAAK9E,EAAjB;;AAEA,QAAI8E,KAAK,CAACiG,UAAV,EAAsB;AAClBjG,MAAAA,KAAK,CAACiG,UAAN,CAAiB7F,IAAjB,CAAsB,GAAtB,EAA2B,KAAK8F,uBAAL,EAA3B;AACH;;AAED,QAAIlG,KAAK,CAACmG,cAAV,EAA0B;AACtBnG,MAAAA,KAAK,CAACmG,cAAN,CAAqB/F,IAArB,CAA0B,GAA1B,EAA+B,KAAK8F,uBAAL,EAA/B;AACH;;AAED,QAAIlG,KAAK,CAACoG,YAAN,IAAsBpG,KAAK,CAACqG,YAAhC,EAA8C;AAC1C,WAAKC,6BAAL,CAAmCtG,KAAK,CAACoG,YAAzC,EAAuDpG,KAAK,CAACqG,YAA7D;AACH;AACJ,GA1lBmC;AA4lBpCE,EAAAA,UAAU,EAAE,UAASC,IAAT,EAAe;AACvB,YAAQA,IAAR;AACI,WAAK,QAAL;AACI,eAAO,KAAKzJ,UAAL,IAAmB,IAA1B;;AACJ,WAAK,QAAL;AACI,eAAO,KAAKC,UAAL,IAAmB,IAA1B;;AACJ;AACI,cAAM,IAAIoC,KAAJ,CAAU,wCAAV,CAAN;AANR;AAQH,GArmBmC;AAumBpCqH,EAAAA,YAAY,EAAE,UAASD,IAAT,EAAe;AACzB,YAAQA,IAAR;AACI,WAAK,QAAL;AACI,eAAO,IAAIlN,KAAJ,CAAU,KAAK8L,YAAf,CAAP;;AACJ,WAAK,QAAL;AACI,eAAO,IAAI9L,KAAJ,CAAU,KAAK+L,YAAf,CAAP;;AACJ;AACI,cAAM,IAAIjG,KAAJ,CAAU,wCAAV,CAAN;AANR;AAQH,GAhnBmC;AAknBpCsH,EAAAA,qBAAqB,EAAE,UAASF,IAAT,EAAe;AAClC,YAAQA,IAAR;AACI,WAAK,QAAL;AACI,eAAO,IAAIlN,KAAJ,CAAU,KAAKqN,WAAf,CAAP;;AACJ,WAAK,QAAL;AACI,eAAO,IAAIrN,KAAJ,CAAU,KAAKsN,WAAf,CAAP;;AACJ;AACI,cAAM,IAAIxH,KAAJ,CAAU,wCAAV,CAAN;AANR;AAQH,GA3nBmC;AA6nBpCyH,EAAAA,YAAY,EAAE,UAASL,IAAT,EAAe;AACzB,YAAQA,IAAR;AACI,WAAK,QAAL;AACI,YAAIzJ,UAAU,GAAG,KAAKA,UAAtB;AACA,YAAI,CAACA,UAAL,EAAiB;AACjB,eAAO,KAAK+J,YAAL,IAAqB/J,UAAU,CAAC4C,EAAvC;;AACJ,WAAK,QAAL;AACI,YAAI3C,UAAU,GAAG,KAAKA,UAAtB;AACA,YAAI,CAACA,UAAL,EAAiB;AACjB,eAAO,KAAK+J,YAAL,IAAqB/J,UAAU,CAAC2C,EAAvC;;AACJ;AACI,cAAM,IAAIP,KAAJ,CAAU,wCAAV,CAAN;AAVR;;AAYA,WAAO,IAAP;AACH,GA3oBmC;AA6oBpCyF,EAAAA,gBAAgB,EAAE,UAASnI,GAAT,EAAc;AAE5BA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AAEA,QAAIY,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAI0J,KAAJ,EAAWC,IAAX;;AAEA,QAAIvK,GAAG,CAACwK,WAAJ,IAAmB5J,KAAK,CAAC6J,wBAAN,CAA+BzK,GAAG,CAACwK,WAAnC,CAAvB,EAAwE;AACpE;AACA;AACA;AACA,UAAIE,EAAE,GAAG1K,GAAG,CAAC0K,EAAJ,IAAU,CAAnB;AACA,UAAIC,EAAE,GAAG3K,GAAG,CAAC2K,EAAJ,IAAU,CAAnB;AAEAL,MAAAA,KAAK,GAAI,IAAIrN,QAAJ,CAAa,KAAKqN,KAAlB,CAAD,CAA2BM,SAA3B,CAAqCF,EAArC,EAAyCC,EAAzC,EAA6C1B,MAArD,CAPoE,CASpE;;AACA,WAAK4B,0BAAL,CAAgCH,EAAhC,EAAoCC,EAApC,EAVoE,CAYpE;;;AACAJ,MAAAA,IAAI,GAAG,KAAKA,IAAZ;AACAA,MAAAA,IAAI,CAACK,SAAL,CAAeF,EAAf,EAAmBC,EAAnB;AAEH,KAhBD,MAgBO;AAEH,UAAInL,QAAQ,GAAGoB,KAAK,CAACpB,QAAN,EAAf,CAFG,CAGH;;AAEA,UAAIsL,OAAO,GAAG,KAAKC,WAAL,CAAiBvL,QAAjB,CAAd;AACA,UAAIkJ,YAAY,GAAG,KAAKA,YAAL,GAAoBoC,OAAO,CAACpL,MAA/C;AACA,UAAIiJ,YAAY,GAAG,KAAKA,YAAL,GAAoBmC,OAAO,CAACnL,MAA/C,CAPG,CASH;;AACA2K,MAAAA,KAAK,GAAG,KAAKU,SAAL,CAAexL,QAAf,EAAyBQ,GAAzB,CAAR,CAVG,CAYH;;AACA,UAAIiL,gBAAgB,GAAG,KAAKC,oBAAL,CAA0BZ,KAA1B,EAAiC5B,YAAjC,EAA+CC,YAA/C,CAAvB;AACA,UAAIsB,WAAW,GAAG,KAAKA,WAAL,GAAmBgB,gBAAgB,CAACvL,MAAtD;AACA,UAAIwK,WAAW,GAAG,KAAKA,WAAL,GAAmBe,gBAAgB,CAACtL,MAAtD,CAfG,CAiBH;;AACA,UAAIwL,YAAY,GAAG,KAAKC,gBAAL,CAAsBd,KAAtB,EAA6BL,WAA7B,EAA0CC,WAA1C,CAAnB,CAlBG,CAoBH;;AACAK,MAAAA,IAAI,GAAG,KAAKc,QAAL,CAAcf,KAAd,EAAqBa,YAAY,CAACzL,MAAb,IAAuBuK,WAA5C,EAAyDkB,YAAY,CAACxL,MAAb,IAAuBuK,WAAhF,CAAP;AACH;;AAED,SAAKI,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAK7L,OAAL,GAAe,EAAf;AACH,GA/rBmC;AAisBpC0M,EAAAA,gBAAgB,EAAE,UAASd,KAAT,EAAgBL,WAAhB,EAA6BC,WAA7B,EAA0C;AAExD,QAAIoB,aAAa,GAAGhB,KAAK,CAAC,CAAD,CAAzB;AACA,QAAIiB,YAAY,GAAGjB,KAAK,CAACA,KAAK,CAACxI,MAAN,GAAe,CAAhB,CAAxB,CAHwD,CAKxD;AACA;AACA;AACA;AACA;;AACA,QAAIwB,KAAK,GAAG,KAAK/E,YAAjB,CAVwD,CAWxD;;AACA,QAAIiN,iBAAJ,EAAuBC,iBAAvB;;AAEA,QAAI,KAAKjN,EAAL,CAAQkL,YAAZ,EAA0B;AAEtBpG,MAAAA,KAAK,CAACoI,UAAN,GAAmBpI,KAAK,CAACoI,UAAN,IAAoB,KAAKlN,EAAL,CAAQkL,YAAR,CAAqBiC,OAArB,EAAvC;AACAH,MAAAA,iBAAiB,GAAG5O,KAAK,CAACqN,WAAD,CAAL,CAAmB2B,IAAnB,CAChBN,aAAa,IAAIpB,WADD,EAEhB5G,KAAK,CAACoI,UAAN,CAAiBG,KAAjB,GAAyB,KAAKrN,EAAL,CAAQkL,YAAR,CAAqBoC,KAArB,GAA6BC,EAAtD,GAA2D,CAAC,CAF5C,EAGlBC,KAHkB,EAApB;AAIH;;AAED,QAAI,KAAKxN,EAAL,CAAQmL,YAAZ,EAA0B;AAEtBrG,MAAAA,KAAK,CAAC2I,UAAN,GAAmB3I,KAAK,CAAC2I,UAAN,IAAoB,KAAKzN,EAAL,CAAQmL,YAAR,CAAqBgC,OAArB,EAAvC;AACAF,MAAAA,iBAAiB,GAAG7O,KAAK,CAACsN,WAAD,CAAL,CAAmB0B,IAAnB,CAChBL,YAAY,IAAItB,WADA,EAEhB3G,KAAK,CAAC2I,UAAN,CAAiBJ,KAAjB,GAAyB,KAAKrN,EAAL,CAAQmL,YAAR,CAAqBmC,KAArB,GAA6BC,EAAtD,GAA2D,CAAC,CAF5C,EAGlBC,KAHkB,EAApB;AAIH,KA9BuD,CAgCxD;;;AACA1I,IAAAA,KAAK,CAAC2G,WAAN,GAAoBuB,iBAAiB,IAAIvB,WAAW,CAACvN,KAAZ,EAAzC;AACA4G,IAAAA,KAAK,CAAC4G,WAAN,GAAoBuB,iBAAiB,IAAIvB,WAAW,CAACxN,KAAZ,EAAzC;AAEA,WAAO;AACHgD,MAAAA,MAAM,EAAE8L,iBADL;AAEH7L,MAAAA,MAAM,EAAE8L;AAFL,KAAP;AAIH,GAzuBmC;AA2uBpCS,EAAAA,kBAAkB,EAAE,UAASC,YAAT,EAAuBC,QAAvB,EAAiCC,aAAjC,EAAgDC,SAAhD,EAA2D;AAE3E,QAAIC,WAAJ,EAAiBC,YAAjB;AACA,QAAIC,cAAJ,EAAoBC,eAApB;AACA,QAAI9L,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAI+L,QAAQ,GAAG/L,KAAK,CAAC6B,GAAN,CAAU0J,YAAV,CAAf;AACA,QAAIS,SAAS,GAAGhM,KAAK,CAAC6B,GAAN,CAAU4J,aAAV,CAAhB;AACA,QAAIQ,SAAS,GAAG,KAAKhD,UAAL,CAAgBsC,YAAhB,CAAhB;AACA,QAAIW,UAAU,GAAG,KAAKjD,UAAL,CAAgBwC,aAAhB,CAAjB;AACA,QAAIU,WAAW,GAAG,KAAK5C,YAAL,CAAkBgC,YAAlB,CAAlB;AACA,QAAIa,YAAY,GAAG,KAAK7C,YAAL,CAAkBkC,aAAlB,CAAnB,CAV2E,CAY3E;;AACA,QAAIQ,SAAJ,EAAe;AACX,UAAIT,QAAJ,EAAc;AACVK,QAAAA,cAAc,GAAG,IAAI7P,KAAJ,CAAUwP,QAAV,CAAjB;AACH,OAFD,MAEO,IAAIU,UAAJ,EAAgB;AACnBL,QAAAA,cAAc,GAAGO,YAAjB;AACH,OAFM,MAEA;AACHP,QAAAA,cAAc,GAAG,IAAI7P,KAAJ,CAAUgQ,SAAV,CAAjB;AACH;;AACDL,MAAAA,WAAW,GAAG,KAAKU,SAAL,CAAeN,QAAQ,CAACO,MAAxB,EAAgCL,SAAhC,EAA2CE,WAA3C,EAAwDN,cAAxD,EAAwEN,YAAxE,CAAd;AACH,KATD,MASO;AACHI,MAAAA,WAAW,GAAG,IAAI3P,KAAJ,CAAU+P,QAAV,CAAd;AACH,KAxB0E,CA0B3E;;;AACA,QAAIG,UAAJ,EAAgB;AACZJ,MAAAA,eAAe,GAAG,IAAI9P,KAAJ,CAAU0P,SAAS,IAAIC,WAAvB,CAAlB;AACAC,MAAAA,YAAY,GAAG,KAAKS,SAAL,CAAeL,SAAS,CAACM,MAAzB,EAAiCJ,UAAjC,EAA6CE,YAA7C,EAA2DN,eAA3D,EAA4EL,aAA5E,CAAf;AACH,KAHD,MAGO;AACHG,MAAAA,YAAY,GAAG,IAAI5P,KAAJ,CAAUgQ,SAAV,CAAf;AACH;;AAED,QAAIO,GAAG,GAAG,EAAV;AACAA,IAAAA,GAAG,CAAChB,YAAD,CAAH,GAAoBI,WAApB;AACAY,IAAAA,GAAG,CAACd,aAAD,CAAH,GAAqBG,YAArB;AACA,WAAOW,GAAP;AACH,GAjxBmC;AAmxBpCpC,EAAAA,WAAW,EAAE,UAASvL,QAAT,EAAmB;AAE5B,QAAIoB,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIwM,WAAW,GAAG5N,QAAQ,CAAC,CAAD,CAA1B;AACA,QAAI6N,UAAU,GAAG7N,QAAQ,CAACA,QAAQ,CAACsC,MAAT,GAAkB,CAAnB,CAAzB;;AAEA,QAAIlB,KAAK,CAACjB,MAAN,GAAe2N,QAAf,IAA2B,CAAC1M,KAAK,CAAClB,MAAN,GAAe4N,QAA/C,EAAyD;AACrD;AACA,aAAO,KAAKpB,kBAAL,CAAwB,QAAxB,EAAkCmB,UAAlC,EAA8C,QAA9C,EAAwDD,WAAxD,CAAP;AACH,KAT2B,CAW5B;;;AACA,WAAO,KAAKlB,kBAAL,CAAwB,QAAxB,EAAkCkB,WAAlC,EAA+C,QAA/C,EAAyDC,UAAzD,CAAP;AACH,GAhyBmC;AAkyBpCnC,EAAAA,oBAAoB,EAAE,UAASZ,KAAT,EAAgB5B,YAAhB,EAA8BC,YAA9B,EAA4C;AAE9D,QAAI2C,aAAa,GAAGhB,KAAK,CAAC,CAAD,CAAzB;AACA,QAAIiB,YAAY,GAAGjB,KAAK,CAACA,KAAK,CAACxI,MAAN,GAAe,CAAhB,CAAxB;AACA,QAAIlB,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAI2M,SAAS,GAAG3M,KAAK,CAAC6B,GAAN,CAAU,QAAV,CAAhB;AACA,QAAI+K,SAAS,GAAG5M,KAAK,CAAC6B,GAAN,CAAU,QAAV,CAAhB;AACA,QAAIpC,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAIC,UAAU,GAAG,KAAKA,UAAtB;AACA,QAAImN,YAAY,GAAG,KAAKrN,KAAL,CAAWtC,OAA9B;AACA,QAAIsM,YAAJ,EAAkBC,YAAlB,CAV8D,CAY9D;;AACA,QAAIJ,WAAJ;;AACA,QAAI5J,UAAU,IAAI,CAACA,UAAU,CAACqN,gBAAX,CAA4B,KAAKtD,YAAjC,CAAnB,EAAmE;AAC/DA,MAAAA,YAAY,GAAI,KAAKA,YAAL,IAAqB/J,UAAU,CAAC4C,EAAhD;AACA,UAAI0K,wBAAwB,GAAGJ,SAAS,CAACK,eAAV,IAA6BH,YAAY,CAACI,sBAAzE;AACA,UAAIC,cAAc,GAAGxC,aAAa,IAAI3C,YAAtC;AACA,UAAIoF,UAAU,GAAG,IAAIlR,IAAJ,CAASiR,cAAT,EAAyBpF,YAAzB,CAAjB;AACAuB,MAAAA,WAAW,GAAG,KAAK+D,kBAAL,CACVL,wBADU,EAEVtN,UAFU,EAGV+J,YAHU,EAIV2D,UAJU,EAKV,QALU,CAAd;AAOH,KAZD,MAYO;AACH9D,MAAAA,WAAW,GAAGvB,YAAd;AACH,KA5B6D,CA6B9D;;;AACA,QAAIwB,WAAJ;;AACA,QAAI5J,UAAU,IAAI,CAACA,UAAU,CAACoN,gBAAX,CAA4B,KAAKrD,YAAjC,CAAnB,EAAmE;AAC/DA,MAAAA,YAAY,GAAI,KAAKA,YAAL,IAAqB/J,UAAU,CAAC2C,EAAhD;AACA,UAAIgL,wBAAwB,GAAGT,SAAS,CAACI,eAAV,IAA6BH,YAAY,CAACI,sBAAzE;AACA,UAAIK,cAAc,GAAG3C,YAAY,IAAI7C,YAArC;AACA,UAAIyF,UAAU,GAAG,IAAItR,IAAJ,CAASqR,cAAT,EAAyBvF,YAAzB,CAAjB;AACAuB,MAAAA,WAAW,GAAG,KAAK8D,kBAAL,CACVC,wBADU,EAEV3N,UAFU,EAGV+J,YAHU,EAIV8D,UAJU,EAKV,QALU,CAAd;AAOH,KAZD,MAYO;AACHjE,MAAAA,WAAW,GAAGvB,YAAd;AACH;;AAED,WAAO;AACHjJ,MAAAA,MAAM,EAAEuK,WADL;AAEHtK,MAAAA,MAAM,EAAEuK;AAFL,KAAP;AAIH,GAr1BmC;AAu1BpC+C,EAAAA,SAAS,EAAE,UAASmB,SAAT,EAAoBC,QAApB,EAA8BC,MAA9B,EAAsCC,GAAtC,EAA2CC,OAA3C,EAAoD;AAE3D,QAAIC,YAAY,GAAGJ,QAAQ,CAACX,gBAAT,CAA0BY,MAA1B,CAAnB;AACA,QAAIb,YAAY,GAAG,KAAKrN,KAAL,CAAWtC,OAA9B;;AACA,QAAI,CAACsQ,SAAL,EAAgB;AACZ,UAAIK,YAAJ,EAAkB;AACdL,QAAAA,SAAS,GAAGX,YAAY,CAACiB,iBAAzB;AACH,OAFD,MAEO;AACH,YAAIjB,YAAY,CAACkB,kBAAb,IAAmC,KAAK7Q,OAAL,CAAawK,aAApD,EAAmE;AAC/D;AACA;AACA;AACA;AACA8F,UAAAA,SAAS,GAAG;AAAEQ,YAAAA,IAAI,EAAE;AAAR,WAAZ;AACH,SAND,MAMO;AACHR,UAAAA,SAAS,GAAGX,YAAY,CAACoB,aAAzB;AACH;AACJ;AACJ;;AAED,QAAI,CAACT,SAAL,EAAgB,MAAM,IAAI1L,KAAJ,CAAU,kBAAV,CAAN;AAChB,QAAIoM,QAAJ;;AACA,QAAI,OAAOV,SAAP,KAAqB,UAAzB,EAAqC;AACjCU,MAAAA,QAAQ,GAAGV,SAAX;AACH,KAFD,MAEO;AACH,UAAIW,UAAU,GAAGX,SAAS,CAACQ,IAA3B;AACA,UAAII,eAAe,GAAGP,YAAY,GAAG,qBAAH,GAA2B,iBAA7D;AACAK,MAAAA,QAAQ,GAAGrB,YAAY,CAACuB,eAAD,CAAZ,CAA8BD,UAA9B,CAAX;AACA,UAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC,MAAM,IAAIpM,KAAJ,CAAU,qBAAqBqM,UAA/B,CAAN;AACvC;;AACD,QAAI7B,MAAM,GAAG4B,QAAQ,CAACG,IAAT,CACT,IADS,EAETZ,QAFS,EAGTC,MAHS,EAITC,GAJS,EAKTH,SAAS,CAACc,IAAV,IAAkB,EALT,EAMTV,OANS,EAOT,IAPS,CAAb;AASA,QAAI,CAACtB,MAAL,EAAa,OAAO,IAAItQ,KAAJ,EAAP;AACb,WAAOsQ,MAAM,CAAClB,KAAP,CAAa,KAAKrN,gBAAlB,CAAP;AACH,GAh4BmC;AAm4BpCqP,EAAAA,kBAAkB,EAAE,UAASmB,kBAAT,EAA6BC,IAA7B,EAAmCd,MAAnC,EAA2Ce,IAA3C,EAAiDb,OAAjD,EAA0D;AAE1E,QAAIZ,eAAJ;AACA,QAAIV,MAAM,GAAGmC,IAAI,CAACrH,GAAlB;AACA,QAAIyF,YAAY,GAAG,KAAKrN,KAAL,CAAWtC,OAA9B,CAJ0E,CAM1E;;AACA,QAAI,OAAO2P,YAAY,CAAC6B,mBAApB,KAA4C,UAAhD,EAA4D;AACxD,UAAIC,oBAAoB,GAAIjB,MAAM,KAAKc,IAAI,CAACnM,EAAjB,GAAuBa,SAAvB,GAAmCwK,MAA9D;AACAV,MAAAA,eAAe,GAAGH,YAAY,CAAC6B,mBAAb,CAAiC,IAAjC,EAAuCF,IAAvC,EAA6CG,oBAA7C,EAAmEF,IAAI,CAACG,KAAxE,EAA+EhB,OAA/E,CAAlB;AACA,UAAIZ,eAAJ,EAAqB,OAAOA,eAAP;AACxB;;AAED,QAAI,CAACuB,kBAAL,EAAyB,OAAOjC,MAAP;AACzB,QAAIuC,iBAAJ;;AACA,QAAI,OAAON,kBAAP,KAA8B,UAAlC,EAA8C;AAC1CM,MAAAA,iBAAiB,GAAGN,kBAApB;AACH,KAFD,MAEO;AACH,UAAIO,mBAAmB,GAAGP,kBAAkB,CAACP,IAA7C;AACAa,MAAAA,iBAAiB,GAAGhC,YAAY,CAACkC,wBAAb,CAAsCD,mBAAtC,CAApB;AACA,UAAI,OAAOD,iBAAP,KAA6B,UAAjC,EAA6C,MAAM,IAAI/M,KAAJ,CAAU,+BAA+BgN,mBAAzC,CAAN;AAChD;;AACD9B,IAAAA,eAAe,GAAG6B,iBAAiB,CAACR,IAAlB,CAAuB,IAAvB,EAA6BI,IAA7B,EAAmCD,IAAnC,EAAyCd,MAAzC,EAAiDa,kBAAkB,CAACD,IAAnB,IAA2B,EAA5E,EAAgFV,OAAhF,EAAyF,IAAzF,CAAlB;AACA,QAAI,CAACZ,eAAL,EAAsB,OAAOV,MAAP;AACtB,WAAOU,eAAe,CAAC5B,KAAhB,CAAsB,KAAKrN,gBAA3B,CAAP;AACH,GA55BmC;AA85BpCkM,EAAAA,0BAA0B,EAAE,UAASH,EAAT,EAAaC,EAAb,EAAiB;AAEzC,QAAIrH,KAAK,GAAG,KAAK/E,YAAjB;AAEA+E,IAAAA,KAAK,CAAC2G,WAAN,CAAkB2F,MAAlB,CAAyBlF,EAAzB,EAA6BC,EAA7B;AACArH,IAAAA,KAAK,CAAC4G,WAAN,CAAkB0F,MAAlB,CAAyBlF,EAAzB,EAA6BC,EAA7B;AACA,SAAKV,WAAL,CAAiB2F,MAAjB,CAAwBlF,EAAxB,EAA4BC,EAA5B;AACA,SAAKT,WAAL,CAAiB0F,MAAjB,CAAwBlF,EAAxB,EAA4BC,EAA5B;AACA,SAAKjC,YAAL,CAAkBkH,MAAlB,CAAyBlF,EAAzB,EAA6BC,EAA7B;AACA,SAAKhC,YAAL,CAAkBiH,MAAlB,CAAyBlF,EAAzB,EAA6BC,EAA7B;AACH,GAx6BmC;AA06BpC;AACA;AACAkF,EAAAA,uBAAuB,EAAE,UAASC,aAAT,EAAwB;AAE7C,QAAI,OAAOA,aAAP,KAAyB,QAA7B,EAAuC,OAAO;AAAEC,MAAAA,QAAQ,EAAED,aAAZ;AAA2BF,MAAAA,MAAM,EAAE,IAAnC;AAAyCI,MAAAA,KAAK,EAAE,CAAhD;AAAmDd,MAAAA,IAAI,EAAE;AAAzD,KAAP;AACvC,WAAOY,aAAP;AACH,GAh7BmC;AAk7BpC3O,EAAAA,oBAAoB,EAAE,YAAW;AAE7B,QAAI,CAAC,KAAK3C,EAAL,CAAQc,MAAb,EAAqB,OAAO,IAAP;AAErB,QAAIiL,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP,CALkB,CAO7B;AACA;;AAEA,QAAI3J,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAItB,MAAM,GAAGsB,KAAK,CAAC6B,GAAN,CAAU,QAAV,KAAuB,EAApC;AACA,QAAI,CAACnD,MAAM,CAACwC,MAAZ,EAAoB,OAAO,IAAP;AAEpB,QAAIuD,mBAAmB,GAAGzE,KAAK,CAAC0E,SAAN,CAAgBC,YAA1C;AACA,QAAI0K,2BAA2B,GAAG5K,mBAAmB,CAAC6K,QAAtD;;AAEA,QAAI3K,YAAY,GAAG3E,KAAK,CAAC6E,gBAAN,EAAnB;;AACA,QAAI0K,oBAAoB,GAAG,KAAKN,uBAAL,CAA6BtK,YAAY,CAAC2K,QAA1C,CAA3B;;AAEA,QAAIE,eAAe,GAAGhU,KAAK,CAAC,EAAD,EAAK6T,2BAAL,EAAkCE,oBAAlC,CAA3B;;AAEA,SAAK,IAAIxI,GAAG,GAAG,CAAV,EAAanE,CAAC,GAAGlE,MAAM,CAACwC,MAA7B,EAAqC6F,GAAG,GAAGnE,CAA3C,EAA8CmE,GAAG,EAAjD,EAAqD;AACjD,UAAIvC,SAAS,GAAG,KAAK/G,WAAL,CAAiBsJ,GAAjB,CAAhB;AACA,UAAI,CAACvC,SAAL,EAAgB;AAChB,UAAID,KAAK,GAAG7F,MAAM,CAACqI,GAAD,CAAlB;;AACA,UAAImI,aAAa,GAAG,KAAKD,uBAAL,CAA6B1K,KAAK,CAAC+K,QAAnC,CAApB;;AACA,UAAIA,QAAQ,GAAG9T,KAAK,CAAC,EAAD,EAAKgU,eAAL,EAAsBN,aAAtB,CAApB;;AACA,UAAIO,oBAAoB,GAAG,KAAKC,6BAAL,CAAmCJ,QAAnC,CAA3B;;AACA9K,MAAAA,SAAS,CAACQ,YAAV,CAAuB,WAAvB,EAAoC1J,CAAC,CAACqU,uBAAF,CAA0BF,oBAA1B,CAApC;;AACA,WAAKG,mBAAL,CAAyB7I,GAAzB;AACH;;AAED,WAAO,IAAP;AACH,GAp9BmC;AAs9BpC6I,EAAAA,mBAAmB,EAAE,UAASC,KAAT,EAAgB;AACjC;AACA;AACA;AACA,UAAM;AAAE/R,MAAAA,OAAF;AAAWJ,MAAAA;AAAX,QAA+B,IAArC;AACA,UAAM4E,SAAS,GAAG5E,eAAe,CAACmS,KAAD,CAAjC;AACA,QAAI,CAACvN,SAAL,EAAgB;;AAChB,SAAK,IAAI4C,QAAT,IAAqB5C,SAArB,EAAgC;AAC5B,YAAM;AAAEwN,QAAAA;AAAF,UAASxN,SAAS,CAAC4C,QAAD,CAAxB;AACA,UAAI4K,EAAE,IAAKA,EAAE,IAAIhS,OAAjB,EAA2B,OAAOA,OAAO,CAACgS,EAAD,CAAP,CAAYC,YAAnB;AAC9B;AACJ,GAj+BmC;AAm+BpCvP,EAAAA,mBAAmB,EAAE,YAAW;AAE5B,QAAI,CAAC,KAAK5C,EAAL,CAAQsI,SAAb,EAAwB,OAAO,IAAP,CAFI,CAI5B;AACA;AACA;AACA;;AAEA,QAAIgF,KAAK,GAAG,EAAZ;AACA,QAAI8D,MAAM,GAAG,KAAK9R,OAAL,CAAaI,eAA1B;AACA,QAAI0S,gBAAgB,GAAG,KAAKC,mBAAL,EAAvB,CAX4B,CAa5B;AACA;;AACA,QAAI,CAACC,MAAM,CAACC,KAAP,CAAaH,gBAAb,CAAL,EAAqC;AAEjC;AACA,UAAIA,gBAAgB,GAAG,KAAK9S,OAAL,CAAaC,eAApC,EAAqD;AACjD+N,QAAAA,KAAK,GAAG,WAAR;AACA8D,QAAAA,MAAM,IAAI,CAAV;AACH;;AAED,UAAIoB,YAAY,GAAG,KAAKC,gBAAL,CAAsBrB,MAAtB,CAAnB;;AAEA,WAAK1I,UAAL,CAAgBxD,IAAhB,CAAqB,WAArB,EAAkC,eAAesN,YAAY,CAACE,CAA5B,GAAgC,IAAhC,GAAuCF,YAAY,CAACG,CAApD,GAAwD,IAAxD,GAA+DrF,KAAjG;;AAEA,UAAI,KAAKhO,OAAL,CAAaE,eAAb,IAAgC4S,gBAAgB,IAAI,KAAK9S,OAAL,CAAaG,cAArE,EAAqF;AAEjF,YAAIE,qBAAqB,GAAG,KAAKL,OAAL,CAAaK,qBAAb,IAAsCyR,MAAlE;AAEAoB,QAAAA,YAAY,GAAG,KAAKC,gBAAL,CAAsBL,gBAAgB,GAAGzS,qBAAzC,CAAf;;AACA,aAAKkJ,WAAL,CAAiB3D,IAAjB,CAAsB,WAAtB,EAAmC,eAAesN,YAAY,CAACE,CAA5B,GAAgC,IAAhC,GAAuCF,YAAY,CAACG,CAApD,GAAwD,IAAxD,GAA+DrF,KAAlG;;AACA,aAAKzE,WAAL,CAAiB3D,IAAjB,CAAsB,YAAtB,EAAoC,SAApC;AAEH,OARD,MAQO,IAAI,KAAK5F,OAAL,CAAaE,eAAjB,EAAkC;AAErC,aAAKqJ,WAAL,CAAiB3D,IAAjB,CAAsB,YAAtB,EAAoC,QAApC;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GA7gCmC;AA+gCpC2E,EAAAA,sBAAsB,EAAE,YAAW;AAE/B,QAAI,CAAC,KAAK7J,EAAL,CAAQoJ,gBAAb,EAA+B,OAAO,IAAP,CAFA,CAI/B;;AACA,QAAIxK,CAAC,CAACgU,GAAF,CAAM,KAAK5S,EAAL,CAAQoJ,gBAAR,CAAyBzD,IAA/B,EAAqC,SAArC,MAAoD,MAAxD,EAAgE,OAAO,IAAP;AAEhE,QAAI4H,EAAE,GAAG,KAAK8E,mBAAL,KAA6B,KAAK/S,OAAL,CAAaC,eAA1C,GAA4D,EAA5D,GAAiE,CAA1E;;AACA,SAAKS,EAAL,CAAQuJ,eAAR,CAAwB+D,KAAxB,CAA8BC,EAA9B;;AACA,SAAKvN,EAAL,CAAQyJ,eAAR,CAAwB6D,KAAxB,CAA8BC,EAA9B;;AAEA,SAAKnC,6BAAL,CAAmC,KAAKpL,EAAL,CAAQuJ,eAA3C,EAA4D,KAAKvJ,EAAL,CAAQyJ,eAApE;;AAEA,WAAO,IAAP;AACH,GA7hCmC;AA+hCpC/H,EAAAA,mBAAmB,EAAE,UAASsO,OAAT,EAAkB;AAEnC,UAAM;AAAE5N,MAAAA,KAAF;AAASR,MAAAA;AAAT,QAAmB,IAAzB;AACA,UAAMiR,eAAe,GAAI,GAAE7C,OAAQ,MAAnC;AACA,UAAM8C,MAAM,GAAG1Q,KAAK,CAAC6B,GAAN,CAAU+L,OAAV,CAAf;AACA,UAAM+C,KAAK,GAAGD,MAAM,IAAIA,MAAM,CAACZ,EAA/B;;AAEA,QAAI,CAACa,KAAL,EAAY;AACR;AACA,WAAKF,eAAL,IAAwB,IAAxB;AACA,WAAKG,eAAL,CAAqBhD,OAArB;AACA,aAAO,IAAP;AACH;;AAED,UAAMiD,QAAQ,GAAGrR,KAAK,CAACsR,YAAN,CAAmBH,KAAnB,CAAjB;AACA,QAAI,CAACE,QAAL,EAAe,MAAM,IAAI/O,KAAJ,CAAU,uBAAuB8L,OAAvB,GAAiC,QAA3C,CAAN;AAEf,UAAMmD,OAAO,GAAGF,QAAQ,CAACG,QAAT,CAAkBxR,KAAlB,CAAhB;;AACA,QAAI,CAACuR,OAAL,EAAc;AACV;AACA,aAAO,KAAP;AACH;;AAED,SAAKN,eAAL,IAAwBM,OAAxB;AACA,SAAKH,eAAL,CAAqBhD,OAArB;AACA,WAAO,IAAP;AACH,GAzjCmC;AA2jCpCgD,EAAAA,eAAe,EAAE,UAAShD,OAAT,EAAkB;AAE/B,UAAMqD,iBAAiB,GAAI,GAAErD,OAAQ,QAArC;AACA,UAAMmD,OAAO,GAAG,KAAK9H,UAAL,CAAgB2E,OAAhB,CAAhB;;AACA,QAAImD,OAAJ,EAAa;AACT,UAAIG,eAAe,GAAGH,OAAO,CAACI,oBAAR,CAA6B,KAAKnR,KAAL,CAAW6B,GAAX,CAAe+L,OAAf,CAA7B,CAAtB;AACA,UAAIsD,eAAe,KAAKH,OAAO,CAAC1O,EAAhC,EAAoC6O,eAAe,GAAG,IAAlB;AACpC,WAAKD,iBAAL,IAA0BC,eAA1B;AACH,KAJD,MAIO;AACH,WAAKD,iBAAL,IAA0B,IAA1B;AACH;AACJ,GAtkCmC;AAwkCpCjI,EAAAA,6BAA6B,EAAE,UAASoI,WAAT,EAAsBC,WAAtB,EAAmC;AAE9D;AACA;AACA,QAAI3H,KAAK,GAAG/N,OAAO,CAAC,KAAK+N,KAAN,CAAnB;;AACA,QAAI0H,WAAJ,EAAiB;AACbA,MAAAA,WAAW,CAACE,sBAAZ,CACI,KAAKjI,WADT,EAEIK,KAAK,CAAC,CAAD,CAAL,IAAY,KAAKJ,WAFrB,EAGI,KAAK9J,KAAL,CAAW+R,KAHf;AAKH;;AAED,QAAIF,WAAJ,EAAiB;AACbA,MAAAA,WAAW,CAACC,sBAAZ,CACI,KAAKhI,WADT,EAEII,KAAK,CAACA,KAAK,CAACxI,MAAN,GAAe,CAAhB,CAAL,IAA2B,KAAKmI,WAFpC,EAGI,KAAK7J,KAAL,CAAW+R,KAHf;AAKH;AACJ,GA5lCmC;AA8lCpCC,EAAAA,sBAAsB,EAAE,UAASzK,GAAT,EAAc;AAElC,QAAImI,aAAa,GAAG,KAAKlP,KAAL,CAAWuE,KAAX,CAAiBwC,GAAjB,EAAsBuI,QAAtB,IAAkC,EAAtD;AACA,WAAQJ,aAAa,CAACE,KAAd,IAAuB,CAA/B;AACH,GAlmCmC;AAomCpCqC,EAAAA,qBAAqB,EAAE,UAAS1K,GAAT,EAAc;AAEjC,QAAImI,aAAa,GAAG,KAAKlP,KAAL,CAAWuE,KAAX,CAAiBwC,GAAjB,EAAsBuI,QAAtB,IAAkC,EAAtD;AACA,WAAOJ,aAAa,CAACZ,IAArB;AACH,GAxmCmC;AA0mCpCoD,EAAAA,4BAA4B,EAAE,YAAW;AAErC,QAAI/M,YAAY,GAAG,KAAK3E,KAAL,CAAW6E,gBAAX,EAAnB;;AACA,QAAI0K,oBAAoB,GAAG5K,YAAY,CAAC2K,QAAb,IAAyB,EAApD;AACA,WAAOC,oBAAoB,CAACjB,IAA5B;AACH,GA/mCmC;AAinCpC;AACA;AACAqD,EAAAA,uBAAuB,EAAE,UAASC,iBAAT,EAA4BC,wBAA5B,EAAsD;AAE3E,QAAID,iBAAiB,KAAK,IAA1B,EAAgC,OAAO,IAAP;;AAChC,QAAIA,iBAAiB,KAAK1O,SAA1B,EAAqC;AAEjC,UAAI2O,wBAAwB,KAAK,IAAjC,EAAuC,OAAO,IAAP;AACvC,aAAOA,wBAAP;AACH;;AAED,WAAOrW,KAAK,CAAC,EAAD,EAAKqW,wBAAL,EAA+BD,iBAA/B,CAAZ;AACH,GA7nCmC;AA+nCpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,EAAAA,QAAQ,EAAE,UAASC,EAAT,EAAaC,EAAb,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyB;AAE/B;AACA,QAAIC,MAAJ;AACA,QAAIC,MAAJ;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,QAAJ;;AACA,QAAI,OAAOP,EAAP,KAAc,QAAlB,EAA4B;AACxB;AACAI,MAAAA,MAAM,GAAGJ,EAAE,CAACzB,CAAZ;AACA8B,MAAAA,MAAM,GAAGL,EAAE,CAACxB,CAAZ;;AACA,UAAI,OAAOyB,EAAP,KAAc,QAAlB,EAA4B;AACxB;AACAK,QAAAA,UAAU,GAAGL,EAAb;AACAM,QAAAA,QAAQ,GAAGL,EAAX;AACH,OAJD,MAIO;AACH;AACAK,QAAAA,QAAQ,GAAGN,EAAX;AACH;AACJ,KAZD,MAYO;AACH;AACAG,MAAAA,MAAM,GAAGJ,EAAT;AACAK,MAAAA,MAAM,GAAGJ,EAAT;;AACA,UAAI,OAAOC,EAAP,KAAc,QAAlB,EAA4B;AACxB;AACAI,QAAAA,UAAU,GAAGJ,EAAb;AACAK,QAAAA,QAAQ,GAAGJ,EAAX;AACH,OAJD,MAIO;AACH;AACAI,QAAAA,QAAQ,GAAGL,EAAX;AACH;AACJ,KA/B8B,CAiC/B;;;AACA,QAAIJ,wBAAwB,GAAG,KAAKH,4BAAL,EAA/B;;AACA,QAAIE,iBAAiB,GAAGU,QAAxB;;AACA,QAAIC,YAAY,GAAG,KAAKZ,uBAAL,CAA6BC,iBAA7B,EAAgDC,wBAAhD,CAAnB,CApC+B,CAsC/B;;;AACA,QAAItN,KAAK,GAAG;AAAE+K,MAAAA,QAAQ,EAAE,KAAKkD,gBAAL,CAAsBL,MAAtB,EAA8BC,MAA9B,EAAsCC,UAAtC,EAAkDE,YAAlD;AAAZ,KAAZ;AACA,QAAIxL,GAAG,GAAG,CAAC,CAAX;AACA,SAAK/G,KAAL,CAAWyS,WAAX,CAAuB1L,GAAvB,EAA4BxC,KAA5B,EAAmC+N,QAAnC;AACA,WAAOvL,GAAP;AACH,GAvrCmC;AAyrCpC;AACA2L,EAAAA,SAAS,EAAE,UAASpC,CAAT,EAAYC,CAAZ,EAAenR,GAAf,EAAoB;AAE3B;AACA,QAAIuT,eAAe,GAAI,OAAOrC,CAAP,KAAa,QAApC;AACA,QAAI6B,MAAM,GAAGQ,eAAe,GAAGrC,CAAC,CAACA,CAAL,GAASA,CAArC;AACA,QAAI8B,MAAM,GAAGO,eAAe,GAAGrC,CAAC,CAACC,CAAL,GAASA,CAArC;AACA,QAAI+B,QAAQ,GAAGK,eAAe,GAAGpC,CAAH,GAAOnR,GAArC;AAEA,QAAI0H,MAAM,GAAG;AAAEwJ,MAAAA,CAAC,EAAE6B,MAAL;AAAa5B,MAAAA,CAAC,EAAE6B;AAAhB,KAAb;AACA,QAAIrL,GAAG,GAAG,KAAK6L,cAAL,CAAoBT,MAApB,EAA4BC,MAA5B,CAAV;AACA,SAAKpS,KAAL,CAAW6S,YAAX,CAAwB9L,GAAxB,EAA6BD,MAA7B,EAAqCwL,QAArC;AACA,WAAOvL,GAAP;AACH,GAtsCmC;AAwsCpC;AACA;AACA;AACA;AACA;AACA;AACA+L,EAAAA,SAAS,EAAE,UAASC,KAAT,EAAgB3T,GAAhB,EAAqB4T,QAArB,EAA+B;AAEtC,aAASC,cAAT,CAAwBC,MAAxB,EAAgCF,QAAhC,EAA0C;AACtC,aAAO,YAAW;AACdE,QAAAA,MAAM,CAAC7O,MAAP;;AACA,YAAI,OAAO2O,QAAP,KAAoB,UAAxB,EAAoC;AAChCA,UAAAA,QAAQ;AACX;AACJ,OALD;AAMH;;AAED,QAAIG,QAAJ,EAAcC,UAAd,EAA0BlO,QAA1B;;AACA,QAAItJ,QAAQ,CAACwD,GAAD,CAAZ,EAAmB;AACf+T,MAAAA,QAAQ,GAAG/T,GAAG,CAAC+T,QAAf;AACAC,MAAAA,UAAU,GAAIhU,GAAG,CAACiU,SAAJ,KAAkB,SAAhC;AACAnO,MAAAA,QAAQ,GAAG9F,GAAG,CAACuJ,UAAf;AACH,KAJD,MAIO;AACH;AACAwK,MAAAA,QAAQ,GAAG/T,GAAX;AACAgU,MAAAA,UAAU,GAAG,KAAb;AACAlO,MAAAA,QAAQ,GAAG,IAAX;AACH;;AAEDiO,IAAAA,QAAQ,GAAGA,QAAQ,IAAI,IAAvB;AAEA,QAAIG,mBAAmB,GAAG;AACtBC,MAAAA,GAAG,EAAEJ,QAAQ,GAAG,IADM;AAEtBK,MAAAA,WAAW,EAAE,CAFS;AAGtBC,MAAAA,QAAQ,EAAE,QAHY;AAItBC,MAAAA,IAAI,EAAE;AAJgB,KAA1B;;AAOA,QAAIN,UAAJ,EAAgB;AACZE,MAAAA,mBAAmB,CAACK,SAApB,GAAgC,KAAhC;AACAL,MAAAA,mBAAmB,CAACM,QAApB,GAA+B,KAA/B;AACH;;AAED,QAAIV,MAAM,GAAG5X,CAAC,CAACyX,KAAD,CAAd;AACA,QAAIpK,UAAJ;;AACA,QAAI,OAAOzD,QAAP,KAAoB,QAAxB,EAAkC;AAC9B;AACAyD,MAAAA,UAAU,GAAG,KAAKpD,cAAL,CAAoBL,QAApB,EAA8B,KAAK7C,EAAnC,EAAuC,KAAKC,SAA5C,EAAuD,CAAvD,CAAb;AACH,KAHD,MAGO;AACH;AACA,UAAII,KAAK,GAAG,KAAK9E,EAAjB;AACA+K,MAAAA,UAAU,GAAIjG,KAAK,CAACiG,UAAP,GAAqBjG,KAAK,CAACiG,UAAN,CAAiBpF,IAAtC,GAA6C,KAAKlB,EAAL,CAAQwR,aAAR,CAAsB,MAAtB,CAA1D;AACH;;AAED,QAAI,EAAElL,UAAU,YAAYmL,cAAxB,CAAJ,EAA6C;AACzC,YAAM,IAAIhS,KAAJ,CAAU,iEAAV,CAAN;AACH;;AAEDoR,IAAAA,MAAM,CACDa,QADL,CACc,KAAKvU,KAAL,CAAW+R,KADzB,EAEKyC,gBAFL,CAEsBV,mBAFtB,EAE2C3K,UAF3C;AAIAsL,IAAAA,UAAU,CAAChB,cAAc,CAACC,MAAD,EAASF,QAAT,CAAf,EAAmCG,QAAnC,CAAV;AACH,GAvwCmC;AAywCpC/I,EAAAA,SAAS,EAAE,UAASxL,QAAT,EAAmB;AAE1BA,IAAAA,QAAQ,KAAKA,QAAQ,GAAG,EAAhB,CAAR;AAEA,QAAIsV,SAAS,GAAG5X,OAAhB;AACA,QAAI+B,MAAM,GAAG,KAAK2B,KAAL,CAAW3B,MAAX,EAAb;AACA,QAAI8V,aAAa,GAAG,KAAK3U,KAAL,CAAWtC,OAAX,CAAmBiX,aAAvC;;AAEA,QAAI,CAAC9V,MAAL,EAAa;AACT,UAAI8V,aAAJ,EAAmB9V,MAAM,GAAG8V,aAAT,CAAnB,KACK,OAAOvV,QAAQ,CAAC0J,GAAT,CAAatM,KAAb,CAAP,CAFI,CAEwB;AACpC;;AAED,QAAIoY,QAAQ,GAAGvY,UAAU,CAACwC,MAAD,CAAV,GAAqBA,MAArB,GAA8B6V,SAAS,CAAC7V,MAAM,CAAC2P,IAAR,CAAtD;;AACA,QAAI,CAACnS,UAAU,CAACuY,QAAD,CAAf,EAA2B;AACvB,YAAM,IAAItS,KAAJ,CAAU,oCAAoCzD,MAAM,CAAC2P,IAA3C,GAAkD,IAA5D,CAAN;AACH;;AAED,QAAIM,IAAI,GAAGjQ,MAAM,CAACiQ,IAAP,IAAe,EAA1B;AAEA,QAAI5E,KAAK,GAAG0K,QAAQ,CAAC/F,IAAT,CACR,IADQ,EACF;AACNzP,IAAAA,QAFQ,EAEE;AACV0P,IAAAA,IAHQ,EAGF;AACN,QAJQ,CAIH;AAJG,KAAZ;AAOA,QAAI,CAAC5E,KAAL,EAAY,OAAO9K,QAAQ,CAAC0J,GAAT,CAAatM,KAAb,CAAP;AACZ,WAAO0N,KAAP;AACH,GAtyCmC;AAwyCpC;AACA;AACAe,EAAAA,QAAQ,EAAE,UAASf,KAAT,EAAgBL,WAAhB,EAA6BC,WAA7B,EAA0C;AAEhD,QAAI4K,SAAS,GAAG3X,UAAhB;AACA,QAAI+B,SAAS,GAAG,KAAK0B,KAAL,CAAW1B,SAAX,EAAhB;AACA,QAAI+V,gBAAgB,GAAG,KAAK7U,KAAL,CAAWtC,OAAX,CAAmBmX,gBAA1C;;AAEA,QAAI,CAAC/V,SAAL,EAAgB;AACZA,MAAAA,SAAS,GAAG+V,gBAAgB,IAAI,EAAhC;AACH;;AAED,QAAIC,WAAW,GAAGzY,UAAU,CAACyC,SAAD,CAAV,GAAwBA,SAAxB,GAAoC4V,SAAS,CAAC5V,SAAS,CAAC0P,IAAX,CAA/D;;AACA,QAAI,CAACnS,UAAU,CAACyY,WAAD,CAAf,EAA8B;AAC1B,YAAM,IAAIxS,KAAJ,CAAU,uCAAuCxD,SAAS,CAAC0P,IAAjD,GAAwD,IAAlE,CAAN;AACH;;AAED,QAAIM,IAAI,GAAGxS,KAAK,CAACwC,SAAS,CAACgQ,IAAV,IAAkB,EAAnB,CAAhB;AACAA,IAAAA,IAAI,CAACiG,GAAL,GAAW,IAAX,CAhBgD,CAgB/B;;AAEjB,QAAI5K,IAAI,GAAG2K,WAAW,CAACjG,IAAZ,CACP,IADO,EACD;AACNhF,IAAAA,WAFO,EAEM;AACbC,IAAAA,WAHO,EAGM;AACbI,IAAAA,KAJO,EAIA;AACP4E,IAAAA,IALO,EAKD;AACN,QANO,CAMF;AANE,KAAX;;AASA,QAAI,OAAO3E,IAAP,KAAgB,QAApB,EAA8B;AAC1B;AACAA,MAAAA,IAAI,GAAG,IAAIzN,IAAJ,CAASZ,CAAC,CAACkZ,iBAAF,CAAoB7K,IAApB,CAAT,CAAP;AACH;;AAED,WAAOA,IAAP;AACH,GA30CmC;AA60CpC;AACA;AAEA8K,EAAAA,aAAa,EAAE,YAAW;AAEtB,QAAI9K,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAAC7N,KAAL,EAAP;AACH,GAt1CmC;AAw1CpC8M,EAAAA,uBAAuB,EAAE,YAAW;AAEhC,QAAIe,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,QAAI7L,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIA,OAAO,CAAC4W,cAAR,CAAuB,MAAvB,CAAJ,EAAoC,OAAO5W,OAAO,CAAC6W,IAAf;AACpC,QAAIA,IAAI,GAAGhL,IAAI,CAACiL,SAAL,EAAX;AACA9W,IAAAA,OAAO,CAAC6W,IAAR,GAAeA,IAAf;AACA,WAAOA,IAAP;AACH,GAl2CmC;AAo2CpCE,EAAAA,yBAAyB,EAAE,YAAW;AAElC,QAAIlL,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,QAAI7L,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIA,OAAO,CAAC4W,cAAR,CAAuB,qBAAvB,CAAJ,EAAmD,OAAO5W,OAAO,CAACgX,mBAAf;AACnD,QAAIC,YAAY,GAAGpL,IAAI,CAACqL,sBAAL,EAAnB;AACAlX,IAAAA,OAAO,CAACgX,mBAAR,GAA8BC,YAA9B;AACA,WAAOA,YAAP;AACH,GA92CmC;AAg3CpC9E,EAAAA,mBAAmB,EAAE,YAAW;AAE5B,QAAItG,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,CAAP;AAEX,QAAI7L,OAAO,GAAG,KAAKA,OAAnB;AACA,QAAIA,OAAO,CAAC4W,cAAR,CAAuB,QAAvB,CAAJ,EAAsC,OAAO5W,OAAO,CAACoD,MAAf;AACtC,QAAIA,MAAM,GAAGyI,IAAI,CAACzI,MAAL,CAAY;AAAE4T,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAZ,CAAb;AACA/W,IAAAA,OAAO,CAACoD,MAAR,GAAiBA,MAAjB;AACA,WAAOA,MAAP;AACH,GA13CmC;AA43CpCmP,EAAAA,gBAAgB,EAAE,UAASnP,MAAT,EAAiB;AAE/B,QAAIyI,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAACsL,aAAL,CAAmB/T,MAAnB,EAA2B;AAAE4T,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAA3B,CAAP;AACH,GAl4CmC;AAo4CpCK,EAAAA,eAAe,EAAE,UAASC,KAAT,EAAgB;AAE7B,QAAIxL,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AACX,QAAI5N,YAAY,CAACoZ,KAAD,CAAhB,EAAyBA,KAAK,GAAGC,UAAU,CAACD,KAAD,CAAV,GAAoB,GAA5B;AACzB,WAAOxL,IAAI,CAAC0L,OAAL,CAAaF,KAAb,EAAoB;AAAEL,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAApB,CAAP;AACH,GA14CmC;AA44CpCS,EAAAA,kBAAkB,EAAE,UAASpU,MAAT,EAAiB;AAEjC,QAAIyI,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAAC4L,eAAL,CAAqBrU,MAArB,EAA6B;AAAE4T,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAA7B,CAAP;AACH,GAl5CmC;AAo5CpCW,EAAAA,iBAAiB,EAAE,UAASL,KAAT,EAAgB;AAE/B,QAAIxL,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAAC8L,SAAL,CAAeN,KAAf,EAAsB;AAAEL,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAtB,CAAP;AACH,GA15CmC;AA45CpCa,EAAAA,eAAe,EAAE,UAASnN,KAAT,EAAgB;AAE7B,QAAIoB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAACgM,YAAL,CAAkBpN,KAAlB,EAAyB;AAAEuM,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAzB,CAAP;AACH,GAl6CmC;AAo6CpCe,EAAAA,qBAAqB,EAAE,UAASrN,KAAT,EAAgB;AAEnC,QAAIoB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAACkM,kBAAL,CAAwBtN,KAAxB,EAA+B;AAAEuM,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAA/B,CAAP;AACH,GA16CmC;AA46CpCiB,EAAAA,oBAAoB,EAAE,UAASvN,KAAT,EAAgB;AAElC,QAAIoB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AAEX,WAAOA,IAAI,CAACoM,4BAAL,CAAkCxN,KAAlC,EAAyC;AAAEuM,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAzC,CAAP;AACH,GAl7CmC;AAo7CpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArC,EAAAA,gBAAgB,EAAE,UAASlC,CAAT,EAAYC,CAAZ,EAAe0B,EAAf,EAAmBC,EAAnB,EAAuB;AAErC,QAAI5C,QAAQ,GAAG,EAAf,CAFqC,CAIrC;;AACA,QAAI+C,UAAU,GAAG,CAAjB;AACA,QAAIC,QAAJ;;AACA,QAAI,OAAOL,EAAP,KAAc,QAAlB,EAA4B;AACxB;AACAI,MAAAA,UAAU,GAAGJ,EAAb;AACAK,MAAAA,QAAQ,GAAGJ,EAAX;AACH,KAJD,MAIO;AACH;AACAI,MAAAA,QAAQ,GAAGL,EAAX;AACH,KAdoC,CAgBrC;;;AACA,QAAIK,QAAJ,EAAchD,QAAQ,CAAChB,IAAT,GAAgBgE,QAAhB,CAjBuB,CAmBrC;;AACA,QAAI0D,kBAAkB,GAAG,EAAE1D,QAAQ,IAAIA,QAAQ,CAAC2D,gBAAvB,CAAzB,CApBqC,CAoB8B;;AACnE,QAAIC,yBAAyB,GAAI5D,QAAQ,IAAIA,QAAQ,CAAC2D,gBAArB,IAAyC3D,QAAQ,CAAC6D,eAAnF,CArBqC,CAqBgE;;AACrG,QAAIC,gBAAgB,GAAG9D,QAAQ,IAAIA,QAAQ,CAAC+D,cAA5C,CAtBqC,CAsBuB;AAE5D;;AACA,QAAI1M,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI2M,OAAO,GAAG;AAAExB,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAd;AACA,QAAI0B,UAAU,GAAG,IAAIva,KAAJ,CAAUsU,CAAV,EAAaC,CAAb,CAAjB;AACA,QAAIiG,CAAC,GAAG7M,IAAI,CAAC8M,aAAL,CAAmBF,UAAnB,EAA+BD,OAA/B,CAAR,CA5BqC,CA8BrC;;AACA,QAAII,aAAa,GAAG/M,IAAI,CAACgN,SAAL,CAAeH,CAAf,EAAkBF,OAAlB,CAApB;AACA,QAAIN,kBAAJ,EAAwBU,aAAa,GAAIA,aAAa,GAAG,KAAKzG,mBAAL,EAAjB,IAAgD,CAAhE,CAhCa,CAgCsD;;AAC3F,QAAIiG,yBAAJ,EAA+BQ,aAAa,GAAI,CAAC,CAAD,IAAM,KAAKzG,mBAAL,KAA6ByG,aAAnC,CAAD,IAAuD,CAAvE,CAjCM,CAiCoE;;AACzGpH,IAAAA,QAAQ,CAACH,QAAT,GAAoBuH,aAApB,CAlCqC,CAoCrC;AACA;AACA;AACA;;AACA,QAAIE,OAAJ;AACA,QAAI,CAACR,gBAAL,EAAuBQ,OAAO,GAAGjN,IAAI,CAACkN,UAAL,CAAgBL,CAAhB,CAAV;AACvB,QAAIM,WAAJ;;AACA,QAAIF,OAAJ,EAAa;AACTE,MAAAA,WAAW,GAAGF,OAAO,CAACG,WAAR,CAAoBR,UAApB,CAAd;AACH,KAFD,MAEO;AACH,UAAIZ,YAAY,GAAGhM,IAAI,CAACqN,QAAL,CAAcR,CAAd,CAAnB;AACA,UAAIS,eAAe,GAAGV,UAAU,CAACW,UAAX,CAAsBvB,YAAtB,CAAtB;AACAmB,MAAAA,WAAW,GAAG;AAAExG,QAAAA,CAAC,EAAE2G,eAAe,CAAC3G,CAArB;AAAwBC,QAAAA,CAAC,EAAE0G,eAAe,CAAC1G;AAA3C,OAAd;AACH;;AACDjB,IAAAA,QAAQ,CAACN,MAAT,GAAkB8H,WAAlB,CAlDqC,CAoDrC;;AACAxH,IAAAA,QAAQ,CAACF,KAAT,GAAiBiD,UAAjB;AAEA,WAAO/C,QAAP;AACH,GAp/CmC;AAs/CpCI,EAAAA,6BAA6B,EAAE,UAASR,aAAT,EAAwB;AAEnD,QAAIwH,aAAJ;AACA,QAAIS,UAAU,GAAG,CAAjB;AACA,QAAI7I,IAAI,GAAG,EAAX;;AACA,QAAI,OAAOY,aAAP,KAAyB,QAA7B,EAAuC;AACnCwH,MAAAA,aAAa,GAAGxH,aAAhB;AACH,KAFD,MAEO,IAAI,OAAOA,aAAa,CAACC,QAArB,KAAkC,QAAtC,EAAgD;AACnDb,MAAAA,IAAI,GAAGY,aAAa,CAACZ,IAAd,IAAsB,EAA7B;AACAoI,MAAAA,aAAa,GAAGxH,aAAa,CAACC,QAA9B;AACAgI,MAAAA,UAAU,GAAGjI,aAAa,CAACE,KAAd,IAAuB,CAApC;AACH,KAJM,MAIA;AACH,YAAM,IAAItN,KAAJ,CAAU,gDAAV,CAAN;AACH;;AAED,QAAIkU,kBAAkB,GAAKU,aAAa,GAAG,CAAjB,IAAwBA,aAAa,IAAI,CAAnE;AAEA,QAAII,WAAW,GAAG,CAAlB;AACA,QAAIM,sBAAsB,GAAG;AAAE9G,MAAAA,CAAC,EAAE,CAAL;AAAQC,MAAAA,CAAC,EAAE;AAAX,KAA7B;;AACA,QAAIrB,aAAa,CAACF,MAAlB,EAA0B;AACtB,UAAIqI,cAAc,GAAGnI,aAAa,CAACF,MAAnC;AACA,UAAI,OAAOqI,cAAP,KAA0B,QAA9B,EAAwCP,WAAW,GAAGO,cAAd;AACxC,UAAIA,cAAc,CAAC/G,CAAnB,EAAsB8G,sBAAsB,CAAC9G,CAAvB,GAA2B+G,cAAc,CAAC/G,CAA1C;AACtB,UAAI+G,cAAc,CAAC9G,CAAnB,EAAsB6G,sBAAsB,CAAC7G,CAAvB,GAA2B8G,cAAc,CAAC9G,CAA1C;AACzB;;AAED,QAAI6F,gBAAgB,GAAKgB,sBAAsB,CAAC9G,CAAvB,KAA6B,CAA9B,IAAqC8G,sBAAsB,CAAC7G,CAAvB,KAA6B,CAAlE,IAAwEuG,WAAW,KAAK,CAAhH;AAEA,QAAIQ,cAAc,GAAGhJ,IAAI,CAACiJ,YAA1B;AACA,QAAIC,kBAAkB,GAAGlJ,IAAI,CAACmJ,gBAA9B;AAEA,QAAI9N,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI2M,OAAO,GAAG;AAAExB,MAAAA,mBAAmB,EAAE,KAAKD,yBAAL;AAAvB,KAAd;AAEA,QAAI1F,QAAQ,GAAG6G,kBAAkB,GAAIU,aAAa,GAAG,KAAKzG,mBAAL,EAApB,GAAkDyG,aAAnF;AACA,QAAIE,OAAO,GAAGjN,IAAI,CAAC4L,eAAL,CAAqBpG,QAArB,EAA+BmH,OAA/B,CAAd;AAEA,QAAIoB,WAAJ;AACA,QAAItI,KAAK,GAAG+H,UAAZ;;AACA,QAAIP,OAAJ,EAAa;AACT,UAAIR,gBAAJ,EAAsB;AAClBsB,QAAAA,WAAW,GAAGd,OAAO,CAAChI,KAAtB;AACA8I,QAAAA,WAAW,CAAC1I,MAAZ,CAAmBoI,sBAAnB;AACH,OAHD,MAGO;AACH,YAAIO,MAAM,GAAGf,OAAO,CAAC9a,KAAR,EAAb;AACA6b,QAAAA,MAAM,CAACC,MAAP,CAAchB,OAAO,CAAChI,KAAtB,EAA6B,CAAC,EAA9B;AACA+I,QAAAA,MAAM,CAACE,SAAP,CAAiBf,WAAjB;AACAY,QAAAA,WAAW,GAAGC,MAAM,CAACvQ,GAArB;AACH;;AACD,UAAIkQ,cAAJ,EAAoB;AAChBlI,QAAAA,KAAK,GAAIwH,OAAO,CAACxH,KAAR,KAAkB+H,UAA3B;;AACA,YAAIK,kBAAJ,EAAwB;AACpBpI,UAAAA,KAAK,GAAGjT,cAAc,CAAE,CAACiT,KAAK,GAAG,EAAT,IAAe,GAAhB,GAAuB,EAAxB,CAAtB;AACH;AACJ;AACJ,KAhBD,MAgBO;AACH;AACAsI,MAAAA,WAAW,GAAG/N,IAAI,CAACiF,KAAnB;AACA,UAAIwH,gBAAJ,EAAsBsB,WAAW,CAAC1I,MAAZ,CAAmBoI,sBAAnB;AACzB;;AAED,WAAO9b,CAAC,CAACwc,eAAF,GACF9N,SADE,CACQ0N,WAAW,CAACpH,CADpB,EACuBoH,WAAW,CAACnH,CADnC,EAEFqH,MAFE,CAEKxI,KAFL,CAAP;AAGH,GAtjDmC;AAwjDpC2I,EAAAA,mBAAmB,EAAE,UAAS7I,aAAT,EAAwB;AAEzC,QAAIO,oBAAoB,GAAG,KAAKC,6BAAL,CAAmCR,aAAnC,CAA3B;;AACA,WAAO,IAAIlT,KAAJ,CAAUyT,oBAAoB,CAACuI,CAA/B,EAAkCvI,oBAAoB,CAACwI,CAAvD,CAAP;AACH,GA5jDmC;AA8jDpCrF,EAAAA,cAAc,EAAE,UAAStC,CAAT,EAAYC,CAAZ,EAAe;AAE3B,QAAIvQ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIpB,QAAQ,GAAGoB,KAAK,CAACpB,QAAN,EAAf;AAEA,QAAIsZ,YAAY,GAAG,KAAKtC,qBAAL,CAA2B,IAAI5Z,KAAJ,CAAUsU,CAAV,EAAaC,CAAb,CAA3B,CAAnB;AAEA,QAAIxJ,GAAG,GAAG,CAAV;;AACA,SAAK,IAAInE,CAAC,GAAGhE,QAAQ,CAACsC,MAAtB,EAA8B6F,GAAG,GAAGnE,CAApC,EAAuCmE,GAAG,EAA1C,EAA8C;AAC1C,UAAIoR,aAAa,GAAGvZ,QAAQ,CAACmI,GAAD,CAA5B;AACA,UAAIqR,mBAAmB,GAAG,KAAKxC,qBAAL,CAA2BuC,aAA3B,CAA1B;AACA,UAAID,YAAY,GAAGE,mBAAnB,EAAwC;AAC3C;;AAED,WAAOrR,GAAP;AACH,GA7kDmC;;AA+kDpC;AACA;AAEAsR,EAAAA,iBAAiB,CAACC,GAAD,EAAMhI,CAAN,EAASC,CAAT,EAAY;AACzBnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmB0b,WAAnB,CAA+BlK,IAA/B,CAAoC,IAApC,EAA0CiK,GAA1C,EAA+ChI,CAA/C,EAAkDC,CAAlD;AACA,SAAKiI,MAAL,CAAY,kBAAZ,EAAgCF,GAAhC,EAAqChI,CAArC,EAAwCC,CAAxC;AACH,GArlDmC;;AAulDpCkI,EAAAA,iBAAiB,CAACH,GAAD,EAAMhI,CAAN,EAASC,CAAT,EAAY;AACzBnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmB6b,WAAnB,CAA+BrK,IAA/B,CAAoC,IAApC,EAA0CiK,GAA1C,EAA+ChI,CAA/C,EAAkDC,CAAlD;AACA,SAAKiI,MAAL,CAAY,kBAAZ,EAAgCF,GAAhC,EAAqChI,CAArC,EAAwCC,CAAxC;AACH,GA1lDmC;;AA4lDpCoI,EAAAA,eAAe,CAACL,GAAD,EAAMhI,CAAN,EAASC,CAAT,EAAY;AACvB,SAAKiI,MAAL,CAAY,gBAAZ,EAA8BF,GAA9B,EAAmChI,CAAnC,EAAsCC,CAAtC;AACAnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmB+b,SAAnB,CAA6BvK,IAA7B,CAAkC,IAAlC,EAAwCiK,GAAxC,EAA6ChI,CAA7C,EAAgDC,CAAhD;AACH,GA/lDmC;;AAimDpCsI,EAAAA,eAAe,EAAE,UAASP,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEjCnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmBgc,eAAnB,CAAmC/b,KAAnC,CAAyC,IAAzC,EAA+CmB,SAA/C;AACA,SAAKua,MAAL,CAAY,sBAAZ,EAAoCF,GAApC,EAAyChI,CAAzC,EAA4CC,CAA5C;AACH,GArmDmC;AAumDpCuI,EAAAA,YAAY,EAAE,UAASR,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE9BnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmBic,YAAnB,CAAgChc,KAAhC,CAAsC,IAAtC,EAA4CmB,SAA5C;AACA,SAAKua,MAAL,CAAY,mBAAZ,EAAiCF,GAAjC,EAAsChI,CAAtC,EAAyCC,CAAzC;AACH,GA3mDmC;AA6mDpCwI,EAAAA,WAAW,EAAE,UAAST,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE7BnV,IAAAA,QAAQ,CAACyB,SAAT,CAAmBkc,WAAnB,CAA+Bjc,KAA/B,CAAqC,IAArC,EAA2CmB,SAA3C;AACA,SAAKua,MAAL,CAAY,kBAAZ,EAAgCF,GAAhC,EAAqChI,CAArC,EAAwCC,CAAxC;AACH,GAjnDmC;AAmnDpCgI,EAAAA,WAAW,EAAE,UAASD,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE7B,SAAK8H,iBAAL,CAAuBC,GAAvB,EAA4BhI,CAA5B,EAA+BC,CAA/B,EAF6B,CAI7B;;AACA,QAAI5T,SAAS,GAAG2b,GAAG,CAACvZ,MAAJ,CAAWia,YAAX,CAAwB,OAAxB,CAAhB;;AACA,YAAQrc,SAAR;AAEI,WAAK,eAAL;AACI,aAAKsc,eAAL,CAAqBX,GAArB,EAA0BhI,CAA1B,EAA6BC,CAA7B;AACA;;AAEJ,WAAK,sBAAL;AACA,WAAK,2BAAL;AACI,aAAK2I,qBAAL,CAA2BZ,GAA3B,EAAgChI,CAAhC,EAAmCC,CAAnC;AACA;;AAEJ,WAAK,kBAAL;AACI,aAAK4I,kBAAL,CAAwBb,GAAxB,EAA6BhI,CAA7B,EAAgCC,CAAhC;AACA;;AAEJ,WAAK,YAAL;AACA,WAAK,iBAAL;AACI,aAAK6I,mBAAL,CAAyBd,GAAzB,EAA8BhI,CAA9B,EAAiCC,CAAjC;AACA;;AAEJ,WAAK,eAAL;AACA,WAAK,eAAL;AACI;AAtBR;;AAyBA,SAAK8I,SAAL,CAAef,GAAf,EAAoBhI,CAApB,EAAuBC,CAAvB;AACH,GAnpDmC;AAqpDpCmI,EAAAA,WAAW,EAAE,UAASJ,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE7B;AACA,QAAI+I,QAAQ,GAAG,KAAKzb,SAApB;AACA,QAAIyb,QAAJ,EAAc,KAAKC,SAAL,CAAejB,GAAf,EAAoBgB,QAApB;AAEd,QAAI3E,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;;AACA,YAAQ3D,IAAI,CAAC6E,MAAb;AAEI,WAAK,aAAL;AACI,aAAKC,UAAL,CAAgBnB,GAAhB,EAAqBhI,CAArB,EAAwBC,CAAxB;AACA;;AAEJ,WAAK,YAAL;AACI,aAAKmJ,SAAL,CAAepB,GAAf,EAAoBhI,CAApB,EAAuBC,CAAvB;AACA;;AAEJ,WAAK,gBAAL;AACI,aAAKoJ,aAAL,CAAmBrB,GAAnB,EAAwBhI,CAAxB,EAA2BC,CAA3B;AACA;;AAEJ,WAAK,MAAL;AACI,aAAKqJ,IAAL,CAAUtB,GAAV,EAAehI,CAAf,EAAkBC,CAAlB;AACA;AAhBR,KAP6B,CA0B7B;;;AACA,QAAI+I,QAAJ,EAAc5d,MAAM,CAAC4d,QAAD,EAAW,KAAKC,SAAL,CAAejB,GAAf,CAAX,CAAN;AAEd,SAAKG,iBAAL,CAAuBH,GAAvB,EAA4BhI,CAA5B,EAA+BC,CAA/B;AACH,GAnrDmC;AAqrDpCqI,EAAAA,SAAS,EAAE,UAASN,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE3B;AACA,QAAI+I,QAAQ,GAAG,KAAKzb,SAApB;;AACA,QAAIyb,QAAJ,EAAc;AACV,WAAKC,SAAL,CAAejB,GAAf,EAAoBgB,QAApB;AACA,WAAKzb,SAAL,GAAiB,IAAjB;AACH;;AAED,QAAI8W,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;;AACA,YAAQ3D,IAAI,CAAC6E,MAAb;AAEI,WAAK,aAAL;AACI,aAAKK,aAAL,CAAmBvB,GAAnB,EAAwBhI,CAAxB,EAA2BC,CAA3B;AACA;;AAEJ,WAAK,YAAL;AACI,aAAKuJ,YAAL,CAAkBxB,GAAlB,EAAuBhI,CAAvB,EAA0BC,CAA1B;AACA;;AAEJ,WAAK,gBAAL;AACI,aAAKwJ,gBAAL,CAAsBzB,GAAtB,EAA2BhI,CAA3B,EAA8BC,CAA9B;AACA;;AAEJ,WAAK,MAAL;AACI,aAAKyJ,OAAL,CAAa1B,GAAb,EAAkBhI,CAAlB,EAAqBC,CAArB;AAfR;;AAkBA,SAAKoI,eAAL,CAAqBL,GAArB,EAA0BhI,CAA1B,EAA6BC,CAA7B;AACA,SAAK0J,eAAL,CAAqB3B,GAArB;AACH,GAntDmC;AAqtDpC4B,EAAAA,SAAS,EAAE,UAAS5B,GAAT,EAAc;AAErBld,IAAAA,QAAQ,CAACyB,SAAT,CAAmBqd,SAAnB,CAA6Bpd,KAA7B,CAAmC,IAAnC,EAAyCmB,SAAzC;AACA,SAAKua,MAAL,CAAY,gBAAZ,EAA8BF,GAA9B;AACH,GAztDmC;AA2tDpC6B,EAAAA,QAAQ,EAAE,UAAS7B,GAAT,EAAc;AAEpBld,IAAAA,QAAQ,CAACyB,SAAT,CAAmBsd,QAAnB,CAA4Brd,KAA5B,CAAkC,IAAlC,EAAwCmB,SAAxC;AACA,SAAKua,MAAL,CAAY,eAAZ,EAA6BF,GAA7B;AACH,GA/tDmC;AAiuDpC8B,EAAAA,UAAU,EAAE,UAAS9B,GAAT,EAAc;AAEtBld,IAAAA,QAAQ,CAACyB,SAAT,CAAmBud,UAAnB,CAA8Btd,KAA9B,CAAoC,IAApC,EAA0CmB,SAA1C;AACA,SAAKua,MAAL,CAAY,iBAAZ,EAA+BF,GAA/B;AACH,GAruDmC;AAuuDpC+B,EAAAA,UAAU,EAAE,UAAS/B,GAAT,EAAc;AAEtBld,IAAAA,QAAQ,CAACyB,SAAT,CAAmBwd,UAAnB,CAA8Bvd,KAA9B,CAAoC,IAApC,EAA0CmB,SAA1C;AACA,SAAKua,MAAL,CAAY,iBAAZ,EAA+BF,GAA/B;AACH,GA3uDmC;AA6uDpCgC,EAAAA,UAAU,EAAE,UAAShC,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoBgK,KAApB,EAA2B;AAEnCnf,IAAAA,QAAQ,CAACyB,SAAT,CAAmByd,UAAnB,CAA8Bxd,KAA9B,CAAoC,IAApC,EAA0CmB,SAA1C;AACA,SAAKua,MAAL,CAAY,iBAAZ,EAA+BF,GAA/B,EAAoChI,CAApC,EAAuCC,CAAvC,EAA0CgK,KAA1C;AACH,GAjvDmC;AAmvDpCC,EAAAA,OAAO,EAAE,UAASlC,GAAT,EAAcmC,SAAd,EAAyBnK,CAAzB,EAA4BC,CAA5B,EAA+B;AAEpC;AACA,QAAImK,QAAQ,GAAGpf,CAAC,CAACgd,GAAG,CAACvZ,MAAL,CAAD,CAAc4b,iBAAd,CAAgC,WAAhC,EAA6C,KAAKtY,EAAlD,CAAf;;AACA,QAAIqY,QAAJ,EAAc;AACV;AACApC,MAAAA,GAAG,CAACsC,eAAJ,GAFU,CAIV;;AACA,UAAI,KAAK9U,GAAL,CAAS,cAAT,CAAJ,EAA8B;AAC1B,YAAI2U,SAAS,KAAK,QAAlB,EAA4B;AACxB;AACA,eAAKza,KAAL,CAAWqE,MAAX,CAAkB;AAAEwW,YAAAA,EAAE,EAAE;AAAN,WAAlB,EAFwB,CAGxB;;AACA;AAEH,SAND,MAMO;AACH;AACA,eAAKrC,MAAL,CAAYiC,SAAZ,EAAuBnC,GAAvB,EAA4BhI,CAA5B,EAA+BC,CAA/B;AACH;AACJ;;AAED,WAAK8H,iBAAL,CAAuBC,GAAvB,EAA4BhI,CAA5B,EAA+BC,CAA/B;AACA,WAAK/Q,KAAL,CAAWsb,kBAAX,CAA8B,IAA9B,EAAoCxC,GAAG,CAAC3D,IAAxC;AAEH,KArBD,MAqBO;AACHvZ,MAAAA,QAAQ,CAACyB,SAAT,CAAmB2d,OAAnB,CAA2B1d,KAA3B,CAAiC,IAAjC,EAAuCmB,SAAvC;AACH;AACJ,GA/wDmC;AAixDpC8c,EAAAA,OAAO,EAAE,UAASzC,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEzB,SAAK8H,iBAAL,CAAuBC,GAAvB,EAA4BhI,CAA5B,EAA+BC,CAA/B;AAEA,SAAKyK,cAAL,CAAoB1C,GAApB,EAAyBhI,CAAzB,EAA4BC,CAA5B;AAEA,QAAIqK,eAAe,GAAG,KAAKrB,SAAL,CAAejB,GAAf,EAAoBsC,eAA1C;AACA,QAAIA,eAAJ,EAAqBtC,GAAG,CAACsC,eAAJ;AACxB,GAzxDmC;AA2xDpC;AAEAxB,EAAAA,mBAAmB,EAAE,UAASd,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAErC,QAAI,CAAC,KAAKzK,GAAL,CAAS,WAAT,CAAL,EAA4B,OAFS,CAIrC;AACA;;AACA,QAAImV,SAAS,GAAG,KAAKvI,SAAL,CAAe;AAAEpC,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAAf,EAA+B;AAAEsK,MAAAA,EAAE,EAAE;AAAN,KAA/B,CAAhB;AACA,SAAKtB,SAAL,CAAejB,GAAf,EAAoB;AAChBkB,MAAAA,MAAM,EAAE,aADQ;AAEhByB,MAAAA,SAAS,EAAEA;AAFK,KAApB;AAIH,GAxyDmC;AA0yDpCD,EAAAA,cAAc,EAAE,UAAS1C,GAAT,EAAc4C,EAAd,EAAkBC,EAAlB,EAAsB;AAElC,QAAI,KAAKrV,GAAL,CAAS,WAAT,CAAJ,EAA2B;AAEvB,UAAItB,SAAS,GAAG8T,GAAG,CAAC8C,aAApB;AACA,UAAIC,QAAQ,GAAGC,QAAQ,CAAC9W,SAAS,CAACwU,YAAV,CAAuB,WAAvB,CAAD,EAAsC,EAAtC,CAAvB;;AAEA,UAAIuC,aAAa,GAAG,KAAK/J,sBAAL,CAA4B6J,QAA5B,CAApB;;AACA,UAAIzJ,iBAAiB,GAAG,KAAKH,qBAAL,CAA2B4J,QAA3B,CAAxB;;AACA,UAAIxJ,wBAAwB,GAAG,KAAKH,4BAAL,EAA/B;;AACA,UAAIa,YAAY,GAAG,KAAKZ,uBAAL,CAA6BC,iBAA7B,EAAgDC,wBAAhD,CAAnB;;AAEA,WAAK0H,SAAL,CAAejB,GAAf,EAAoB;AAChBkB,QAAAA,MAAM,EAAE,YADQ;AAEhB6B,QAAAA,QAAQ,EAAEA,QAFM;AAGhBE,QAAAA,aAAa,EAAEA,aAHC;AAIhBhJ,QAAAA,YAAY,EAAEA,YAJE;AAKhBqI,QAAAA,eAAe,EAAE;AALD,OAApB;AAQH,KAlBD,MAkBO;AAEH;AACA;AACA,WAAKrB,SAAL,CAAejB,GAAf,EAAoB;AAAEsC,QAAAA,eAAe,EAAE;AAAnB,OAApB;AACH;;AAED,SAAKpb,KAAL,CAAWsb,kBAAX,CAA8B,IAA9B,EAAoCxC,GAAG,CAAC3D,IAAxC;AACH,GAt0DmC;AAw0DpCsE,EAAAA,eAAe,EAAE,UAASX,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEjC,QAAI,CAAC,KAAKzK,GAAL,CAAS,YAAT,CAAL,EAA6B;AAE7B,QAAI0V,UAAU,GAAGlD,GAAG,CAACvZ,MAArB;AACA,QAAIkc,SAAS,GAAGK,QAAQ,CAACE,UAAU,CAACxC,YAAX,CAAwB,KAAxB,CAAD,EAAiC,EAAjC,CAAxB;AACA,SAAKO,SAAL,CAAejB,GAAf,EAAoB;AAChBkB,MAAAA,MAAM,EAAE,aADQ;AAEhByB,MAAAA,SAAS,EAAEA;AAFK,KAApB;AAIH,GAl1DmC;AAo1DpC/B,EAAAA,qBAAqB,EAAE,UAASZ,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEvC,QAAI,CAAC,KAAKzK,GAAL,CAAS,cAAT,CAAL,EAA+B;AAE/B,QAAI2V,UAAU,GAAGnD,GAAG,CAACvZ,MAArB;AACA,QAAIkc,SAAS,GAAGK,QAAQ,CAACG,UAAU,CAACzC,YAAX,CAAwB,KAAxB,CAAD,EAAiC,EAAjC,CAAxB;AACA,SAAKhZ,KAAL,CAAW0b,YAAX,CAAwBT,SAAxB;AACH,GA31DmC;AA61DpC9B,EAAAA,kBAAkB,EAAE,UAASb,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEpC,QAAI,CAAC,KAAKzK,GAAL,CAAS,eAAT,CAAL,EAAgC;AAEhC,QAAI6V,aAAa,GAAGrD,GAAG,CAACvZ,MAAxB;AACA,QAAI6c,aAAa,GAAGD,aAAa,CAAC3C,YAAd,CAA2B,KAA3B,CAApB;AACA,QAAIrE,IAAI,GAAG,KAAKkH,kBAAL,CAAwBD,aAAxB,EAAuC;AAAEE,MAAAA,4BAA4B,EAAE;AAAhC,KAAvC,CAAX;AAEA,SAAKvC,SAAL,CAAejB,GAAf,EAAoB3D,IAApB;AACH,GAt2DmC;AAw2DpC0E,EAAAA,SAAS,EAAE,UAASf,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE3B,QAAI,CAAC,KAAKzK,GAAL,CAAS,UAAT,CAAL,EAA2B;AAE3B,SAAKyT,SAAL,CAAejB,GAAf,EAAoB;AAChBkB,MAAAA,MAAM,EAAE,MADQ;AAEhBuC,MAAAA,EAAE,EAAEzL,CAFY;AAGhB0L,MAAAA,EAAE,EAAEzL;AAHY,KAApB;AAKH,GAj3DmC;AAm3DpC;AACAmJ,EAAAA,SAAS,EAAE,UAASpB,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE3B,QAAIoE,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;AACA,QAAI/T,KAAK,GAAG;AAAE+K,MAAAA,QAAQ,EAAE,KAAKkD,gBAAL,CAAsBlC,CAAtB,EAAyBC,CAAzB,EAA4BoE,IAAI,CAAC4G,aAAjC,EAAgD5G,IAAI,CAACpC,YAArD;AAAZ,KAAZ;AACA,QAAI,KAAK/S,KAAL,CAAWtC,OAAX,CAAmB+e,UAAvB,EAAmC,OAAO1X,KAAK,CAAC+K,QAAN,CAAeN,MAAtB;AACnC,SAAKhP,KAAL,CAAWuE,KAAX,CAAiBoQ,IAAI,CAAC0G,QAAtB,EAAgC9W,KAAhC;AACH,GA13DmC;AA43DpCkV,EAAAA,UAAU,EAAE,UAASnB,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE5B,QAAIoE,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;AACA,SAAKtY,KAAL,CAAW8G,MAAX,CAAkB6N,IAAI,CAACsG,SAAvB,EAAkC;AAAE3K,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAAlC,EAAkD;AAAEsK,MAAAA,EAAE,EAAE;AAAN,KAAlD;AACH,GAh4DmC;AAk4DpClB,EAAAA,aAAa,EAAE,UAASrB,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAE/B,QAAI,KAAK/Q,KAAL,CAAWtC,OAAX,CAAmBgf,SAAvB,EAAkC;AAE9B,WAAKC,cAAL,CAAoB7D,GAApB,EAAyBhI,CAAzB,EAA4BC,CAA5B;AAEH,KAJD,MAIO;AAEH,WAAK6L,iBAAL,CAAuB,KAAKC,cAAL,CAAoB/D,GAApB,CAAvB,EAAiDhI,CAAjD,EAAoDC,CAApD,EAAuD,KAAKgJ,SAAL,CAAejB,GAAf,CAAvD;AACH;AACJ,GA54DmC;AA84DpCsB,EAAAA,IAAI,EAAE,UAAStB,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEtB,QAAIoE,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;AACA,SAAKtY,KAAL,CAAWgK,SAAX,CAAqBsG,CAAC,GAAGqE,IAAI,CAACoH,EAA9B,EAAkCxL,CAAC,GAAGoE,IAAI,CAACqH,EAA3C,EAA+C;AAAEnB,MAAAA,EAAE,EAAE;AAAN,KAA/C;AACA,SAAKtB,SAAL,CAAejB,GAAf,EAAoB;AAChByD,MAAAA,EAAE,EAAEzL,CADY;AAEhB0L,MAAAA,EAAE,EAAEzL;AAFY,KAApB;AAIH,GAt5DmC;AAw5DpC;AAEAuJ,EAAAA,YAAY,EAAE,YAAW,CACrB;AACH,GA55DmC;AA85DpCD,EAAAA,aAAa,EAAE,YAAW,CACtB;AACH,GAh6DmC;AAk6DpCE,EAAAA,gBAAgB,EAAE,UAASzB,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAElC,QAAIoE,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAX;AACA,QAAI9Y,KAAK,GAAG,KAAKA,KAAjB;;AAEA,QAAIA,KAAK,CAACtC,OAAN,CAAcgf,SAAlB,EAA6B;AACzB,WAAKI,iBAAL,CAAuB3H,IAAvB;AACH,KAFD,MAEO;AACH,WAAK4H,oBAAL,CAA0B5H,IAA1B,EAAgCrE,CAAhC,EAAmCC,CAAnC;AACH;;AAED,QAAI,CAAC/Q,KAAK,CAACgd,WAAN,CAAkB,IAAlB,CAAL,EAA8B;AAC1B;AACA,WAAKC,SAAL,CAAe9H,IAAf;AACH,KAHD,MAGO;AACH,WAAK+H,gBAAL,CAAsB/H,IAAtB;;AACA,WAAKgI,mBAAL,CAAyBhI,IAAzB,EAA+B2D,GAA/B;AACH;;AAED,SAAKsE,mBAAL,CAAyBjI,IAAzB;AACH,GAt7DmC;AAw7DpCqF,EAAAA,OAAO,EAAE,YAAW,CAChB;AACH,GA17DmC;AA47DpCyC,EAAAA,SAAS,EAAE,UAAS9H,IAAT,EAAe;AAEtB,YAAQA,IAAI,CAACkI,cAAb;AAEI,WAAK,QAAL;AACI,aAAK7c,KAAL,CAAWqE,MAAX,CAAkB;AAAEwW,UAAAA,EAAE,EAAE;AAAN,SAAlB;AACA;;AAEJ,WAAK,QAAL;AACA;AACI,aAAK7a,KAAL,CAAW8c,GAAX,CAAenI,IAAI,CAACoI,SAApB,EAA+BpI,IAAI,CAACqI,UAApC,EAAgD;AAAEnC,UAAAA,EAAE,EAAE;AAAN,SAAhD;AACA;AATR;AAWH,GAz8DmC;AA28DpC6B,EAAAA,gBAAgB,EAAE,UAAS/H,IAAT,EAAe;AAE7B;AACA,QAAI,KAAKnV,KAAL,CAAWtC,OAAX,CAAmB+f,aAAnB,IAAoC,KAAKjd,KAAL,CAAWkd,QAAX,EAAxC,EAA+D;AAC3D;AACAvI,MAAAA,IAAI,CAACwI,CAAL,GAAS,IAAT;AACH;AACJ,GAl9DmC;AAo9DpCR,EAAAA,mBAAmB,EAAE,UAAShI,IAAT,EAAe2D,GAAf,EAAoB;AAErC,QAAIyE,SAAS,GAAGpI,IAAI,CAACoI,SAArB;AACA,QAAIC,UAAU,GAAGrI,IAAI,CAACqI,UAAtB;AACA,QAAII,UAAU,GAAG,KAAKpd,KAAL,CAAWqd,IAAX,CAAgBN,SAAhB,CAAjB;AACA,QAAIO,UAAU,GAAGF,UAAU,IAAI,CAAC/hB,IAAI,CAACkiB,SAAL,CAAeP,UAAf,EAA2BI,UAA3B,CAAhC;;AACA,QAAIE,UAAJ,EAAgB;AACZ,UAAI9d,KAAK,GAAG,KAAKA,KAAjB;;AACA,UAAIwd,UAAU,CAAClN,EAAf,EAAmB;AACf,aAAK0I,MAAL,CAAY,iBAAZ,EAA+BF,GAA/B,EAAoC9Y,KAAK,CAACge,eAAN,CAAsBR,UAAU,CAAClN,EAAjC,CAApC,EAA0E6E,IAAI,CAAC8I,aAA/E,EAA8FV,SAA9F;AACH;;AACD,UAAIK,UAAU,CAACtN,EAAf,EAAmB;AACf,aAAK0I,MAAL,CAAY,cAAZ,EAA4BF,GAA5B,EAAiC9Y,KAAK,CAACge,eAAN,CAAsBJ,UAAU,CAACtN,EAAjC,CAAjC,EAAuE6E,IAAI,CAAC+I,kBAA5E,EAAgGX,SAAhG;AACH;AACJ;AACJ,GAn+DmC;AAq+DpCZ,EAAAA,cAAc,EAAE,UAAS7D,GAAT,EAAchI,CAAd,EAAiBC,CAAjB,EAAoB;AAEhC,UAAMoE,IAAI,GAAG,KAAK4E,SAAL,CAAejB,GAAf,CAAb,CAFgC,CAGhC;;AAEA,QAAIqF,CAAC,GAAG,KAAKne,KAAL,CAAWtC,OAAX,CAAmBgf,SAAnB,CAA6B0B,MAA7B,IAAuC,EAA/C;AACA,QAAIC,WAAW,GAAG,KAAKre,KAAL,CAAWse,eAAX,CAA2B;AAAExN,MAAAA,CAAC,EAAEA,CAAC,GAAGqN,CAAT;AAAYpN,MAAAA,CAAC,EAAEA,CAAC,GAAGoN,CAAnB;AAAsB1S,MAAAA,KAAK,EAAE,IAAI0S,CAAjC;AAAoCI,MAAAA,MAAM,EAAE,IAAIJ;AAAhD,KAA3B,CAAlB;AAEA,QAAIK,eAAe,GAAGrJ,IAAI,CAACsJ,WAAL,IAAoB,IAA1C;AACA,QAAIC,iBAAiB,GAAGvJ,IAAI,CAACwJ,aAAL,IAAsB,IAA9C;AACA,QAAIC,eAAe,GAAGzJ,IAAI,CAAC0J,WAAL,IAAoB,IAA1C;AAEA1J,IAAAA,IAAI,CAACsJ,WAAL,GAAmBtJ,IAAI,CAACwJ,aAAL,GAAqBxJ,IAAI,CAAC0J,WAAL,GAAmB,IAA3D;AAEA,QAAIC,WAAW,GAAGpO,MAAM,CAACqO,SAAzB;AACA,QAAIC,OAAO,GAAG,IAAIxiB,KAAJ,CAAUsU,CAAV,EAAaC,CAAb,CAAd;AACA,QAAI/Q,KAAK,GAAG,KAAKA,KAAjB;AAEAqe,IAAAA,WAAW,CAAChX,OAAZ,CAAoB,UAAS2H,IAAT,EAAe;AAC/B,YAAMiQ,UAAU,GAAG,EAAnB,CAD+B,CAE/B;;AACA,UAAIjQ,IAAI,CAACnM,EAAL,CAAQ2W,YAAR,CAAqB,QAArB,MAAmC,OAAvC,EAAgD;AAC5CyF,QAAAA,UAAU,CAACzhB,IAAX,CAAgB;AACZ0hB,UAAAA,IAAI,EAAElQ,IAAI,CAACxO,KAAL,CAAW+K,OAAX,EADM;AAEZ2C,UAAAA,MAAM,EAAEc,IAAI,CAACnM;AAFD,SAAhB;AAIH;;AAEDmM,MAAAA,IAAI,CAAChS,CAAL,CAAO,UAAP,EAAmBb,OAAnB,GAA6BkL,OAA7B,CAAqC6G,MAAM,IAAI;AAC3C+Q,QAAAA,UAAU,CAACzhB,IAAX,CAAgB;AACZ0hB,UAAAA,IAAI,EAAElQ,IAAI,CAACmQ,WAAL,CAAiBjR,MAAjB,CADM;AAEZA,UAAAA;AAFY,SAAhB;AAIH,OALD;AAOA+Q,MAAAA,UAAU,CAAC5X,OAAX,CAAmB+X,SAAS,IAAI;AAC5B,cAAM;AAAElR,UAAAA,MAAF;AAAUgR,UAAAA;AAAV,YAAmBE,SAAzB,CAD4B,CAE5B;;AACA,cAAMzP,QAAQ,GAAGuP,IAAI,CAACG,MAAL,GAAcC,eAAd,CAA8BN,OAA9B,CAAjB,CAH4B,CAI5B;;AACA,YAAIrP,QAAQ,GAAGmP,WAAf,EAA4B;AACxB,gBAAMS,kBAAkB,GAAGb,iBAAiB,KAAKxQ,MAAjD;;AACA,cAAIqR,kBAAkB,IAAIvf,KAAK,CAACtC,OAAN,CAAc8hB,kBAAd,CAAiCliB,KAAjC,CACtB0C,KADsB,EACfmV,IAAI,CAACsK,sBAAL,CAA4BzQ,IAA5B,EAAmCA,IAAI,CAACnM,EAAL,KAAYqL,MAAb,GAAuB,IAAvB,GAA8BA,MAAhE,CADe,CAA1B,EAEG;AACC4Q,YAAAA,WAAW,GAAGnP,QAAd;AACAwF,YAAAA,IAAI,CAACsJ,WAAL,GAAmBzP,IAAnB;AACAmG,YAAAA,IAAI,CAACwJ,aAAL,GAAqBzQ,MAArB;AACH;AACJ;AACJ,OAfD;AAiBH,KAlCD,EAkCG,IAlCH;AAoCA,QAAItG,GAAJ;AACA,QAAIiX,WAAW,GAAG,IAAlB;AACA,QAAIJ,WAAW,GAAGtJ,IAAI,CAACsJ,WAAvB;AACA,QAAIE,aAAa,GAAGxJ,IAAI,CAACwJ,aAAzB;;AACA,QAAIA,aAAJ,EAAmB;AACfE,MAAAA,WAAW,GAAG1J,IAAI,CAAC0J,WAAL,GAAmBJ,WAAW,CAACiB,aAAZ,CAA0Bf,aAA1B,EAAyC,aAAzC,CAAjC;AACH;;AACD,QAAIvQ,OAAO,GAAG+G,IAAI,CAACoI,SAAnB;AACA,QAAIoC,gBAAgB,GAAIjB,iBAAiB,KAAKC,aAA9C;;AACA,QAAIH,eAAe,IAAImB,gBAAvB,EAAyC;AACrCnB,MAAAA,eAAe,CAACoB,WAAhB,CAA4BhB,eAA5B,EAA6C;AACzCiB,QAAAA,UAAU,EAAE,IAD6B;AAEzCC,QAAAA,QAAQ,EAAE;AAF+B,OAA7C;AAIH;;AAED,QAAIrB,WAAJ,EAAiB;AAEb,UAAI,CAACkB,gBAAL,EAAuB;AAEvBlB,MAAAA,WAAW,CAACsB,SAAZ,CAAsBlB,WAAtB,EAAmC;AAC/BgB,QAAAA,UAAU,EAAE,IADmB;AAE/BC,QAAAA,QAAQ,EAAE;AAFqB,OAAnC;AAIAlY,MAAAA,GAAG,GAAG6W,WAAW,CAACuB,UAAZ,CAAuBrB,aAAvB,EAAsC7N,CAAtC,EAAyCC,CAAzC,EAA4C,KAAKvQ,KAAjD,EAAwD4N,OAAxD,CAAN;AAEH,KAVD,MAUO;AAEHxG,MAAAA,GAAG,GAAG;AAAEkJ,QAAAA,CAAC,EAAEA,CAAL;AAAQC,QAAAA,CAAC,EAAEA;AAAX,OAAN;AACH;;AAED,SAAKvQ,KAAL,CAAW8c,GAAX,CAAelP,OAAf,EAAwBxG,GAAG,IAAI;AAAEkJ,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAA/B,EAA+C;AAAEsK,MAAAA,EAAE,EAAE;AAAN,KAA/C;;AAEA,QAAImD,eAAJ,EAAqB;AACjB,WAAKxF,MAAL,CAAY,sBAAZ,EAAoCF,GAApC,EAAyC0F,eAAzC,EAA0DE,iBAA1D,EAA6EtQ,OAA7E;AACH;;AACD,QAAIqQ,WAAJ,EAAiB;AACb,WAAKzF,MAAL,CAAY,mBAAZ,EAAiCF,GAAjC,EAAsC2F,WAAtC,EAAmDE,aAAnD,EAAkEvQ,OAAlE;AACH;AACJ,GAlkEmC;AAokEpC0O,EAAAA,iBAAiB,EAAE,UAAS3H,IAAT,EAAe;AAE9B;AACA;AACA,QAAIsJ,WAAW,GAAGtJ,IAAI,CAACsJ,WAAvB;AACA,QAAIE,aAAa,GAAGxJ,IAAI,CAACwJ,aAAzB;;AACA,QAAIF,WAAW,IAAIE,aAAnB,EAAkC;AAE9BF,MAAAA,WAAW,CAACmB,WAAZ,CAAwBzK,IAAI,CAAC0J,WAA7B,EAA0C;AAAEgB,QAAAA,UAAU,EAAE,IAAd;AAAoBC,QAAAA,QAAQ,EAAE;AAA9B,OAA1C;AACA3K,MAAAA,IAAI,CAAC+I,kBAAL,GAA0BO,WAAW,CAACwB,UAAZ,CAAuBtB,aAAvB,CAA1B;AACH;;AAEDxJ,IAAAA,IAAI,CAACsJ,WAAL,GAAmBtJ,IAAI,CAACwJ,aAAL,GAAqB,IAAxC;AACH,GAjlEmC;AAmlEpC/B,EAAAA,iBAAiB,EAAE,UAASrd,MAAT,EAAiBuR,CAAjB,EAAoBC,CAApB,EAAuBoE,IAAvB,EAA6B;AAE5C;AACA,UAAM;AAAEnV,MAAAA,KAAF;AAASQ,MAAAA;AAAT,QAAmB,IAAzB;;AAEA,QAAI2U,IAAI,CAAC+K,WAAL,KAAqB3gB,MAAzB,EAAiC;AAC7B;AACA,UAAI4V,IAAI,CAAC0J,WAAT,EAAsB;AAClB1J,QAAAA,IAAI,CAACgL,gBAAL,CAAsBP,WAAtB,CAAkCzK,IAAI,CAAC0J,WAAvC,EAAoD;AAChDgB,UAAAA,UAAU,EAAE;AADoC,SAApD;AAGH;;AAED,YAAMM,gBAAgB,GAAGhL,IAAI,CAACgL,gBAAL,GAAwBngB,KAAK,CAACwR,QAAN,CAAejS,MAAf,CAAjD;;AACA,UAAI4gB,gBAAJ,EAAsB;AAClB;AACA;AACA,cAAMjC,kBAAkB,GAAG/I,IAAI,CAAC+I,kBAAL,GAA0BiC,gBAAgB,CAACF,UAAjB,CAA4B1gB,MAA5B,CAArD;AACA,cAAMsf,WAAW,GAAG1J,IAAI,CAAC0J,WAAL,GAAmBsB,gBAAgB,CAACT,aAAjB,CAA+BxB,kBAA/B,EAAmD,aAAnD,CAAvC;;AAEA,YAAIA,kBAAkB,IAAI,KAAKle,KAAL,CAAWtC,OAAX,CAAmB8hB,kBAAnB,CAAsCliB,KAAtC,CACtB0C,KADsB,EAEtBmV,IAAI,CAACsK,sBAAL,CAA4BU,gBAA5B,EAA8CjC,kBAA9C,CAFsB,CAA1B,EAGG;AACC;AACA;AACA;AACA,cAAIW,WAAJ,EAAiB;AACbsB,YAAAA,gBAAgB,CAACJ,SAAjB,CAA2BlB,WAA3B,EAAwC;AACpCgB,cAAAA,UAAU,EAAE;AADwB,aAAxC;AAGH;AACJ,SAZD,MAYO;AACH;AACA1K,UAAAA,IAAI,CAAC+I,kBAAL,GAA0B,IAA1B;AACA/I,UAAAA,IAAI,CAAC0J,WAAL,GAAmB,IAAnB;AACH;AACJ,OAvBD,MAuBO;AACH;AACA1J,QAAAA,IAAI,CAAC+I,kBAAL,GAA0B,IAA1B;AACA/I,QAAAA,IAAI,CAAC0J,WAAL,GAAmB,IAAnB;AACH;AACJ;;AAED1J,IAAAA,IAAI,CAAC+K,WAAL,GAAmB3gB,MAAnB;AAEAiB,IAAAA,KAAK,CAAC8c,GAAN,CAAUnI,IAAI,CAACoI,SAAf,EAA0B;AAAEzM,MAAAA,CAAC,EAAEA,CAAL;AAAQC,MAAAA,CAAC,EAAEA;AAAX,KAA1B,EAA0C;AAAEsK,MAAAA,EAAE,EAAE;AAAN,KAA1C;AACH,GAloEmC;AAooEpC0B,EAAAA,oBAAoB,EAAE,UAAS5H,IAAI,GAAG,EAAhB,EAAoBrE,CAApB,EAAuBC,CAAvB,EAA0B;AAE5C,UAAM;AAAEvQ,MAAAA;AAAF,QAAY,IAAlB;AACA,UAAM;AAAE2f,MAAAA,gBAAF;AAAoBjC,MAAAA,kBAApB;AAAwCW,MAAAA,WAAxC;AAAqDtB,MAAAA;AAArD,QAAmEpI,IAAzE;AAEA,QAAI,CAAC+I,kBAAD,IAAuB,CAACW,WAAxB,IAAuC,CAACsB,gBAA5C,EAA8D;AAE9DA,IAAAA,gBAAgB,CAACP,WAAjB,CAA6Bf,WAA7B,EAA0C;AAAEgB,MAAAA,UAAU,EAAE;AAAd,KAA1C,EAP4C,CAS5C;;AACA,UAAMjY,GAAG,GAAGuY,gBAAgB,CAACH,UAAjB,CAA4B9B,kBAA5B,EAAgDpN,CAAhD,EAAmDC,CAAnD,EAAsDvQ,KAAtD,EAA6D+c,SAA7D,CAAZ;AACA/c,IAAAA,KAAK,CAAC8c,GAAN,CAAUC,SAAV,EAAqB3V,GAArB,EAA0B;AAAEyT,MAAAA,EAAE,EAAE;AAAN,KAA1B;AACH,GAhpEmC;AAkpEpC+E,EAAAA,oBAAoB,EAAE,UAASjL,IAAT,EAAe;AAEjCA,IAAAA,IAAI,CAACwI,CAAL,GAAS,KAAKnd,KAAL,CAAW6B,GAAX,CAAe,GAAf,CAAT;AACA,SAAK7B,KAAL,CAAW6f,OAAX,GAHiC,CAKjC;AACA;;AACA,QAAIC,KAAK,GAAG,KAAKzd,EAAL,CAAQyd,KAApB;AACAnL,IAAAA,IAAI,CAACoL,aAAL,GAAqBD,KAAK,CAACC,aAA3B;AACAD,IAAAA,KAAK,CAACC,aAAN,GAAsB,MAAtB;;AAEA,QAAI,KAAKvgB,KAAL,CAAWtC,OAAX,CAAmB8iB,aAAvB,EAAsC;AAClC,WAAKC,qBAAL,CAA2BtL,IAA3B;AACH;AACJ,GAhqEmC;AAkqEpCiI,EAAAA,mBAAmB,EAAE,UAASjI,IAAT,EAAe;AAEhC,QAAIA,IAAI,CAACwI,CAAL,KAAW,IAAf,EAAqB;AACjB,WAAKnd,KAAL,CAAW8c,GAAX,CAAe,GAAf,EAAoBnI,IAAI,CAACwI,CAAzB,EAA4B;AAAEtC,QAAAA,EAAE,EAAE;AAAN,OAA5B;AACAlG,MAAAA,IAAI,CAACwI,CAAL,GAAS,IAAT;AACH,KAL+B,CAOhC;;;AACA,SAAK9a,EAAL,CAAQyd,KAAR,CAAcC,aAAd,GAA8BpL,IAAI,CAACoL,aAAnC;;AAEA,QAAI,KAAKvgB,KAAL,CAAWtC,OAAX,CAAmB8iB,aAAvB,EAAsC;AAClC,WAAKE,uBAAL,CAA6BvL,IAA7B;AACH;AACJ,GA/qEmC;AAirEpCwL,EAAAA,6BAA6B,EAAE,UAASpD,SAAT,EAAoB;AAC/C;AACA;AACA,QAAIzO,IAAI,GAAG,EAAX;AAEAA,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUyO,SAAV;AACAzO,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAV;AAEA,QAAI8R,iBAAJ;AACA,QAAIzd,CAAC,GAAG,CAAR;AACA,QAAI0d,CAAC,GAAG,CAAR;;AAEA,QAAItD,SAAS,KAAK,QAAlB,EAA4B;AACxBpa,MAAAA,CAAC,GAAG,CAAJ;AACAyd,MAAAA,iBAAiB,GAAG,QAApB;AACH,KAHD,MAGO;AACHC,MAAAA,CAAC,GAAG,CAAJ;AACAD,MAAAA,iBAAiB,GAAG,QAApB;AACH;;AAED,QAAIhZ,GAAG,GAAG,KAAKpH,KAAL,CAAW6B,GAAX,CAAeue,iBAAf,CAAV;;AAEA,QAAIhZ,GAAG,CAAC0I,EAAR,EAAY;AACR,UAAItB,IAAI,GAAGF,IAAI,CAAC3L,CAAD,CAAJ,GAAU,KAAKnD,KAAL,CAAWge,eAAX,CAA2BpW,GAAG,CAAC0I,EAA/B,CAArB;AACA,UAAIpC,MAAM,GAAGc,IAAI,CAAC2C,oBAAL,CAA0B/J,GAA1B,CAAb;AACA,UAAIsG,MAAM,KAAKc,IAAI,CAACnM,EAApB,EAAwBqL,MAAM,GAAGxK,SAAT;AACxBoL,MAAAA,IAAI,CAAC3L,CAAC,GAAG,CAAL,CAAJ,GAAc+K,MAAd;AACH;;AAED,aAASuR,sBAAT,CAAgCxR,QAAhC,EAA0CC,MAA1C,EAAkD;AAC9CY,MAAAA,IAAI,CAAC+R,CAAD,CAAJ,GAAU5S,QAAV;AACAa,MAAAA,IAAI,CAAC+R,CAAC,GAAG,CAAL,CAAJ,GAAc5S,QAAQ,CAACpL,EAAT,KAAgBqL,MAAhB,GAAyBxK,SAAzB,GAAqCwK,MAAnD;AACA,aAAOY,IAAP;AACH;;AAED,WAAO2Q,sBAAP;AACH,GArtEmC;AAutEpCgB,EAAAA,qBAAqB,EAAE,UAAStL,IAAT,EAAe;AAElC,aAAS2L,iBAAT,CAA2B9R,IAA3B,EAAiCd,MAAjC,EAAyC;AACrC,UAAIlO,KAAK,GAAGgP,IAAI,CAAChP,KAAjB;AACA,UAAI+gB,QAAQ,GAAG/gB,KAAK,CAACtC,OAAN,CAAc8hB,kBAA7B;AACA,aAAOuB,QAAQ,CAACzjB,KAAT,CAAe0C,KAAf,EAAsB,KAAKyf,sBAAL,CAA4BzQ,IAA5B,EAAkCd,MAAlC,CAAtB,CAAP;AACH;;AAED,QAAIlO,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIghB,QAAQ,GAAGhhB,KAAK,CAACQ,KAAN,CAAYygB,QAAZ,EAAf;AACA9L,IAAAA,IAAI,CAAC+L,MAAL,GAAc,EAAd;;AAEA,SAAK,IAAI/d,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG4d,QAAQ,CAACtf,MAA7B,EAAqCyB,CAAC,GAAGC,CAAzC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,UAAI6L,IAAI,GAAGgS,QAAQ,CAAC7d,CAAD,CAAR,CAAYqO,QAAZ,CAAqBxR,KAArB,CAAX;;AAEA,UAAI,CAACgP,IAAL,EAAW;AACP;AACH;;AAED,UAAImS,OAAO,GAAG5e,KAAK,CAAClF,SAAN,CAAgB6L,KAAhB,CAAsB2F,IAAtB,CAA2BG,IAAI,CAACnM,EAAL,CAAQue,gBAAR,CAAyB,UAAzB,CAA3B,CAAd;;AACA,UAAIpS,IAAI,CAACnM,EAAL,CAAQ2W,YAAR,CAAqB,QAArB,MAAmC,OAAvC,EAAgD;AAC5C;AACA2H,QAAAA,OAAO,CAAC3jB,IAAR,CAAawR,IAAI,CAACnM,EAAlB;AACH;;AAED,UAAIwe,gBAAgB,GAAGF,OAAO,CAACG,MAAR,CAAeR,iBAAiB,CAACS,IAAlB,CAAuBpM,IAAvB,EAA6BnG,IAA7B,CAAf,CAAvB;;AAEA,UAAIqS,gBAAgB,CAAC3f,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B;AACA,aAAK,IAAImf,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAGH,gBAAgB,CAAC3f,MAArC,EAA6Cmf,CAAC,GAAGW,CAAjD,EAAoDX,CAAC,EAArD,EAAyD;AACrD7R,UAAAA,IAAI,CAAC+Q,SAAL,CAAesB,gBAAgB,CAACR,CAAD,CAA/B,EAAoC;AAAEY,YAAAA,kBAAkB,EAAE;AAAtB,WAApC;AACH,SAJ4B,CAK7B;;;AACAzS,QAAAA,IAAI,CAAC+Q,SAAL,CAAe,IAAf,EAAqB;AAAE2B,UAAAA,mBAAmB,EAAE;AAAvB,SAArB;AAEAvM,QAAAA,IAAI,CAAC+L,MAAL,CAAYlS,IAAI,CAACxO,KAAL,CAAW8P,EAAvB,IAA6B+Q,gBAA7B;AACH;AACJ;AACJ,GA7vEmC;AA+vEpCX,EAAAA,uBAAuB,EAAE,UAASvL,IAAT,EAAe;AAEpC,QAAIwM,UAAU,GAAG/f,MAAM,CAACggB,IAAP,CAAYzM,IAAI,CAAC+L,MAAjB,CAAjB;AACA,QAAI5Q,EAAJ;AACA,QAAIuR,aAAJ;;AAEA,SAAK,IAAI1e,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGue,UAAU,CAACjgB,MAA/B,EAAuCyB,CAAC,GAAGC,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;AAC/CmN,MAAAA,EAAE,GAAGqR,UAAU,CAACxe,CAAD,CAAf;AACA0e,MAAAA,aAAa,GAAG1M,IAAI,CAAC+L,MAAL,CAAY5Q,EAAZ,CAAhB;AAEA,UAAItB,IAAI,GAAG,KAAKhP,KAAL,CAAWge,eAAX,CAA2B1N,EAA3B,CAAX;;AACA,UAAItB,IAAJ,EAAU;AACN,aAAK,IAAI6R,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAGK,aAAa,CAACngB,MAAlC,EAA0Cmf,CAAC,GAAGW,CAA9C,EAAiDX,CAAC,EAAlD,EAAsD;AAClD7R,UAAAA,IAAI,CAAC4Q,WAAL,CAAiBiC,aAAa,CAAChB,CAAD,CAA9B,EAAmC;AAAEY,YAAAA,kBAAkB,EAAE;AAAtB,WAAnC;AACH;;AACDzS,QAAAA,IAAI,CAAC4Q,WAAL,CAAiB,IAAjB,EAAuB;AAAE8B,UAAAA,mBAAmB,EAAE;AAAvB,SAAvB;AACH;AACJ;;AAEDvM,IAAAA,IAAI,CAAC+L,MAAL,GAAc,IAAd;AACH,GAnxEmC;AAqxEpC7E,EAAAA,kBAAkB,EAAE,UAASzU,GAAT,EAAchI,GAAd,EAAmB;AAEnCA,IAAAA,GAAG,KAAKA,GAAG,GAAG,EAAX,CAAH,CAFmC,CAInC;AACA;;AACA,QAAIuV,IAAI,GAAG;AACP6E,MAAAA,MAAM,EAAE,gBADD;AAEPuD,MAAAA,SAAS,EAAE3V,GAFJ;AAGPyV,MAAAA,cAAc,EAAEzd,GAAG,CAACyd,cAAJ,IAAsB,QAH/B;AAIPY,MAAAA,aAAa,EAAE,KAAKrW,GAAG,GAAG,QAAX,MAAyB,KAAKA,GAAG,GAAG,MAAX,IAAqB,KAAKA,GAAG,GAAG,MAAX,EAAmB/E,EAAxC,GAA6C,IAAtE,CAJR;AAKP2a,MAAAA,UAAU,EAAElhB,KAAK,CAAC,KAAKkE,KAAL,CAAW6B,GAAX,CAAeuF,GAAf,CAAD,CALV;AAMP6X,MAAAA,sBAAsB,EAAE,KAAKkB,6BAAL,CAAmC/Y,GAAnC;AANjB,KAAX;;AASA,SAAKwY,oBAAL,CAA0BjL,IAA1B;;AAEA,QAAIvV,GAAG,CAAC0c,4BAAJ,KAAqC,IAAzC,EAA+C;AAC3C,WAAKje,SAAL,GAAiB8W,IAAjB;AACH;;AAED,WAAOA,IAAP;AACH;AA3yEmC,CAAhB,CAAjB;AA8yEPvT,MAAM,CAACkgB,cAAP,CAAsB7kB,QAAQ,CAACI,SAA/B,EAA0C,YAA1C,EAAwD;AAEpD0kB,EAAAA,UAAU,EAAE,IAFwC;AAIpD1f,EAAAA,GAAG,EAAE,YAAW;AACZ,QAAIpC,UAAU,GAAG,KAAKA,UAAtB;;AACA,QAAI,CAACA,UAAL,EAAiB;AACb,UAAIkN,SAAS,GAAG,KAAK3M,KAAL,CAAWlB,MAAX,EAAhB;AACA,aAAO,IAAI1C,IAAJ,CAASuQ,SAAS,CAAC2D,CAAnB,EAAsB3D,SAAS,CAAC4D,CAAhC,CAAP;AACH;;AACD,QAAI/G,YAAY,GAAG,KAAKA,YAAxB;;AACA,QAAI/J,UAAU,CAACqN,gBAAX,CAA4BtD,YAA5B,CAAJ,EAA+C;AAC3C,aAAO,IAAIpN,IAAJ,CAAS,KAAK0L,YAAd,CAAP;AACH;;AACD,WAAOrI,UAAU,CAACkf,WAAX,CAAuBnV,YAAY,IAAI/J,UAAU,CAAC4C,EAAlD,CAAP;AACH;AAfmD,CAAxD;AAmBAjB,MAAM,CAACkgB,cAAP,CAAsB7kB,QAAQ,CAACI,SAA/B,EAA0C,YAA1C,EAAwD;AAEpD0kB,EAAAA,UAAU,EAAE,IAFwC;AAIpD1f,EAAAA,GAAG,EAAE,YAAW;AACZ,QAAInC,UAAU,GAAG,KAAKA,UAAtB;;AACA,QAAI,CAACA,UAAL,EAAiB;AACb,UAAIkN,SAAS,GAAG,KAAK5M,KAAL,CAAWjB,MAAX,EAAhB;AACA,aAAO,IAAI3C,IAAJ,CAASwQ,SAAS,CAAC0D,CAAnB,EAAsB1D,SAAS,CAAC2D,CAAhC,CAAP;AACH;;AACD,QAAI9G,YAAY,GAAG,KAAKA,YAAxB;;AACA,QAAI/J,UAAU,CAACoN,gBAAX,CAA4BrD,YAA5B,CAAJ,EAA+C;AAC3C,aAAO,IAAIrN,IAAJ,CAAS,KAAK2L,YAAd,CAAP;AACH;;AACD,WAAOrI,UAAU,CAACif,WAAX,CAAuBlV,YAAY,IAAI/J,UAAU,CAAC2C,EAAlD,CAAP;AACH;AAfmD,CAAxD","sourcesContent":["import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { removeClassNamePrefix, merge, template, assign, toArray, isObject, isFunction, clone, isPercentage } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport $ from 'jquery';\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    options: {\n\n        shortLinkLength: 105,\n        doubleLinkTools: false,\n        longLinkLength: 155,\n        linkToolsOffset: 40,\n        doubleLinkToolsOffset: 65,\n        sampleInterval: 50,\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _markerCache: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // keeps markers bboxes and positions again for quicker access\n        this._markerCache = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.metrics = {};\n    },\n\n    presentationAttributes: {\n        markup: ['RENDER'],\n        attrs: ['UPDATE'],\n        router: ['UPDATE'],\n        connector: ['UPDATE'],\n        smooth: ['UPDATE'],\n        manhattan: ['UPDATE'],\n        toolMarkup: ['LEGACY_TOOLS'],\n        labels: ['LABELS'],\n        labelMarkup: ['LABELS'],\n        vertices: ['VERTICES', 'UPDATE'],\n        vertexMarkup: ['VERTICES'],\n        source: ['SOURCE', 'UPDATE'],\n        target: ['TARGET', 'UPDATE']\n    },\n\n    initFlag: ['RENDER', 'SOURCE', 'TARGET', 'TOOLS'],\n\n    UPDATE_PRIORITY: 1,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, 'SOURCE')) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, 'SOURCE');\n        }\n\n        if (this.hasFlag(flags, 'TARGET')) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, 'TARGET');\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, 'RENDER')) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, ['RENDER', 'UPDATE', 'VERTICES', 'LABELS', 'TOOLS', 'LEGACY_TOOLS']);\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        if (this.hasFlag(flags, 'VERTICES')) {\n            this.renderVertexMarkers();\n            flags = this.removeFlag(flags, 'VERTICES');\n        }\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, 'LABELS');\n        let updateLegacyTools = this.hasFlag(flags, 'LEGACY_TOOLS');\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, 'LABELS');\n            updateHighlighters = true;\n        }\n\n        if (updateLegacyTools) {\n            this.renderTools();\n            flags = this.removeFlag(flags, 'LEGACY_TOOLS');\n        }\n\n        if (this.hasFlag(flags, 'UPDATE')) {\n            this.update(model, null, opt);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, ['UPDATE', 'TOOLS']);\n            updateLabels = false;\n            updateLegacyTools = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateLegacyTools) {\n            this.updateToolsPosition();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, 'TOOLS')) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, 'TOOLS');\n        }\n\n        return flags;\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag('UPDATE', opt));\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = V(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n        // Cache all children elements for quicker access.\n        var cache = this._V; // vectorized markup;\n        for (var i = 0, n = children.length; i < n; i++) {\n            var child = children[i];\n            var className = child.attr('class');\n            if (className) {\n                // Strip the joint class name prefix, if there is one.\n                className = removeClassNamePrefix(className);\n                cache[$.camelCase(className)] = child;\n            }\n        }\n        // partial rendering\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = V(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V('g').append(fragment);\n        } else {\n            vNode = V(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = V('g').addClass('labels');\n        }\n\n        var container = vLabels.node;\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            container.appendChild(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n\n        if (!container.parentNode) {\n            this.el.appendChild(container);\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return null;\n        const labelSelectors = this._labelSelectors[labelIndex];\n        const [node = null] = this.findBySelector(selector, labelRoot, labelSelectors);\n        return node;\n    },\n\n\n    // merge default label attrs into label attrs\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new Rect(label.size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    renderTools: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Tools are a group of clickable elements that manipulate the whole link.\n        // A good example of this is the remove tool that removes the whole link.\n        // Tools appear after hovering the link close to the `source` element/point of the link\n        // but are offset a bit so that they don't cover the `marker-arrowhead`.\n\n        var $tools = $(this._V.linkTools.node).empty();\n        var toolTemplate = template(this.model.get('toolMarkup') || this.model.toolMarkup);\n        var tool = V(toolTemplate());\n\n        $tools.append(tool.node);\n\n        // Cache the tool node so that the `updateToolsPosition()` can update the tool position quickly.\n        this._toolCache = tool;\n\n        // If `doubleLinkTools` is enabled, we render copy of the tools on the other side of the\n        // link as well but only if the link is longer than `longLinkLength`.\n        if (this.options.doubleLinkTools) {\n\n            var tool2;\n            if (this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup) {\n                toolTemplate = template(this.model.get('doubleToolMarkup') || this.model.doubleToolMarkup);\n                tool2 = V(toolTemplate());\n            } else {\n                tool2 = tool.clone();\n            }\n\n            $tools.append(tool2.node);\n            this._tool2Cache = tool2;\n        }\n\n        return this;\n    },\n\n    renderVertexMarkers: function() {\n\n        if (!this._V.markerVertices) return this;\n\n        var $markerVertices = $(this._V.markerVertices.node).empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('vertexMarkup') || this.model.vertexMarkup);\n\n        this.model.vertices().forEach(function(vertex, idx) {\n            $markerVertices.append(V(markupTemplate(assign({ idx: idx }, vertex))).node);\n        });\n\n        return this;\n    },\n\n    renderArrowheadMarkers: function() {\n\n        // Custom markups might not have arrowhead markers. Therefore, jump of this function immediately if that's the case.\n        if (!this._V.markerArrowheads) return this;\n\n        var $markerArrowheads = $(this._V.markerArrowheads.node);\n\n        $markerArrowheads.empty();\n\n        // A special markup can be given in the `properties.vertexMarkup` property. This might be handy\n        // if default styling (elements) are not desired. This makes it possible to use any\n        // SVG elements for .marker-vertex and .marker-vertex-remove tools.\n        var markupTemplate = template(this.model.get('arrowheadMarkup') || this.model.arrowheadMarkup);\n\n        this._V.sourceArrowhead = V(markupTemplate({ end: 'source' }));\n        this._V.targetArrowhead = V(markupTemplate({ end: 'target' }));\n\n        $markerArrowheads.append(this._V.sourceArrowhead.node, this._V.targetArrowhead.node);\n\n        return this;\n    },\n\n    // Updating.\n    // ---------\n\n    // Default is to process the `attrs` object and set attributes on subelements based on the selectors.\n    update: function(model, attributes, opt) {\n\n        opt || (opt = {});\n\n        this.cleanNodesCache();\n\n        // update the link path\n        this.updateConnection(opt);\n\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(this.el, this.model.attr(), { selectors: this.selectors });\n\n        this.updateDefaultConnectionPath();\n\n        // update the label position etc.\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    updateDefaultConnectionPath: function() {\n\n        var cache = this._V;\n\n        if (cache.connection) {\n            cache.connection.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.connectionWrap) {\n            cache.connectionWrap.attr('d', this.getSerializedConnection());\n        }\n\n        if (cache.markerSource && cache.markerTarget) {\n            this._translateAndAutoOrientArrows(cache.markerSource, cache.markerTarget);\n        }\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourceAnchor);\n            case 'target':\n                return new Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourcePoint);\n            case 'target':\n                return new Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n    updateConnection: function(opt) {\n\n        opt = opt || {};\n\n        var model = this.model;\n        var route, path;\n\n        if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n            // The link is being translated by an ancestor that will\n            // shift source point, target point and all vertices\n            // by an equal distance.\n            var tx = opt.tx || 0;\n            var ty = opt.ty || 0;\n\n            route = (new Polyline(this.route)).translate(tx, ty).points;\n\n            // translate source and target connection and marker points.\n            this._translateConnectionPoints(tx, ty);\n\n            // translate the path itself\n            path = this.path;\n            path.translate(tx, ty);\n\n        } else {\n\n            var vertices = model.vertices();\n            // 1. Find Anchors\n\n            var anchors = this.findAnchors(vertices);\n            var sourceAnchor = this.sourceAnchor = anchors.source;\n            var targetAnchor = this.targetAnchor = anchors.target;\n\n            // 2. Find Route\n            route = this.findRoute(vertices, opt);\n\n            // 3. Find Connection Points\n            var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n            var sourcePoint = this.sourcePoint = connectionPoints.source;\n            var targetPoint = this.targetPoint = connectionPoints.target;\n\n            // 3b. Find Marker Connection Point - Backwards Compatibility\n            var markerPoints = this.findMarkerPoints(route, sourcePoint, targetPoint);\n\n            // 4. Find Connection\n            path = this.findPath(route, markerPoints.source || sourcePoint, markerPoints.target || targetPoint);\n        }\n\n        this.route = route;\n        this.path = path;\n        this.metrics = {};\n    },\n\n    findMarkerPoints: function(route, sourcePoint, targetPoint) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n\n        // Move the source point by the width of the marker taking into account\n        // its scale around x-axis. Note that scale is the only transform that\n        // makes sense to be set in `.marker-source` attributes object\n        // as all other transforms (translate/rotate) will be replaced\n        // by the `translateAndAutoOrient()` function.\n        var cache = this._markerCache;\n        // cache source and target points\n        var sourceMarkerPoint, targetMarkerPoint;\n\n        if (this._V.markerSource) {\n\n            cache.sourceBBox = cache.sourceBBox || this._V.markerSource.getBBox();\n            sourceMarkerPoint = Point(sourcePoint).move(\n                firstWaypoint || targetPoint,\n                cache.sourceBBox.width * this._V.markerSource.scale().sx * -1\n            ).round();\n        }\n\n        if (this._V.markerTarget) {\n\n            cache.targetBBox = cache.targetBBox || this._V.markerTarget.getBBox();\n            targetMarkerPoint = Point(targetPoint).move(\n                lastWaypoint || sourcePoint,\n                cache.targetBBox.width * this._V.markerTarget.scale().sx * -1\n            ).round();\n        }\n\n        // if there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint\n        };\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (paperOptions.perpendicularLinks || this.options.perpendicular) {\n                    // Backwards compatibility\n                    // If `perpendicularLinks` flag is set on the paper and there are vertices\n                    // on the link, then try to find a connection point that makes the link perpendicular\n                    // even though the link won't point to the center of the targeted object.\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        // Backwards compatibility\n        if (typeof paperOptions.linkConnectionPoint === 'function') {\n            var linkConnectionMagnet = (magnet === view.el) ? undefined : magnet;\n            connectionPoint = paperOptions.linkConnectionPoint(this, view, linkConnectionMagnet, line.start, endType);\n            if (connectionPoint) return connectionPoint;\n        }\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    _translateConnectionPoints: function(tx, ty) {\n\n        var cache = this._markerCache;\n\n        cache.sourcePoint.offset(tx, ty);\n        cache.targetPoint.offset(tx, ty);\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        var defaultPosition = merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = merge({}, defaultPosition, labelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateToolsPosition: function() {\n\n        if (!this._V.linkTools) return this;\n\n        // Move the tools a bit to the target position but don't cover the `sourceArrowhead` marker.\n        // Note that the offset is hardcoded here. The offset should be always\n        // more than the `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n\n        var scale = '';\n        var offset = this.options.linkToolsOffset;\n        var connectionLength = this.getConnectionLength();\n\n        // Firefox returns connectionLength=NaN in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (!Number.isNaN(connectionLength)) {\n\n            // If the link is too short, make the tools half the size and the offset twice as low.\n            if (connectionLength < this.options.shortLinkLength) {\n                scale = 'scale(.5)';\n                offset /= 2;\n            }\n\n            var toolPosition = this.getPointAtLength(offset);\n\n            this._toolCache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n\n            if (this.options.doubleLinkTools && connectionLength >= this.options.longLinkLength) {\n\n                var doubleLinkToolsOffset = this.options.doubleLinkToolsOffset || offset;\n\n                toolPosition = this.getPointAtLength(connectionLength - doubleLinkToolsOffset);\n                this._tool2Cache.attr('transform', 'translate(' + toolPosition.x + ', ' + toolPosition.y + ') ' + scale);\n                this._tool2Cache.attr('visibility', 'visible');\n\n            } else if (this.options.doubleLinkTools) {\n\n                this._tool2Cache.attr('visibility', 'hidden');\n            }\n        }\n\n        return this;\n    },\n\n    updateArrowheadMarkers: function() {\n\n        if (!this._V.markerArrowheads) return this;\n\n        // getting bbox of an element with `display=\"none\"` in IE9 ends up with access violation\n        if ($.css(this._V.markerArrowheads.node, 'display') === 'none') return this;\n\n        var sx = this.getConnectionLength() < this.options.shortLinkLength ? .5 : 1;\n        this._V.sourceArrowhead.scale(sx);\n        this._V.targetArrowhead.scale(sx);\n\n        this._translateAndAutoOrientArrows(this._V.sourceArrowhead, this._V.targetArrowhead);\n\n        return this;\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _translateAndAutoOrientArrows: function(sourceArrow, targetArrow) {\n\n        // Make the markers \"point\" to their sticky points being auto-oriented towards\n        // `targetPosition`/`sourcePosition`. And do so only if there is a markup for them.\n        var route = toArray(this.route);\n        if (sourceArrow) {\n            sourceArrow.translateAndAutoOrient(\n                this.sourcePoint,\n                route[0] || this.targetPoint,\n                this.paper.cells\n            );\n        }\n\n        if (targetArrow) {\n            targetArrow.translateAndAutoOrient(\n                this.targetPoint,\n                route[route.length - 1] || this.sourcePoint,\n                this.paper.cells\n            );\n        }\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this.model.label(idx).position || {};\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this.model.label(idx).position || {};\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.directon` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if (isObject(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = V(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findBySelector(selector, this.el, this.selectors)[0];\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = routers;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(Point); // no router specified\n        }\n\n        var routerFn = isFunction(router) ? router : namespace[router.name];\n        if (!isFunction(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = connectors;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n        if (!isFunction(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = clone(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start;\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n                }\n            }\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start;\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return V.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        // Backwards compatibility for the default markup\n        var className = evt.target.getAttribute('class');\n        switch (className) {\n\n            case 'marker-vertex':\n                this.dragVertexStart(evt, x, y);\n                return;\n\n            case 'marker-vertex-remove':\n            case 'marker-vertex-remove-area':\n                this.dragVertexRemoveStart(evt, x, y);\n                return;\n\n            case 'marker-arrowhead':\n                this.dragArrowheadStart(evt, x, y);\n                return;\n\n            case 'connection':\n            case 'connection-wrap':\n                this.dragConnectionStart(evt, x, y);\n                return;\n\n            case 'marker-source':\n            case 'marker-target':\n                return;\n        }\n\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertex(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) assign(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'vertex-move':\n                this.dragVertexEnd(evt, x, y);\n                break;\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        // Backwards compatibility\n        var linkTool = V(evt.target).findParentByClass('link-tool', this.el);\n        if (linkTool) {\n            // No further action to be executed\n            evt.stopPropagation();\n\n            // Allow `interactive.useLinkTools=false`\n            if (this.can('useLinkTools')) {\n                if (eventName === 'remove') {\n                    // Built-in remove event\n                    this.model.remove({ ui: true });\n                    // Do not trigger link pointerdown\n                    return;\n\n                } else {\n                    // link:options and other custom events inside the link tools\n                    this.notify(eventName, evt, x, y);\n                }\n            }\n\n            this.notifyPointerdown(evt, x, y);\n            this.paper.delegateDragEvents(this, evt.data);\n\n        } else {\n            CellView.prototype.onevent.apply(this, arguments);\n        }\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragConnectionStart: function(evt, x, y) {\n\n        if (!this.can('vertexAdd')) return;\n\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        var vertexIdx = this.addVertex({ x: x, y: y }, { ui: true });\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragLabelStart: function(evt, _x, _y) {\n\n        if (this.can('labelMove')) {\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragVertexStart: function(evt, x, y) {\n\n        if (!this.can('vertexMove')) return;\n\n        var vertexNode = evt.target;\n        var vertexIdx = parseInt(vertexNode.getAttribute('idx'), 10);\n        this.eventData(evt, {\n            action: 'vertex-move',\n            vertexIdx: vertexIdx\n        });\n    },\n\n    dragVertexRemoveStart: function(evt, x, y) {\n\n        if (!this.can('vertexRemove')) return;\n\n        var removeNode = evt.target;\n        var vertexIdx = parseInt(removeNode.getAttribute('idx'), 10);\n        this.model.removeVertex(vertexIdx);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        this.model.label(data.labelIdx, label);\n    },\n\n    dragVertex: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.vertex(data.vertexIdx, { x: x, y: y }, { ui: true });\n    },\n\n    dragArrowhead: function(evt, x, y) {\n\n        if (this.paper.options.snapLinks) {\n\n            this._snapArrowhead(evt, x, y);\n\n        } else {\n\n            this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragVertexEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        // checking view in close area of the pointer\n\n        var r = this.paper.options.snapLinks.radius || 50;\n        var viewsInArea = this.paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new Point(x, y);\n        var paper = this.paper;\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n\n            if (!newClosestMagnet) return;\n\n            closestView.highlight(magnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: clone(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    }\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n"]},"metadata":{},"sourceType":"module"}